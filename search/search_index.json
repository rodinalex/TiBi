{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tibi","title":"TiBi","text":""},{"location":"#what-is-tibi","title":"What is TiBi?","text":"<p>TiBi is an app that performs Tight Binding calculations. It allows the User to construct the system using graphical means with no coding.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<ul> <li>\u2705 macOS (Apple Silicon &amp; Intel): binary available</li> <li>\u2705 Windows</li> <li>\u2705 Linux</li> </ul>"},{"location":"dev/architecture/","title":"Architecture","text":"<p>The project follows the MVC (Model-View-Controller) approach. In addition, it makes use of the Command pattern for Undo/Redo functionality, as well as Workers for multi-thread processes. </p>"},{"location":"dev/architecture/#project-structure","title":"Project Structure","text":"<pre><code>TiBi/\n\u251c\u2500\u2500 assets/                 # Documentation/Demo assets\n\u251c\u2500\u2500 docs/                   # Documentation \n\u251c\u2500\u2500 TiBi/                   # Main package\n\u2502   \u251c\u2500\u2500 app.py              # Entry point\n\u2502   \u251c\u2500\u2500 assets/             # Styling resources (e.g., icons)\n\u2502   \u251c\u2500\u2500 controllers/        # Application controllers\n\u2502   \u251c\u2500\u2500 core/               # Physics functions\n\u2502   \u251c\u2500\u2500 logic/              # App commands and data serialization\n\u2502   \u2502   \u251c\u2500\u2500 commands/       # Commands for Undo/Redo actions\n\u2502   \u2502   \u251c\u2500\u2500 serialization/  # Data serialization\n\u2502   \u2502   \u2514\u2500\u2500 workers/        # Workers for parallel threads\n\u2502   \u251c\u2500\u2500 models/             # Data models\n\u2502   \u251c\u2500\u2500 ui/                 # UI resources (styles, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 actions/        # Action manager\n\u2502   \u2502   \u251c\u2500\u2500 styles/         # UI styling\n\u2502   \u2502   \u2514\u2500\u2500 ...             # Constants and Utility *.py files\n\u2502   \u2514\u2500\u2500 views/              # UI views\n\u2502       \u251c\u2500\u2500 panels/         # View components\n\u2502       \u251c\u2500\u2500 widgets/        # View widgets\n\u2502       \u2514\u2500\u2500 ...             # Principal View *.py files\n\u251c\u2500\u2500 app_mac.spec            # macOS build config\n\u251c\u2500\u2500 app_win.spec            # Windows build config\n\u251c\u2500\u2500 app_linux.spec          # Linux build config\n\u251c\u2500\u2500 environment.yml         # Conda dependencies\n\u251c\u2500\u2500 requirements.txt        # pip dependencies\n\u251c\u2500\u2500 mkdocs.yml              # MkDocs settings\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"dev/controllers/","title":"Controllers","text":"<p>This page provides the documentation for the controllers used by the Application.</p>"},{"location":"dev/controllers/#TiBi.controllers.AppController","title":"<code>TiBi.controllers.AppController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Main application controller.</p> <p>This controller serves as a high-level coordinator in the application, handling communication between different subsystems. It connects signals from various controllers and routes requests to appropriate handlers, ensuring that components remain decoupled from each other.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>bz_plot_controller</code> <code>BrillouinZonePlotController</code> <p>Controller of the Broullouin zone graphical component</p> <code>computation_controller</code> <code>ComputationController</code> <p>Controller orchestrating computations</p> <code>main_ui_controller</code> <code>MainUIController</code> <p>Controller in charge of menus and toolbars</p> <code>plot_controller</code> <code>PlotController</code> <p>Controller of the results graphical component</p> <code>uc_controller</code> <code>UnitCellController</code> <p>Controller in charge of <code>UnitCell</code> creation/editing</p> <code>uc_plot_controller</code> <code>UnitCellPlotController</code> <p>Controller of the <code>UnitCell</code> graphical component</p> Source code in <code>TiBi/controllers/app_controller.py</code> <pre><code>class AppController(QObject):\n    \"\"\"\n    Main application controller.\n\n    This controller serves as a high-level coordinator in the application,\n    handling communication between different subsystems.\n    It connects signals from various controllers and routes requests to\n    appropriate handlers, ensuring that components remain decoupled from\n    each other.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    bz_plot_controller : BrillouinZonePlotController\n        Controller of the Broullouin zone graphical component\n    computation_controller : ComputationController\n        Controller orchestrating computations\n    main_ui_controller : MainUIController\n        Controller in charge of menus and toolbars\n    plot_controller : PlotController\n        Controller of the results graphical component\n    uc_controller : UnitCellController\n        Controller in charge of `UnitCell` creation/editing\n    uc_plot_controller : UnitCellPlotController\n        Controller of the `UnitCell` graphical component\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        bz_plot_controller: BrillouinZonePlotController,\n        computation_controller: ComputationController,\n        main_ui_controller: MainUIController,\n        plot_controller: PlotController,\n        uc_controller: UnitCellController,\n        uc_plot_controller: UnitCellPlotController,\n    ):\n        super().__init__()\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.bz_plot_controller = bz_plot_controller\n        self.computation_controller = computation_controller\n        self.main_ui_controller = main_ui_controller\n        self.plot_controller = plot_controller\n        self.uc_controller = uc_controller\n        self.uc_plot_controller = uc_plot_controller\n\n        # Connect signals\n        # Redraw the panels only when the unit cell selection changes.\n        # Selecting inside the unit cell should not cause redraws.\n        self.selection.unit_cell_updated.connect(self._update_panels)\n        # When a new site is selected, reddraw only the unit cell plot\n        self.selection.site_updated.connect(self._update_unit_cell_plot)\n\n        # bz_plot_controller\n        # When the path is updated, the bandstructure is cleared.\n        # We pass an empty band structure to the plotting function\n        # resulting in a cleared plot.\n        self.bz_plot_controller.bz_path_updated.connect(self._plot_bands)\n\n        # computation_controller\n        self.computation_controller.status_updated.connect(self._relay_status)\n        self.computation_controller.bands_plot_requested.connect(\n            self._plot_bands\n        )\n        self.computation_controller.dos_plot_requested.connect(self._plot_dos)\n        # Handle the programmatic selection of an item in the tree\n        # due to undo/redo in the hopping controller\n        self.computation_controller.selection_requested.connect(\n            self.uc_controller.select_item\n        )\n\n        # Handle the request to draw hopping segments after a pair of states\n        # is selected from the hopping button matrix\n        self.computation_controller.hopping_segments_requested.connect(\n            self._handle_hopping_segments_requested\n        )\n\n        # main_ui_controller\n        self.main_ui_controller.project_refresh_requested.connect(\n            self._handle_project_refresh_requested\n        )\n        self.main_ui_controller.unit_cell_update_requested.connect(\n            self._update_unit_cell_plot\n        )\n        # uc_controller\n        self.uc_controller.hopping_projection_update_requested.connect(\n            self._handle_hopping_projection_update\n        )\n        # If site parameter changes, the change is purely cosmetic,\n        # so the only the unit cell plot is redrawn\n        self.uc_controller.site_parameter_changed.connect(\n            self._update_unit_cell_plot\n        )\n        # Unit cell parameter changes typically invalidate\n        # derived quantities, requiring a full redraw.\n        self.uc_controller.unit_cell_parameter_changed.connect(\n            self._update_panels\n        )\n\n    def _relay_status(self, msg):\n        \"\"\"\n        Send a message to the status bar.\n\n        Parameters\n        ----------\n        msg : str\n            Message to be show in the status bar\n        \"\"\"\n        self.main_ui_controller.update_status(msg)\n\n    def _update_panels(self):\n        \"\"\"\n        Perform a full redraw of plots and panels.\n\n        This major update is called when the `UnitCell` selection changes,\n        `UnitCell` parameter changes or `Site` parameter changes.\n        \"\"\"\n        uc_id = self.selection.unit_cell\n        if uc_id is not None:\n            unit_cell = self.unit_cells[uc_id]\n\n            # Check which vectors of the unit cell are periodic and activate\n            # the UC spinners if they are\n            self.main_ui_controller.set_spinbox_status(\n                unit_cell.v1.is_periodic,\n                unit_cell.v2.is_periodic,\n                unit_cell.v3.is_periodic,\n            )\n\n        # Deactivate the spinners\n        else:\n            self.main_ui_controller.set_spinbox_status(False, False, False)\n\n        # Update the 3D plots for BZ and UC\n        self._update_unit_cell_plot()\n        self.bz_plot_controller.update_brillouin_zone()\n\n        # Update the computation panels\n        self.computation_controller.update_bands_panel()\n        self.computation_controller.update_hopping_panel()\n\n    def _handle_hopping_segments_requested(self):\n        \"\"\"\n        Draw hopping segments connecting the selected state pair.\n\n        After a pair of states is selected from the hopping button matrix,\n        this function passes them to the update_hopping_segments function\n        to draw the lines connecting the source state with the destination\n        ones. This approach avoids redrawing the rest of the plot.\n        \"\"\"\n        pair_selection = self.computation_controller.get_pair_selection()\n        self.uc_plot_controller.update_hopping_segments(pair_selection)\n\n    def _handle_hopping_projection_update(self):\n        \"\"\"\n        Redraw the hopping panels and the projection dropbox.\n\n        This function is necessary to make sure that the label names in the\n        hopping matrix, hopping table, and projection drop box\n        accurately reflect the item names. Additionally, if states are added\n        or removed, the hopping matrix needs to be updated.\n        \"\"\"\n        self.computation_controller.update_hopping_panel()\n        self.computation_controller.update_projection_combo()\n\n    def _handle_project_refresh_requested(self):\n        \"\"\"\n        Reset the selection and the tree, and do a full redraw.\n\n        The unit cell dictionary and\n        the project path have already been updated.\n        Here, only the selection and views are refreshed.\n        \"\"\"\n        # Current selection state (tracks which items are selected in the UI)\n        self.selection.set_selection(uc_id=None, site_id=None, state_id=None)\n        self.uc_controller.refresh_tree()\n        self._update_panels()\n\n    def _update_unit_cell_plot(self):\n        \"\"\"\n        Redraw the unit cell plot.\n\n        Called during the full panels update or when site parameters change.\n        \"\"\"\n        n1, n2, n3, wireframe_shown = (\n            self.main_ui_controller.get_uc_plot_properties()\n        )\n        self.uc_plot_controller.update_unit_cell(wireframe_shown, n1, n2, n3)\n        # If a pair of states is selected, also plot the hopping segments\n        pair_selection = self.computation_controller.get_pair_selection()\n        if pair_selection[0] is not None and pair_selection[1] is not None:\n            self.uc_plot_controller.update_hopping_segments(pair_selection)\n\n    def _plot_bands(self):\n        \"\"\"\n        Plot the bands for the selected `UnitCell`.\n        \"\"\"\n        idx = self.computation_controller.get_projection_indices()\n        self.plot_controller.plot_band_structure(idx)\n\n    def _plot_dos(self):\n        \"\"\"\n        Plot the DOS for the selected `UnitCell`.\n        \"\"\"\n        idx = self.computation_controller.get_projection_indices()\n        num_bins, plot_type, broadening = (\n            self.computation_controller.get_dos_properties()\n        )\n        self.plot_controller.plot_dos(num_bins, idx, plot_type, broadening)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.bands_controller.BandsController","title":"<code>TiBi.controllers.bands_controller.BandsController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller for the hopping parameter interface.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>bands_panel</code> <code>BandsPanel</code> <p>Main panel for bands and BZ grid calculations</p> <code>bands_plot_requested</code> <code>Signal</code> <p>Request band plots update.</p> <code>dos_plot_requested</code> <code>Signal</code> <p>Request DOS plots update.</p> <code>status_updated</code> <code>Signal(str)</code> <p>Update the status bar information.</p> <p>Methods:</p> Name Description <code>get_dos_properties</code> <p>Get the DOS properties for the plots.</p> <code>get_projection_indices</code> <p>Get the states selected for projection from the dropdown menu.</p> <code>update_bands_panel</code> <p>Update the <code>BandsPanel</code>.</p> <code>update_combo</code> <p>Update the states in the combo box.</p> Source code in <code>TiBi/controllers/bands_controller.py</code> <pre><code>class BandsController(QObject):\n    \"\"\"\n    Controller for the hopping parameter interface.\n\n    Attributes\n    ----------\n    unit_cells : dict[UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    bands_panel : BandsPanel\n        Main panel for bands and BZ grid calculations\n    bands_plot_requested : Signal\n        Request band plots update.\n    dos_plot_requested : Signal\n        Request DOS plots update.\n    status_updated : Signal(str)\n        Update the status bar information.\n\n    Methods\n    -------\n    get_dos_properties()\n        Get the DOS properties for the plots.\n    get_projection_indices()\n        Get the states selected for projection from the dropdown menu.\n    update_bands_panel()\n        Update the `BandsPanel`.\n    update_combo()\n        Update the states in the combo box.\n    \"\"\"\n\n    bands_plot_requested = Signal()\n    dos_plot_requested = Signal()\n    status_updated = Signal(str)\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        bands_panel: BandsPanel,\n    ):\n        super().__init__()\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.bands_panel = bands_panel\n        # Conenct the signals\n        self.bands_panel.compute_bands_btn.clicked.connect(self._compute_bands)\n        self.bands_panel.compute_grid_btn.clicked.connect(self._compute_grid)\n        self.bands_panel.proj_combo.selection_changed.connect(\n            lambda _: (\n                self.bands_plot_requested.emit()\n                if (self.bands_panel.radio_group.checkedId() == 0)\n                else self.dos_plot_requested.emit()\n            )\n        )\n        self.bands_panel.select_all_btn.clicked.connect(\n            self.bands_panel.proj_combo.select_all\n        )\n        self.bands_panel.clear_all_btn.clicked.connect(\n            self.bands_panel.proj_combo.clear_selection\n        )\n        # Toggle whether to show bands or DOS:\n        self.bands_panel.radio_group.buttonToggled.connect(\n            lambda _, checked: (\n                (\n                    self.bands_plot_requested.emit()\n                    if (self.bands_panel.radio_group.checkedId() == 0)\n                    else self.dos_plot_requested.emit()\n                )\n                if checked\n                else None\n            )\n        )\n        # Toggle between Histogram and Lorentzian.\n        # Only trigger if DOS is selected\n        self.bands_panel.presentation_choice_group.buttonToggled.connect(\n            lambda _, checked: (\n                self.dos_plot_requested.emit()\n                if (\n                    checked and (self.bands_panel.radio_group.checkedId() == 1)\n                )\n                else None\n            )\n        )\n        # Trigger plots when changing broadening or bin number\n        self.bands_panel.broadening_spinbox.editingConfirmed.connect(\n            lambda: (\n                None\n                if (self.bands_panel.radio_group.checkedId() == 0)\n                else self.dos_plot_requested.emit()\n            )\n        )\n        self.bands_panel.num_bins_spinbox.editingConfirmed.connect(\n            lambda: (\n                None\n                if (self.bands_panel.radio_group.checkedId() == 0)\n                else self.dos_plot_requested.emit()\n            )\n        )\n        # Update the approximate output sizes\n        self.bands_panel.n_points_spinbox.valueChanged.connect(\n            self._set_approximate_band_output\n        )\n        self.bands_panel.v1_points_spinbox.valueChanged.connect(\n            self._set_approximate_BZ_output\n        )\n        self.bands_panel.v2_points_spinbox.valueChanged.connect(\n            self._set_approximate_BZ_output\n        )\n        self.bands_panel.v3_points_spinbox.valueChanged.connect(\n            self._set_approximate_BZ_output\n        )\n        self.selection.selection_changed.connect(\n            self._set_approximate_band_output\n        )\n\n        self.selection.selection_changed.connect(\n            self._set_approximate_BZ_output\n        )\n\n    def _set_approximate_band_output(self, _=None):\n        \"\"\"\n        Update the approximate output size label.\n        \"\"\"\n        n_pts = self.bands_panel.n_points_spinbox.value()\n        if self.selection.unit_cell:\n            n_states = len(\n                self.unit_cells[self.selection.unit_cell].get_states()[0]\n            )\n            # The multiplication by 10 is due to JSON overhead\n            # (not being binary)\n            res = n_pts * (16 * n_states**2 + 8 * n_states) * 10\n        else:\n            res = 0\n        self.bands_panel.approximate_band_size.setText(\n            f\"Approximate output size: {res // 1000} kB\"\n        )\n\n    def _set_approximate_BZ_output(self, _=None):\n        \"\"\"\n        Update the approximate output size label.\n        \"\"\"\n\n        n_pts = [\n            y\n            for y in [\n                x.value() * x.isEnabled()\n                for x in [\n                    self.bands_panel.v1_points_spinbox,\n                    self.bands_panel.v2_points_spinbox,\n                    self.bands_panel.v3_points_spinbox,\n                ]\n            ]\n            if y &gt; 0\n        ]\n        if len(n_pts) == 0:\n            n_pts = 0\n        else:\n            n_pts = np.prod(n_pts)\n        if self.selection.unit_cell:\n            n_states = len(\n                self.unit_cells[self.selection.unit_cell].get_states()[0]\n            )\n            # The multiplication by 10 is due to JSON overhead\n            # (not being binary)\n            res = n_pts * (16 * n_states**2 + 8 * n_states) * 10\n        else:\n            res = 0\n        self.bands_panel.approximate_BZ_grid_size.setText(\n            f\"Approximate output size: {res // 1000} kB\"\n        )\n\n    def _compute_bands(self):\n        \"\"\"\n        Calculate the electronic band structure along a specified k-path.\n\n        The path is defined by the special points in the Brillouin zone.\n        \"\"\"\n        # Set the radio toggle to the correct option\n        for b in self.bands_panel.radio_group.buttons():\n            b.blockSignals(True)\n\n        self.bands_panel.bands_radio.setChecked(True)\n\n        for b in self.bands_panel.radio_group.buttons():\n            b.blockSignals(False)\n\n        # Get the selected unit cell\n        uc_id = self.selection.unit_cell\n        unit_cell = self.unit_cells[uc_id]\n\n        # Check if the coupling is Hermitian and only then calculate\n        if not unit_cell.is_hermitian():\n            self.status_updated.emit(\n                \"Computation halted: the system is non-Hermitian\"\n            )\n            return\n        self.status_updated.emit(\"Band structure calculation started...\")\n        num_points = self.bands_panel.n_points_spinbox.value()\n\n        # Get Hamiltonian function\n        hamiltonian_func = unit_cell.get_hamiltonian_function()\n\n        # Perform calculation\n        k_path = interpolate_k_path(\n            unit_cell.bandstructure.special_points, num_points\n        )\n\n        # Perform calculation on a separate thread\n        self.worker = DiagonalizationWorker(hamiltonian_func, k_path)\n        self.thread = QThread()\n\n        self.worker.moveToThread(self.thread)\n        self.thread.started.connect(self.worker.do_work)\n        self.worker.task_finished.connect(self._handle_band_results)\n\n        self.dialog = ProgressDialog()\n        self.worker.progress_updated.connect(self.dialog.update_progress)\n        self.worker.task_finished.connect(self.dialog.accept)\n        self.worker.task_aborted.connect(self.dialog.reject)\n        self.dialog.cancel_requested.connect(\n            self.worker.request_abort, Qt.DirectConnection\n        )\n\n        # Cleanup\n        self.worker.task_finished.connect(self.thread.quit)\n        self.worker.task_aborted.connect(self.thread.quit)\n        self.thread.finished.connect(self.thread.deleteLater)\n\n        self.thread.start()\n        # Only show the dialog after a delay if it's still running\n        self._show_timer = QTimer(self)\n        self._show_timer.setSingleShot(True)\n\n        def maybe_show_dialog():\n            if self.thread.isRunning():\n                self.dialog.show()\n\n        self._show_timer.timeout.connect(maybe_show_dialog)\n        self._show_timer.start(150)  # Delay in ms\n\n        # Wait for the thread to finish and kill the timer if needed\n        self.thread.finished.connect(self._show_timer.stop)\n\n    def _handle_band_results(self, res):\n        \"\"\"\n        Handle the results of the band structure calculation.\n\n        Parameters\n        ----------\n        res : tuple[list[NDArray[np.float64]], \\\n            list[NDArray[np.float64]], list[NDArray[np.float64]]]\n            Contains the eigenvalues, eigenvectors, and k-points\n        \"\"\"\n        self.status_updated.emit(\"Band structure calculation completed.\")\n\n        uc_id = self.selection.unit_cell\n        unit_cell = self.unit_cells[uc_id]\n\n        eigenvalues, eigenvectors, k_path = res\n        unit_cell.bandstructure.eigenvalues = eigenvalues\n        unit_cell.bandstructure.eigenvectors = eigenvectors\n        unit_cell.bandstructure.path = k_path\n        # Update combo to make sure all sites are selected\n        self.update_combo()\n\n    def _compute_grid(self):\n        \"\"\"\n        Calculate the BZ grid using the settings from the panel.\n        \"\"\"\n        # Set the radio toggle to the correct option\n        for b in self.bands_panel.radio_group.buttons():\n            b.blockSignals(True)\n\n        self.bands_panel.dos_radio.setChecked(True)\n\n        for b in self.bands_panel.radio_group.buttons():\n            b.blockSignals(False)\n\n        # Get the selected unit cell\n        uc_id = self.selection.unit_cell\n        unit_cell = self.unit_cells[uc_id]\n\n        # Check if the coupling is Hermitian and only then calculate\n        if not unit_cell.is_hermitian():\n            self.status_updated.emit(\n                \"Computation halted: the system is non-Hermitian\"\n            )\n            return\n        self.status_updated.emit(\"BZ grid calculation started...\")\n        k_points = get_BZ_grid(\n            unit_cell=unit_cell,\n            n1=self.bands_panel.v1_points_spinbox.value(),\n            n2=self.bands_panel.v2_points_spinbox.value(),\n            n3=self.bands_panel.v3_points_spinbox.value(),\n            typ=self.bands_panel.grid_choice_group.checkedId(),\n        )\n\n        # Get Hamiltonian function\n        hamiltonian_func = unit_cell.get_hamiltonian_function()\n\n        self.status_updated.emit(\"Computing the grid\")\n        # Perform calculation on a separate thread\n        self.worker = DiagonalizationWorker(hamiltonian_func, k_points)\n        self.thread = QThread()\n\n        self.worker.moveToThread(self.thread)\n        self.thread.started.connect(self.worker.do_work)\n        self.worker.task_finished.connect(self._handle_grid_results)\n\n        self.dialog = ProgressDialog()\n        self.worker.progress_updated.connect(self.dialog.update_progress)\n        self.worker.task_finished.connect(self.dialog.accept)\n        self.worker.task_aborted.connect(self.dialog.reject)\n        self.dialog.cancel_requested.connect(\n            self.worker.request_abort, Qt.DirectConnection\n        )\n\n        # Cleanup\n        self.worker.task_finished.connect(self.thread.quit)\n        self.worker.task_aborted.connect(self.thread.quit)\n        self.thread.finished.connect(self.thread.deleteLater)\n\n        self.thread.start()\n        # Only show the dialog after a delay if it's still running\n        self._show_timer = QTimer(self)\n        self._show_timer.setSingleShot(True)\n\n        def maybe_show_dialog():\n            if self.thread.isRunning():\n                self.dialog.show()\n\n        self._show_timer.timeout.connect(maybe_show_dialog)\n        self._show_timer.start(150)  # Delay in ms\n\n        # Wait for the thread to finish and kill the timer if needed\n        self.thread.finished.connect(self._show_timer.stop)\n\n    def _handle_grid_results(self, res):\n        \"\"\"\n        Handle the results of the BZ grid calculation.\n\n        Parameters\n        ----------\n        res : tuple[list[NDArray[np.float64]], \\\n            list[NDArray[np.float64]], list[NDArray[np.float64]]]\n            Contains the eigenvalues, eigenvectors, and k-points\n        \"\"\"\n        self.status_updated.emit(\"BZ grid calculation completed.\")\n        uc_id = self.selection.unit_cell\n        unit_cell = self.unit_cells[uc_id]\n\n        eigenvalues, eigenvectors, k_points = res\n\n        unit_cell.bz_grid.grid_divs = (\n            self.bands_panel.v1_points_spinbox.value(),\n            self.bands_panel.v2_points_spinbox.value(),\n            self.bands_panel.v3_points_spinbox.value(),\n        )\n        unit_cell.bz_grid.eigenvalues = eigenvalues\n        unit_cell.bz_grid.eigenvectors = eigenvectors\n        unit_cell.bz_grid.k_points = k_points\n        unit_cell.bz_grid.is_gamma_centered = bool(\n            self.bands_panel.grid_choice_group.checkedId()\n        )\n        # Update combo to make sure all sites are selected\n        self.update_combo()\n\n    def update_bands_panel(self):\n        \"\"\"\n        Update the `BandsPanel`.\n\n        The UI components are activated/deactivated based on\n        the system parameters.\n        Projection menu is also updated programmatically.\n        Selection is set to \"bands\"\n        \"\"\"\n        # Set the radio toggle to bands\n        for b in self.bands_panel.radio_group.buttons():\n            b.blockSignals(True)\n\n        self.bands_panel.bands_radio.setChecked(True)\n\n        for b in self.bands_panel.radio_group.buttons():\n            b.blockSignals(False)\n        uc_id = self.selection.unit_cell\n        if uc_id is None:\n            dim = 0\n        else:\n            unit_cell = self.unit_cells[uc_id]\n            # Get the system dimensionality\n            dim = (\n                unit_cell.v1.is_periodic\n                + unit_cell.v2.is_periodic\n                + unit_cell.v3.is_periodic\n            )\n            # Fill out the fields\n            bandstructure = unit_cell.bandstructure\n            bz_grid = unit_cell.bz_grid\n\n            if bandstructure.path:\n                self.bands_panel.n_points_spinbox.setValue(\n                    len(bandstructure.path)\n                )\n            else:\n                self.bands_panel.n_points_spinbox.setValue(100)\n            # Set the type of the grid\n            self.bands_panel.grid_choice_group.button(\n                bz_grid.is_gamma_centered\n            ).setChecked(True)\n            self.bands_panel.v1_points_spinbox.setValue(bz_grid.grid_divs[0])\n            self.bands_panel.v2_points_spinbox.setValue(bz_grid.grid_divs[1])\n            self.bands_panel.v3_points_spinbox.setValue(bz_grid.grid_divs[2])\n\n        # BZ path selection buttons\n        # Activate/deactivate buttons based on dimensionality\n        self.bands_panel.add_gamma_btn.setEnabled(dim &gt; 0)\n        for btn in self.bands_panel.vertex_btns:\n            btn.setEnabled(dim &gt; 0)\n        for btn in self.bands_panel.edge_btns:\n            btn.setEnabled(dim &gt; 1)\n        for btn in self.bands_panel.face_btns:\n            btn.setEnabled(dim &gt; 2)\n\n        # Computation and BZ path buttons\n        if uc_id is None:\n            self.bands_panel.remove_last_btn.setEnabled(False)\n            self.bands_panel.clear_path_btn.setEnabled(False)\n            self.bands_panel.compute_bands_btn.setEnabled(False)\n\n        else:\n            self.bands_panel.remove_last_btn.setEnabled(\n                len(unit_cell.bandstructure.special_points) &gt; 0\n            )\n            self.bands_panel.clear_path_btn.setEnabled(\n                len(unit_cell.bandstructure.special_points) &gt; 0\n            )\n            self.bands_panel.compute_bands_btn.setEnabled(\n                len(unit_cell.bandstructure.special_points) &gt; 1\n            )\n\n        # BZ grid spinboxes\n        self.bands_panel.v1_points_spinbox.setEnabled(dim &gt; 0)\n        self.bands_panel.v2_points_spinbox.setEnabled(dim &gt; 1)\n        self.bands_panel.v3_points_spinbox.setEnabled(dim &gt; 2)\n\n        # BZ grid spinboxes and button\n        self.bands_panel.v1_points_spinbox.setEnabled(dim &gt; 0)\n        self.bands_panel.v2_points_spinbox.setEnabled(dim &gt; 1)\n        self.bands_panel.v3_points_spinbox.setEnabled(dim &gt; 2)\n        self.bands_panel.compute_grid_btn.setEnabled(dim &gt; 0)\n\n        # Update the projection combo\n        self.update_combo()\n\n        # Update the approximate output size labels\n        self._set_approximate_band_output()\n        self._set_approximate_BZ_output()\n\n    def update_combo(self):\n        \"\"\"\n        Update the states in the combo box.\n\n        Once the items are updated, the selection buttons are activated\n        if the number of items is not zero. Additionally, all the items\n        are selected programatically.\n        \"\"\"\n        uc_id = self.selection.unit_cell\n        if uc_id is None:\n            items = []\n        else:\n            unit_cell = self.unit_cells[uc_id]\n            _, state_info = unit_cell.get_states()\n            items = [f\"{s[0]}.{s[2]}\" for s in state_info]\n        self.bands_panel.proj_combo.refresh_combo(items)\n        self.bands_panel.select_all_btn.setEnabled(len(items) &gt; 0)\n        self.bands_panel.clear_all_btn.setEnabled(len(items) &gt; 0)\n        self.bands_panel.proj_combo.select_all()\n\n    def get_projection_indices(self):\n        \"\"\"\n        Get the indices of the selected states from the projection menu.\n\n        Returns\n        -------\n        list[int]\n            Indices of the selected states\n        \"\"\"\n        return self.bands_panel.proj_combo.checked_items()\n\n    def get_dos_properties(self):\n        \"\"\"\n        Get the DOS properties for the plots.\n\n        Returns\n        -------\n        tuple[int, int, np.float64]\n            Number of bins/points to be used in the plot, the plot type\n            (0 for a histogram, 1 for Lorentzian), and Lorentzian broadening\n        \"\"\"\n        num_bins = self.bands_panel.num_bins_spinbox.value()\n        plot_type = self.bands_panel.presentation_choice_group.checkedId()\n        broadening = self.bands_panel.broadening_spinbox.value()\n        return (num_bins, plot_type, broadening)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.bands_controller.BandsController.get_dos_properties","title":"<code>get_dos_properties()</code>","text":"<p>Get the DOS properties for the plots.</p> <p>Returns:</p> Type Description <code>tuple[int, int, float64]</code> <p>Number of bins/points to be used in the plot, the plot type (0 for a histogram, 1 for Lorentzian), and Lorentzian broadening</p> Source code in <code>TiBi/controllers/bands_controller.py</code> <pre><code>def get_dos_properties(self):\n    \"\"\"\n    Get the DOS properties for the plots.\n\n    Returns\n    -------\n    tuple[int, int, np.float64]\n        Number of bins/points to be used in the plot, the plot type\n        (0 for a histogram, 1 for Lorentzian), and Lorentzian broadening\n    \"\"\"\n    num_bins = self.bands_panel.num_bins_spinbox.value()\n    plot_type = self.bands_panel.presentation_choice_group.checkedId()\n    broadening = self.bands_panel.broadening_spinbox.value()\n    return (num_bins, plot_type, broadening)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.bands_controller.BandsController.get_projection_indices","title":"<code>get_projection_indices()</code>","text":"<p>Get the indices of the selected states from the projection menu.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>Indices of the selected states</p> Source code in <code>TiBi/controllers/bands_controller.py</code> <pre><code>def get_projection_indices(self):\n    \"\"\"\n    Get the indices of the selected states from the projection menu.\n\n    Returns\n    -------\n    list[int]\n        Indices of the selected states\n    \"\"\"\n    return self.bands_panel.proj_combo.checked_items()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.bands_controller.BandsController.update_bands_panel","title":"<code>update_bands_panel()</code>","text":"<p>Update the <code>BandsPanel</code>.</p> <p>The UI components are activated/deactivated based on the system parameters. Projection menu is also updated programmatically. Selection is set to \"bands\"</p> Source code in <code>TiBi/controllers/bands_controller.py</code> <pre><code>def update_bands_panel(self):\n    \"\"\"\n    Update the `BandsPanel`.\n\n    The UI components are activated/deactivated based on\n    the system parameters.\n    Projection menu is also updated programmatically.\n    Selection is set to \"bands\"\n    \"\"\"\n    # Set the radio toggle to bands\n    for b in self.bands_panel.radio_group.buttons():\n        b.blockSignals(True)\n\n    self.bands_panel.bands_radio.setChecked(True)\n\n    for b in self.bands_panel.radio_group.buttons():\n        b.blockSignals(False)\n    uc_id = self.selection.unit_cell\n    if uc_id is None:\n        dim = 0\n    else:\n        unit_cell = self.unit_cells[uc_id]\n        # Get the system dimensionality\n        dim = (\n            unit_cell.v1.is_periodic\n            + unit_cell.v2.is_periodic\n            + unit_cell.v3.is_periodic\n        )\n        # Fill out the fields\n        bandstructure = unit_cell.bandstructure\n        bz_grid = unit_cell.bz_grid\n\n        if bandstructure.path:\n            self.bands_panel.n_points_spinbox.setValue(\n                len(bandstructure.path)\n            )\n        else:\n            self.bands_panel.n_points_spinbox.setValue(100)\n        # Set the type of the grid\n        self.bands_panel.grid_choice_group.button(\n            bz_grid.is_gamma_centered\n        ).setChecked(True)\n        self.bands_panel.v1_points_spinbox.setValue(bz_grid.grid_divs[0])\n        self.bands_panel.v2_points_spinbox.setValue(bz_grid.grid_divs[1])\n        self.bands_panel.v3_points_spinbox.setValue(bz_grid.grid_divs[2])\n\n    # BZ path selection buttons\n    # Activate/deactivate buttons based on dimensionality\n    self.bands_panel.add_gamma_btn.setEnabled(dim &gt; 0)\n    for btn in self.bands_panel.vertex_btns:\n        btn.setEnabled(dim &gt; 0)\n    for btn in self.bands_panel.edge_btns:\n        btn.setEnabled(dim &gt; 1)\n    for btn in self.bands_panel.face_btns:\n        btn.setEnabled(dim &gt; 2)\n\n    # Computation and BZ path buttons\n    if uc_id is None:\n        self.bands_panel.remove_last_btn.setEnabled(False)\n        self.bands_panel.clear_path_btn.setEnabled(False)\n        self.bands_panel.compute_bands_btn.setEnabled(False)\n\n    else:\n        self.bands_panel.remove_last_btn.setEnabled(\n            len(unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.bands_panel.clear_path_btn.setEnabled(\n            len(unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.bands_panel.compute_bands_btn.setEnabled(\n            len(unit_cell.bandstructure.special_points) &gt; 1\n        )\n\n    # BZ grid spinboxes\n    self.bands_panel.v1_points_spinbox.setEnabled(dim &gt; 0)\n    self.bands_panel.v2_points_spinbox.setEnabled(dim &gt; 1)\n    self.bands_panel.v3_points_spinbox.setEnabled(dim &gt; 2)\n\n    # BZ grid spinboxes and button\n    self.bands_panel.v1_points_spinbox.setEnabled(dim &gt; 0)\n    self.bands_panel.v2_points_spinbox.setEnabled(dim &gt; 1)\n    self.bands_panel.v3_points_spinbox.setEnabled(dim &gt; 2)\n    self.bands_panel.compute_grid_btn.setEnabled(dim &gt; 0)\n\n    # Update the projection combo\n    self.update_combo()\n\n    # Update the approximate output size labels\n    self._set_approximate_band_output()\n    self._set_approximate_BZ_output()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.bands_controller.BandsController.update_combo","title":"<code>update_combo()</code>","text":"<p>Update the states in the combo box.</p> <p>Once the items are updated, the selection buttons are activated if the number of items is not zero. Additionally, all the items are selected programatically.</p> Source code in <code>TiBi/controllers/bands_controller.py</code> <pre><code>def update_combo(self):\n    \"\"\"\n    Update the states in the combo box.\n\n    Once the items are updated, the selection buttons are activated\n    if the number of items is not zero. Additionally, all the items\n    are selected programatically.\n    \"\"\"\n    uc_id = self.selection.unit_cell\n    if uc_id is None:\n        items = []\n    else:\n        unit_cell = self.unit_cells[uc_id]\n        _, state_info = unit_cell.get_states()\n        items = [f\"{s[0]}.{s[2]}\" for s in state_info]\n    self.bands_panel.proj_combo.refresh_combo(items)\n    self.bands_panel.select_all_btn.setEnabled(len(items) &gt; 0)\n    self.bands_panel.clear_all_btn.setEnabled(len(items) &gt; 0)\n    self.bands_panel.proj_combo.select_all()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.BrillouinZonePlotController","title":"<code>TiBi.controllers.BrillouinZonePlotController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller for the Brillouin zone plot view.</p> <p>This controller manages the 3D visualization of the Brillouin zone. It handles the visualization of selected high-symmetry points within the BZ and paths for band structure calculations.</p> <p>The controller observes two views: BZ plot itself and a panel in the computation view which allows one to select BZ points and create path.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>bz_plot_view</code> <code>BrillouinZonePlotView</code> <p>The view component for displaying the Brillouin zone</p> <code>computation_view</code> <code>ComputationView</code> <p>The view component that contains controls for creating a path in the BZ</p> <code>undo_stack</code> <code>QUndoStack</code> <p><code>QUndoStack</code> to hold \"undo-able\" commands</p> <code>unit_cell</code> <code>UnitCell</code> <p>The currently selected unit cell</p> <code>bz_plot_items</code> <code>dict</code> <p>Dictionary to store plot items</p> <code>dim</code> <code>int</code> <p>Dimensionality of the Brillouin zone</p> <code>bz_point_selection</code> <code>dict</code> <p>Indices of the selected high-symmetry points in the BZ</p> <code>bz_point_lists</code> <code>dict</code> <p>Lists of high-symmetry points, grouped by type</p> <code>bz_path_updated</code> <code>Signal</code> <p>Emitted when the BZ special points path is updated by adding or removing points. Triggers a redraw of the path in the plot.</p> <p>Methods:</p> Name Description <code>update_brillouin_zone</code> <p>Draw the Brillouin zone of the selected <code>UnitCell</code>.</p> Source code in <code>TiBi/controllers/bz_plot_controller.py</code> <pre><code>class BrillouinZonePlotController(QObject):\n    \"\"\"\n    Controller for the Brillouin zone plot view.\n\n    This controller manages the 3D visualization of the Brillouin zone.\n    It handles the visualization of selected high-symmetry points within\n    the BZ and paths for band structure calculations.\n\n    The controller observes two views: BZ plot itself and a panel in the\n    computation view which allows one to select BZ points and create\n    path.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    bz_plot_view : BrillouinZonePlotView\n        The view component for displaying the Brillouin zone\n    computation_view : ComputationView\n        The view component that contains controls for creating\n        a path in the BZ\n    undo_stack : QUndoStack\n        `QUndoStack` to hold \"undo-able\" commands\n    unit_cell : UnitCell\n        The currently selected unit cell\n    bz_plot_items : dict\n        Dictionary to store plot items\n    dim : int\n        Dimensionality of the Brillouin zone\n    bz_point_selection : dict\n        Indices of the selected high-symmetry points in the BZ\n    bz_point_lists : dict\n        Lists of high-symmetry points, grouped by type\n    bz_path_updated : Signal\n        Emitted when the BZ special points path is updated\n        by adding or removing points. Triggers a redraw of\n        the path in the plot.\n\n    Methods\n    -------\n    update_brillouin_zone()\n        Draw the Brillouin zone of the selected `UnitCell`.\n    \"\"\"\n\n    bz_path_updated = Signal()\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        bz_plot_view: BrillouinZonePlotView,\n        computation_view: ComputationView,\n        undo_stack: QUndoStack,\n    ):\n        super().__init__()\n\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.bz_plot_view = bz_plot_view\n        self.computation_view = computation_view\n        self.undo_stack = undo_stack\n\n        # Internal controller state\n        self.unit_cell = None\n        self.bz_plot_items = {}  # Dictionary to store plot items\n        self.dim = 0  # Dimensionality\n        # Indices of the selected high-symmetry points in the BZ\n        self.bz_point_selection = bz_point_selection_init()\n        # Lists of high-symmetry points, grouped by type\n        self.bz_point_lists = bz_point_lists_init()\n\n        self.bz_path_updated.connect(self._update_path_visualization)\n\n        # Signals from the ComputationView used for selecting/picking\n        # high-symmetry points in the BZ\n        self.computation_view.bands_panel.add_gamma_btn.clicked.connect(\n            lambda: self._add_point(\"gamma\")\n        )\n        self.computation_view.bands_panel.prev_vertex_btn.clicked.connect(\n            lambda: self._select_point(-1, \"vertex\")\n        )\n        self.computation_view.bands_panel.next_vertex_btn.clicked.connect(\n            lambda: self._select_point(+1, \"vertex\")\n        )\n        self.computation_view.bands_panel.add_vertex_btn.clicked.connect(\n            lambda: self._add_point(\"vertex\")\n        )\n        self.computation_view.bands_panel.prev_edge_btn.clicked.connect(\n            lambda: self._select_point(-1, \"edge\")\n        )\n        self.computation_view.bands_panel.next_edge_btn.clicked.connect(\n            lambda: self._select_point(+1, \"edge\")\n        )\n        self.computation_view.bands_panel.add_edge_btn.clicked.connect(\n            lambda: self._add_point(\"edge\")\n        )\n\n        self.computation_view.bands_panel.prev_face_btn.clicked.connect(\n            lambda: self._select_point(-1, \"face\")\n        )\n        self.computation_view.bands_panel.next_face_btn.clicked.connect(\n            lambda: self._select_point(+1, \"face\")\n        )\n\n        self.computation_view.bands_panel.add_face_btn.clicked.connect(\n            lambda: self._add_point(\"face\")\n        )\n\n        self.computation_view.bands_panel.remove_last_btn.clicked.connect(\n            self._remove_last_point\n        )\n        self.computation_view.bands_panel.clear_path_btn.clicked.connect(\n            self._clear_path\n        )\n\n    def update_brillouin_zone(self):\n        \"\"\"\n        Draw the Brillouin zone of the selected `UnitCell`.\n\n        This method is the core rendering function that:\n        1. Clears any existing visualization\n        2. Calculates the Brillouin zone vertices and faces\n        3. Renders the BZ wireframe and key points (Gamma, vertices,\n        edge midpoints, face centers)\n        4. Updates UI controls based on the dimensionality of the BZ\n\n        The method is triggered whenever the `UnitCell` changes or\n        a new unit cell is selected.\n        \"\"\"\n        uc_id = self.selection.unit_cell\n        # Clear previous plot items except axes\n        for key, item in list(self.bz_plot_items.items()):\n            self.bz_plot_view.view.removeItem(item)\n            del self.bz_plot_items[key]\n\n        # Indices of the selected high-symmetry points in the BZ\n        # The key is the type of the high symmetry point\n        # (\"face\", \"edge\", \"vertex\")\n        # The values are the cardinal indices of each type\n        self.bz_point_selection = bz_point_selection_init()\n        # Lists of high-symmetry points, grouped by type.\n        # The key is the type of the high symmetry point\n        # (\"face\", \"edge\", \"vertex\")\n        # The values are arrays of length-3 arrays of coordinates\n        self.bz_point_lists = bz_point_lists_init()\n\n        if uc_id is None:\n            return\n        else:\n            self.unit_cell = self.unit_cells[uc_id]\n\n        # Guard against 0-volume Brillouin zone: can occur in the process\n        # of creation of the unit cell or due to a mistake\n        if self.unit_cell.volume() == 0:\n            return\n\n        self.bz_vertices, self.bz_faces = self.unit_cell.get_BZ()\n\n        # Determine system dimensionality\n        self.dim = (\n            0 if len(self.bz_vertices) == 0 else len(self.bz_vertices[0])\n        )\n\n        # Extract vertices and faces from the BZ data\n        # Note: In 2D, the faces are equivalent to edges.\n        # In 3D, the faces are polygons.\n        self.bz_point_lists[\"vertex\"] = np.array(self.bz_vertices)\n\n        if self.dim == 2:\n            # Get the edge points\n            for edge in self.bz_faces:\n                # Midpoint of the edge\n                mid_point = np.mean(edge, axis=0)\n                self.bz_point_lists[\"edge\"].append(mid_point)\n            self.bz_point_lists[\"edge\"] = np.array(self.bz_point_lists[\"edge\"])\n\n        elif self.dim == 3:\n            # Use the set of unique edges to avoid duplication\n            # due to faces sharing edges\n            unique_edges = set()\n            edge_midpoints = []\n\n            for face in self.bz_faces:\n                for ii in range(len(face)):\n                    next_ii = (ii + 1) % len(face)\n                    v1 = tuple(face[ii])\n                    v2 = tuple(face[next_ii])\n                    edge = tuple(sorted((v1, v2)))\n                    if edge not in unique_edges:\n                        unique_edges.add(edge)\n                        midpoint = 0.5 * (np.array(v1) + np.array(v2))\n                        edge_midpoints.append(midpoint)\n\n                # Face midpoint (no duplication issue here)\n                face_mid = np.mean(face, axis=0)\n                self.bz_point_lists[\"face\"].append(face_mid)\n\n            self.bz_point_lists[\"edge\"] = np.array(edge_midpoints)\n            self.bz_point_lists[\"face\"] = np.array(self.bz_point_lists[\"face\"])\n\n        # Draw the path\n        self._update_path_visualization()\n        # Create the BZ wireframe by making edges\n        # (connect the vertices based on face data)\n        self._create_bz_wireframe()\n\n        # Plot the BZ points as spheres\n        # Add Gamma point at origin\n        sphere = self._make_point()\n        sphere.setColor((1, 1, 1, 1))\n\n        self.bz_plot_view.view.addItem(sphere)\n        self.bz_plot_items[\"Gamma\"] = sphere\n\n        # Plot points for vertices, edges, and faces\n        for typ, pt in self.bz_point_lists.items():\n            if len(pt) &gt; 0:\n                # Pad all the points of the same type\n                pt_3d = self._pad_to_3d(pt)\n                # Select the 1st point of the type\n                self.bz_point_selection[typ] = 0\n                # Loop over all the padded points\n                for ii, p in enumerate(pt_3d):\n                    # Make a sphere and position it\n                    # at the appropriate location\n                    sphere = self._make_point()\n                    sphere.translate(p[0], p[1], p[2])\n                    self.bz_plot_view.view.addItem(sphere)\n                    self.bz_plot_items[f\"bz_{typ}_{ii}\"] = sphere\n                    # Highlight the first point\n                    if ii == 0:\n                        sphere.setColor(self.bz_plot_view.selected_point_color)\n\n    def _create_bz_wireframe(self):\n        \"\"\"\n        Create a wireframe visualization of the Brillouin zone.\n\n        This method extracts edges from the Brillouin zone faces and creates a\n        GLLinePlotItem to visualize them.\n\n        For 2D BZ, the wireframe is a polygon outline.\n        For 3D BZ, the wireframe is the edges of the polyhedron.\n        \"\"\"\n        if len(self.bz_faces) &gt; 0:\n            unique_edges = set()\n\n            for face in self.bz_faces:\n                for ii in range(len(face)):\n                    next_ii = (ii + 1) % len(face)\n                    v1 = tuple(face[ii])\n                    v2 = tuple(face[next_ii])\n                    edge = tuple(sorted((v1, v2)))\n                    unique_edges.add(edge)\n\n            # Convert edges to line vertices\n            line_vertices = []\n            for v1, v2 in unique_edges:\n                line_vertices.extend([v1, v2])\n\n            # Make sure all the line vertices are 3D\n            line_vertices = self._pad_to_3d(line_vertices)\n\n            # Create a GLLinePlotItem for all BZ edges\n            bz_wireframe = gl.GLLinePlotItem(\n                pos=np.array(line_vertices),\n                color=(1, 1, 1, 0.8),\n                width=1,\n                mode=\"lines\",\n            )\n            self.bz_plot_view.view.addItem(bz_wireframe)\n            self.bz_plot_items[\"bz_wireframe\"] = bz_wireframe\n\n    def _make_point(self, vertex_size=0.20):\n        \"\"\"Create a sphere mesh item for a point in the BZ.\"\"\"\n        # vertex_size = 1 / (self.unit_cell.volume()) ** (1 / 3) / 4\n        return gl.GLMeshItem(\n            meshdata=gl.MeshData.sphere(rows=10, cols=10, radius=vertex_size),\n            smooth=True,\n            color=self.bz_plot_view.point_color,\n            shader=\"shaded\",\n        )\n\n    def _pad_to_3d(self, points) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Ensure points have 3D coordinates by padding with zeros if needed.\n\n        Parameters\n        ----------\n        points\n            Array of point coordinates\n\n        Returns\n        -------\n        NDArray\n            Array of points with 3D coordinates\n        \"\"\"\n        pad_width = 3 - self.dim\n        if pad_width &gt; 0:\n            return np.pad(points, ((0, 0), (0, pad_width)), mode=\"constant\")\n        return np.array(points)\n\n    def _select_point(self, step, typ):\n        \"\"\"\n        Select a point in the Brillouin zone based on type and\n        step direction.\n\n        This method implements the navigation through different types\n        of points in the BZ (vertices, edge midpoints, or face centers).\n        It updates the visual highlighting to show which point is currently\n        selected, and maintains the selection state.\n\n        Parameters\n        ----------\n        step : int\n            Direction to move in the selection\n            (+1 for next, -1 for previous)\n        typ : str\n            Type of point to select ('vertex', 'edge', or 'face')\n        \"\"\"\n        # Guard against empty vertex list\n        if len(self.bz_point_lists[typ]) == 0:\n            return\n\n        prev_point = self.bz_point_selection[typ]\n        # Update the selection index\n        if prev_point is None:\n            self.bz_point_selection[typ] = 0\n        else:\n            self.bz_point_selection[typ] = (prev_point + step) % len(\n                self.bz_point_lists[typ]\n            )\n            prev_key = f\"bz_{typ}_{prev_point}\"\n            self.bz_plot_items[prev_key].setColor(\n                self.bz_plot_view.point_color\n            )\n\n        new_key = f\"bz_{typ}_{self.bz_point_selection[typ]}\"\n        self.bz_plot_items[new_key].setColor(\n            self.bz_plot_view.selected_point_color\n        )\n\n    def _add_point(self, point: str):\n        \"\"\"\n        Add a selected point to the Brillouin zone path.\n\n        This method adds the currently selected point (of the specified type)\n        to the Brillouin zone path. The path is a sequence of k-points\n        that will be used for band structure calculations.\n        Points can be the origin (Gamma), vertices, edge midpoints, or\n        face centers depending on the dimensionality of the BZ.\n\n        Parameters\n        ----------\n        point : str\n            The type of point to add (\"gamma\", \"vertex\", \"edge\", or \"face\")\n        \"\"\"\n\n        if point == \"gamma\":\n            point_coord: NDArray[np.float64] = np.array([0.0] * self.dim)\n        else:\n            if (\n                self.bz_point_selection[point] is not None\n                and self.bz_point_lists[point] is not None\n            ):\n                point_coord: NDArray[np.float64] = np.array(\n                    self.bz_point_lists[point][self.bz_point_selection[point]]\n                )\n            else:\n                print(\"No point selected\")\n                return\n        self.undo_stack.push(\n            AddBZPointCommand(\n                unit_cell=self.unit_cell,\n                point=point_coord,\n                computation_view=self.computation_view,\n                signal=self.bz_path_updated,\n            )\n        )\n\n    def _remove_last_point(self):\n        \"\"\"Remove the last point added to the path.\"\"\"\n        self.undo_stack.push(\n            RemoveBZPointCommand(\n                unit_cell=self.unit_cell,\n                computation_view=self.computation_view,\n                signal=self.bz_path_updated,\n            )\n        )\n\n    def _clear_path(self):\n        \"\"\"Remove all points from the path.\"\"\"\n        self.undo_stack.push(\n            ClearBZPathCommand(\n                unit_cell=self.unit_cell,\n                computation_view=self.computation_view,\n                signal=self.bz_path_updated,\n            )\n        )\n\n    def _update_path_visualization(self):\n        \"\"\"\n        Update the visualization of the BZ path based on current path points.\n\n        This method creates or updates the visual representation of the k-path\n        in the Brillouin zone. The path is shown as a series of connected\n        line segments between the selected k-points.\n        The visualization helps users understand the path along which\n        the band structure will be calculated.\n\n        If the path has fewer than 2 points, no visualization is created.\n        \"\"\"\n        # Remove existing path visualization if it exists\n        if \"bz_path\" in self.bz_plot_items:\n            self.bz_plot_view.view.removeItem(self.bz_plot_items[\"bz_path\"])\n            del self.bz_plot_items[\"bz_path\"]\n        # Only create visualization if we have at least 2 points\n        if len(self.unit_cell.bandstructure.special_points) &lt; 2:\n            return\n\n        # Convert path points to 3D if needed\n        path_3d = self._pad_to_3d(self.unit_cell.bandstructure.special_points)\n        # Create line segments for the path\n        path_pos = []\n        for ii in range(len(path_3d) - 1):\n            # Add both points of each segment\n            path_pos.extend([path_3d[ii], path_3d[ii + 1]])\n        # Create the path visualization\n        path_object = gl.GLLinePlotItem(\n            pos=np.array(path_pos), color=CF_RED, width=5, mode=\"lines\"\n        )\n        self.bz_plot_view.view.addItem(path_object)\n        self.bz_plot_items[\"bz_path\"] = path_object\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.BrillouinZonePlotController.update_brillouin_zone","title":"<code>update_brillouin_zone()</code>","text":"<p>Draw the Brillouin zone of the selected <code>UnitCell</code>.</p> <p>This method is the core rendering function that: 1. Clears any existing visualization 2. Calculates the Brillouin zone vertices and faces 3. Renders the BZ wireframe and key points (Gamma, vertices, edge midpoints, face centers) 4. Updates UI controls based on the dimensionality of the BZ</p> <p>The method is triggered whenever the <code>UnitCell</code> changes or a new unit cell is selected.</p> Source code in <code>TiBi/controllers/bz_plot_controller.py</code> <pre><code>def update_brillouin_zone(self):\n    \"\"\"\n    Draw the Brillouin zone of the selected `UnitCell`.\n\n    This method is the core rendering function that:\n    1. Clears any existing visualization\n    2. Calculates the Brillouin zone vertices and faces\n    3. Renders the BZ wireframe and key points (Gamma, vertices,\n    edge midpoints, face centers)\n    4. Updates UI controls based on the dimensionality of the BZ\n\n    The method is triggered whenever the `UnitCell` changes or\n    a new unit cell is selected.\n    \"\"\"\n    uc_id = self.selection.unit_cell\n    # Clear previous plot items except axes\n    for key, item in list(self.bz_plot_items.items()):\n        self.bz_plot_view.view.removeItem(item)\n        del self.bz_plot_items[key]\n\n    # Indices of the selected high-symmetry points in the BZ\n    # The key is the type of the high symmetry point\n    # (\"face\", \"edge\", \"vertex\")\n    # The values are the cardinal indices of each type\n    self.bz_point_selection = bz_point_selection_init()\n    # Lists of high-symmetry points, grouped by type.\n    # The key is the type of the high symmetry point\n    # (\"face\", \"edge\", \"vertex\")\n    # The values are arrays of length-3 arrays of coordinates\n    self.bz_point_lists = bz_point_lists_init()\n\n    if uc_id is None:\n        return\n    else:\n        self.unit_cell = self.unit_cells[uc_id]\n\n    # Guard against 0-volume Brillouin zone: can occur in the process\n    # of creation of the unit cell or due to a mistake\n    if self.unit_cell.volume() == 0:\n        return\n\n    self.bz_vertices, self.bz_faces = self.unit_cell.get_BZ()\n\n    # Determine system dimensionality\n    self.dim = (\n        0 if len(self.bz_vertices) == 0 else len(self.bz_vertices[0])\n    )\n\n    # Extract vertices and faces from the BZ data\n    # Note: In 2D, the faces are equivalent to edges.\n    # In 3D, the faces are polygons.\n    self.bz_point_lists[\"vertex\"] = np.array(self.bz_vertices)\n\n    if self.dim == 2:\n        # Get the edge points\n        for edge in self.bz_faces:\n            # Midpoint of the edge\n            mid_point = np.mean(edge, axis=0)\n            self.bz_point_lists[\"edge\"].append(mid_point)\n        self.bz_point_lists[\"edge\"] = np.array(self.bz_point_lists[\"edge\"])\n\n    elif self.dim == 3:\n        # Use the set of unique edges to avoid duplication\n        # due to faces sharing edges\n        unique_edges = set()\n        edge_midpoints = []\n\n        for face in self.bz_faces:\n            for ii in range(len(face)):\n                next_ii = (ii + 1) % len(face)\n                v1 = tuple(face[ii])\n                v2 = tuple(face[next_ii])\n                edge = tuple(sorted((v1, v2)))\n                if edge not in unique_edges:\n                    unique_edges.add(edge)\n                    midpoint = 0.5 * (np.array(v1) + np.array(v2))\n                    edge_midpoints.append(midpoint)\n\n            # Face midpoint (no duplication issue here)\n            face_mid = np.mean(face, axis=0)\n            self.bz_point_lists[\"face\"].append(face_mid)\n\n        self.bz_point_lists[\"edge\"] = np.array(edge_midpoints)\n        self.bz_point_lists[\"face\"] = np.array(self.bz_point_lists[\"face\"])\n\n    # Draw the path\n    self._update_path_visualization()\n    # Create the BZ wireframe by making edges\n    # (connect the vertices based on face data)\n    self._create_bz_wireframe()\n\n    # Plot the BZ points as spheres\n    # Add Gamma point at origin\n    sphere = self._make_point()\n    sphere.setColor((1, 1, 1, 1))\n\n    self.bz_plot_view.view.addItem(sphere)\n    self.bz_plot_items[\"Gamma\"] = sphere\n\n    # Plot points for vertices, edges, and faces\n    for typ, pt in self.bz_point_lists.items():\n        if len(pt) &gt; 0:\n            # Pad all the points of the same type\n            pt_3d = self._pad_to_3d(pt)\n            # Select the 1st point of the type\n            self.bz_point_selection[typ] = 0\n            # Loop over all the padded points\n            for ii, p in enumerate(pt_3d):\n                # Make a sphere and position it\n                # at the appropriate location\n                sphere = self._make_point()\n                sphere.translate(p[0], p[1], p[2])\n                self.bz_plot_view.view.addItem(sphere)\n                self.bz_plot_items[f\"bz_{typ}_{ii}\"] = sphere\n                # Highlight the first point\n                if ii == 0:\n                    sphere.setColor(self.bz_plot_view.selected_point_color)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController","title":"<code>TiBi.controllers.ComputationController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller responsible for physics calculations within the application.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>computation_view</code> <code>ComputationView</code> <p>UI object containing the computation view</p> <code>hopping_controller</code> <code>HoppingController</code> <p>Child controller in charge of the hopping panel of the computation UI</p> <code>bands_controller</code> <code>BandsController</code> <p>Child controller in charge of the bands panel of the computation UI</p> <code>status_updated</code> <code>Signal(str)</code> <p>Signal emitted to update the status of the computation</p> <code>bands_plot_requested</code> <code>Signal</code> <p>Request bands plot. Re-emitting signal from <code>BandsController</code></p> <code>dos_plot_requested</code> <code>Signal</code> <p>Request DOS plot. Re-emitting signal from <code>BandsController</code></p> <code>hopping_segments_requested</code> <code>Signal</code> <p>Signal requesting the plotting of hopping segments in the unit cell plot. Re-emitting signal for the <code>HoppingController</code> when the user selects a pair of sites from the hopping matrix.</p> <code>selection_requested</code> <code>Signal(object, object, object)</code> <p>Signal requesting a programmatic selection. Re-emitting signal for the <code>HoppingController</code>.</p> <p>Methods:</p> Name Description <code>get_dos_properties</code> <p>Get the number of bins/points, plot type, and broadening.</p> <code>get_pair_selection</code> <p>Get the selected state pair from the hopping matrix, if any.</p> <code>get_projection_indices</code> <p>Get the projection indices from the projection combo.</p> <code>update_bands_panel</code> <p>Update the bands UI panel.</p> <code>update_hopping_panel</code> <p>Redraw the hoppings UI panel.</p> <code>update_projection_combo</code> <p>Update the projection combo in the bands panel.</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>class ComputationController(QObject):\n    \"\"\"\n    Controller responsible for physics calculations within the application.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    computation_view : ComputationView\n        UI object containing the computation view\n    hopping_controller : HoppingController\n        Child controller in charge of the hopping panel of the computation UI\n    bands_controller : BandsController\n        Child controller in charge of the bands panel of the computation UI\n    status_updated : Signal(str)\n        Signal emitted to update the status of the computation\n    bands_plot_requested : Signal\n        Request bands plot.\n        Re-emitting signal from `BandsController`\n    dos_plot_requested : Signal\n        Request DOS plot.\n        Re-emitting signal from `BandsController`\n    hopping_segments_requested : Signal\n        Signal requesting the plotting of hopping segments in the\n        unit cell plot. Re-emitting signal for the `HoppingController`\n        when the user selects a pair of sites from the hopping matrix.\n    selection_requested : Signal(object, object, object)\n        Signal requesting a programmatic selection. Re-emitting signal for\n        the `HoppingController`.\n\n    Methods\n    -------\n    get_dos_properties()\n        Get the number of bins/points, plot type, and broadening.\n    get_pair_selection()\n        Get the selected state pair from the hopping matrix, if any.\n    get_projection_indices()\n        Get the projection indices from the projection combo.\n    update_bands_panel()\n        Update the bands UI panel.\n    update_hopping_panel()\n        Redraw the hoppings UI panel.\n    update_projection_combo()\n        Update the projection combo in the bands panel.\n    \"\"\"\n\n    status_updated = Signal(str)\n    # Hopping controller signals to relay\n    hopping_segments_requested = Signal()\n    selection_requested = Signal(object, object, object)\n    # Band controller signals to relay\n    bands_plot_requested = Signal()\n    dos_plot_requested = Signal()\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        computation_view: ComputationView,\n        undo_stack: QUndoStack,\n    ):\n        super().__init__()\n        self.computation_view = computation_view\n        self.undo_stack = undo_stack\n\n        self.unit_cells = unit_cells\n        self.selection = selection\n        # Component controllers\n        self.hopping_controller = HoppingController(\n            self.unit_cells,\n            self.selection,\n            self.computation_view.hopping_panel,\n            self.undo_stack,\n        )\n        self.bands_controller = BandsController(\n            self.unit_cells, self.selection, self.computation_view.bands_panel\n        )\n        # Connect the signals\n        # Hoppings Panel\n        self.hopping_controller.hopping_segments_requested.connect(\n            self.hopping_segments_requested.emit\n        )\n        self.hopping_controller.selection_requested.connect(\n            self.selection_requested.emit\n        )\n        # Bands Panel\n        self.bands_controller.bands_plot_requested.connect(\n            self.bands_plot_requested.emit\n        )\n        self.bands_controller.dos_plot_requested.connect(\n            self.dos_plot_requested.emit\n        )\n        self.bands_controller.status_updated.connect(self.status_updated.emit)\n\n    def get_pair_selection(self):\n        \"\"\"\n        Get the selected state pair from the hopping matrix, if any.\n\n        Returns\n        -------\n        list[tuple]  | list[None]\n            List of selected states, if available, where the elements of\n            the list are (site_name, site_id, state_name, state_id).\n        \"\"\"\n        return self.hopping_controller.pair_selection\n\n    def update_hopping_panel(self):\n        \"\"\"\n        Redraw the hoppings UI panel.\n\n        This method is called when the user renames a tree item to make sure\n        that the matrix table contains the correct item names.\n        \"\"\"\n        self.hopping_controller.update_unit_cell()\n\n    def update_bands_panel(self):\n        \"\"\"\n        Update the bands UI panel.\n        \"\"\"\n        self.bands_controller.update_bands_panel()\n\n    def update_projection_combo(self):\n        \"\"\"\n        Update the projection combo in the bands panel.\n        \"\"\"\n        self.bands_controller.update_combo()\n\n    def get_projection_indices(self):\n        \"\"\"\n        Get the projection indices from the projection combo.\n        \"\"\"\n        return self.bands_controller.get_projection_indices()\n\n    def get_dos_properties(self):\n        \"\"\"\n        Get the number of bins/points, plot type, and broadening.\n\n        Returns\n        -------\n        tuple[int, int]\n            Number of bins/points to be used in the plot and the plot type\n            (0 for a histogram, 1 for Lorentzian)\n        \"\"\"\n        return self.bands_controller.get_dos_properties()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController.get_dos_properties","title":"<code>get_dos_properties()</code>","text":"<p>Get the number of bins/points, plot type, and broadening.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>Number of bins/points to be used in the plot and the plot type (0 for a histogram, 1 for Lorentzian)</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>def get_dos_properties(self):\n    \"\"\"\n    Get the number of bins/points, plot type, and broadening.\n\n    Returns\n    -------\n    tuple[int, int]\n        Number of bins/points to be used in the plot and the plot type\n        (0 for a histogram, 1 for Lorentzian)\n    \"\"\"\n    return self.bands_controller.get_dos_properties()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController.get_pair_selection","title":"<code>get_pair_selection()</code>","text":"<p>Get the selected state pair from the hopping matrix, if any.</p> <p>Returns:</p> Type Description <code>list[tuple] | list[None]</code> <p>List of selected states, if available, where the elements of the list are (site_name, site_id, state_name, state_id).</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>def get_pair_selection(self):\n    \"\"\"\n    Get the selected state pair from the hopping matrix, if any.\n\n    Returns\n    -------\n    list[tuple]  | list[None]\n        List of selected states, if available, where the elements of\n        the list are (site_name, site_id, state_name, state_id).\n    \"\"\"\n    return self.hopping_controller.pair_selection\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController.get_projection_indices","title":"<code>get_projection_indices()</code>","text":"<p>Get the projection indices from the projection combo.</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>def get_projection_indices(self):\n    \"\"\"\n    Get the projection indices from the projection combo.\n    \"\"\"\n    return self.bands_controller.get_projection_indices()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController.update_bands_panel","title":"<code>update_bands_panel()</code>","text":"<p>Update the bands UI panel.</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>def update_bands_panel(self):\n    \"\"\"\n    Update the bands UI panel.\n    \"\"\"\n    self.bands_controller.update_bands_panel()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController.update_hopping_panel","title":"<code>update_hopping_panel()</code>","text":"<p>Redraw the hoppings UI panel.</p> <p>This method is called when the user renames a tree item to make sure that the matrix table contains the correct item names.</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>def update_hopping_panel(self):\n    \"\"\"\n    Redraw the hoppings UI panel.\n\n    This method is called when the user renames a tree item to make sure\n    that the matrix table contains the correct item names.\n    \"\"\"\n    self.hopping_controller.update_unit_cell()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.ComputationController.update_projection_combo","title":"<code>update_projection_combo()</code>","text":"<p>Update the projection combo in the bands panel.</p> Source code in <code>TiBi/controllers/computation_controller.py</code> <pre><code>def update_projection_combo(self):\n    \"\"\"\n    Update the projection combo in the bands panel.\n    \"\"\"\n    self.bands_controller.update_combo()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.hopping_controller.HoppingController","title":"<code>TiBi.controllers.hopping_controller.HoppingController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller for the hopping parameter interface.</p> <p>This controller manages the creation and editing of hopping parameters (tight-binding matrix elements) between quantum states. It handles:</p> <ol> <li>The interactive matrix grid where each button represents a possible    hopping between two states</li> <li>The detailed parameter table for editing specific hopping values</li> <li>The right-click context menu for performing operations like creating    Hermitian partners</li> </ol> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>hopping_view</code> <code>HoppingPanel</code> <p>The main view component</p> <code>undo_stack</code> <code>QUndoStack</code> <p><code>QUndoStack</code> to hold \"undo-able\" commands</p> <code>state_info</code> <code>list[tuple]</code> <p>List of tuples with state information         (site_name, site_id, state_name, state_id)        for each <code>State</code> in the <code>UnitCell</code></p> <code>pair_selection</code> <code>list[tuple]</code> <p>2-element list of tuples containing the selected state pair</p> <code>hoppings</code> <code>dict[tuple[uuid, uuid], list[tuple[tuple[int, int, int], complex128]]]</code> <p>Dictionary containing the hopping parameters for the <code>UnitCell</code>. The keys are <code>State</code> UUID tuples. The values are lists of hoppings. Each hopping is a tuple of a displacement tuple, given in terms of lattice vectors, and a complex amplitude.</p> <code>btn_clicked</code> <code>Signal(object, object)</code> <p>Emitted when a hopping button is clicked. The Signal carries the source and destination state info following the (site_name, site_id, state_name, state_id) format.</p> <code>hoppings_changed</code> <code>Signal(object, object, object, object, object)</code> <p>Emitted by the command when couplings are modified. The signal carries the information about the current item selection, as well as the selection of the state pair. It triggers a table and matrix update.</p> <code>hopping_segments_requested</code> <code>Signal</code> <p>Emitted when the coupling table is updated, triggering an update of hopping segments.</p> <code>selection_requested</code> <code>Signal(object, object, object)</code> <p>Emitted when the selection change in the tree is required, carrying the unit cell, site, and state IDs.</p> <p>Methods:</p> Name Description <code>update_unit_cell</code> <p>Update the hopping data model with the <code>UnitCell</code>'s hoppings</p> Source code in <code>TiBi/controllers/hopping_controller.py</code> <pre><code>class HoppingController(QObject):\n    \"\"\"\n    Controller for the hopping parameter interface.\n\n    This controller manages the creation and editing of hopping parameters\n    (tight-binding matrix elements) between quantum states. It handles:\n\n    1. The interactive matrix grid where each button represents a possible\n       hopping between two states\n    2. The detailed parameter table for editing specific hopping values\n    3. The right-click context menu for performing operations like creating\n       Hermitian partners\n\n    Attributes\n    ----------\n    unit_cells : dict[UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    hopping_view : HoppingPanel\n        The main view component\n    undo_stack : QUndoStack\n        `QUndoStack` to hold \"undo-able\" commands\n    state_info : list[tuple]\n        List of tuples with state information \\\n        (site_name, site_id, state_name, state_id)\\\n        for each `State` in the `UnitCell`\n    pair_selection : list[tuple]\n        2-element list of tuples containing the selected state pair\n    hoppings : dict[tuple[uuid, uuid],\\\n            list[tuple[tuple[int, int, int], np.complex128]]]\n        Dictionary containing the hopping parameters for the `UnitCell`.\n        The keys are `State` UUID tuples. The values are lists of hoppings.\n        Each hopping is a tuple of a displacement tuple, given in\n        terms of lattice vectors, and a complex amplitude.\n    btn_clicked : Signal(object, object)\n        Emitted when a hopping button is clicked. The Signal carries the source\n        and destination state info following the\n        (site_name, site_id, state_name, state_id) format.\n    hoppings_changed : Signal(object, object, object, object, object)\n        Emitted by the command when couplings are modified.\n        The signal carries the information about the current item selection,\n        as well as the selection of the state pair. It triggers\n        a table and matrix update.\n    hopping_segments_requested : Signal\n        Emitted when the coupling table is updated, triggering an\n        update of hopping segments.\n    selection_requested : Signal(object, object, object)\n        Emitted when the selection change in the tree is required,\n        carrying the unit cell, site, and state IDs.\n\n    Methods\n    -------\n    update_unit_cell()\n        Update the hopping data model with the `UnitCell`'s hoppings\n    \"\"\"\n\n    btn_clicked = Signal(object, object)\n    hoppings_changed = Signal(object, object, object, object, object)\n    hopping_segments_requested = Signal()\n    selection_requested = Signal(object, object, object)\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        hopping_view: HoppingPanel,\n        undo_stack: QUndoStack,\n    ):\n        super().__init__()\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.hopping_view = hopping_view\n        self.undo_stack = undo_stack\n\n        # Internal controller state\n        self.state_info = []\n        self.pair_selection = [\n            None,\n            None,\n        ]\n        self.hoppings = {}\n\n        # Connect Signals\n        self.btn_clicked.connect(self._update_pair_selection)\n        self.hopping_view.table_panel.add_row_btn.clicked.connect(\n            self._add_empty_row\n        )\n        self.hopping_view.table_panel.remove_row_btn.clicked.connect(\n            self._remove_selected_coupling\n        )\n        self.hopping_view.table_panel.save_btn.clicked.connect(\n            self._save_couplings\n        )\n        self.hoppings_changed.connect(self._handle_hoppings_changed)\n\n    def update_unit_cell(self):\n        \"\"\"\n        Update the hopping data model with the selected `UnitCell`'s hoppings.\n\n        This method is called when the selection changes in the tree view.\n        It retrieves the currently selected unit cell and its hoppings,\n        refreshing the matrix.\n        \"\"\"\n        uc_id = self.selection.unit_cell\n        # Deselect the previous states\n        self._update_pair_selection(None, None)\n\n        # If no unit cell selected, hide the panels and exit early\n        if uc_id is None:\n            self.hopping_view.panel_stack.setCurrentWidget(\n                self.hopping_view.info_label\n            )\n            return\n\n        else:\n            uc = self.unit_cells[uc_id]\n\n            # Get the states and their \"info\" from inside the unit cell\n            _, new_info = uc.get_states()\n\n            # Use the states and the info to construct the hopping matrix grid\n            self.hoppings = uc.hoppings\n            self.state_info = new_info\n            # If there are no states in the unit cell, hide the panels\n            if new_info == []:\n                self.hopping_view.panel_stack.setCurrentWidget(\n                    self.hopping_view.info_label\n                )\n            else:\n                self.hopping_view.panel_stack.setCurrentWidget(\n                    self.hopping_view.panel\n                )\n                self._refresh_matrix()\n\n    def _refresh_matrix(self):\n        \"\"\"\n        Redraw the hopping matrix.\n\n        Button colors are updated based on whether hoppings\n        exist between states.\n        \"\"\"\n        # Clear existing widgets in grid layout\n        while self.hopping_view.matrix_panel.grid_layout.count():\n            item = self.hopping_view.matrix_panel.grid_layout.takeAt(0)\n            if item.widget():\n                item.widget().deleteLater()\n\n        # Configure grid layout to center the content\n        self.hopping_view.matrix_panel.grid_layout.setAlignment(Qt.AlignCenter)\n\n        # Create the button grid\n        self.buttons = {}\n        for ii in range(len(self.state_info)):\n            for jj in range(len(self.state_info)):\n                btn = QPushButton(\"\")\n                set_button_size(btn, \"small\")\n                btn.setContextMenuPolicy(Qt.CustomContextMenu)\n                btn.customContextMenuRequested.connect(\n                    lambda _, row=ii, col=jj, b=btn: self._add_context_menu(\n                        b, row, col\n                    )\n                )\n                # Get the states\n                state1 = self.state_info[ii]\n                state2 = self.state_info[jj]\n                # Apply button styles\n\n                hop = set(self.hoppings.get((state1[3], state2[3]), []))\n                hop_herm = set(self.hoppings.get((state2[3], state1[3]), []))\n                has_hopping = bool(hop)\n                hop_neg_conj = set(\n                    ((-d1, -d2, -d3), np.conj(x)) for ((d1, d2, d3), x) in hop\n                )\n                is_hermitian = hop_neg_conj == hop_herm\n                self._apply_button_style(btn, has_hopping, is_hermitian)\n\n                # Set tips to show both states when hovering.\n                # Show the state and site names.\n                # From second quantization, the hopping goes FROM column INTO\n                # row (columns multiply annihilation operators,\n                # rows multiply creation)\n                btn.setToolTip(\n                    f\"{state2[0]}.{state2[2]} \u2192 {state1[0]}.{state1[2]}\"\n                )\n                btn.setStatusTip(\n                    f\"{state2[0]}.{state2[2]} \u2192 {state1[0]}.{state1[2]}\"\n                )\n\n                # Button click handler implementation:\n                btn.clicked.connect(\n                    lambda checked=False, r=ii, c=jj: self.btn_clicked.emit(\n                        self.state_info[r],\n                        self.state_info[c],  # Format (TO_state, FROM_state)\n                    )\n                )\n                # Add the button to the grid\n                self.hopping_view.matrix_panel.grid_layout.addWidget(\n                    btn, ii, jj\n                )\n                # Save to the button dictionary\n                self.buttons[(ii, jj)] = btn\n\n    def _apply_button_style(\n        self, button: QPushButton, has_hopping, hermitian=False\n    ):\n        \"\"\"\n        Apply the appropriate style to a button based on its hoppings.\n\n        Parameters\n        ----------\n        button : QPushButton\n            The button to style\n        has_hopping : bool\n            Indicator whether the button marks a connection with hoppings\n        hermitian : bool\n            Boolean indicating whether the coupling is Hermitian\n        \"\"\"\n        if not has_hopping:\n            style = BUTTON_STYLE_DEFAULT\n        else:\n            if hermitian:\n                style = BUTTON_STYLE_HAS_HOPPING\n            else:\n                style = BUTTON_STYLE_NONHERMITIAN\n\n        button.setStyleSheet(style)\n\n    def _update_pair_selection(self, s1, s2):\n        \"\"\"\n        Update the pair selection and the table to display hopping terms.\n\n        Parameters\n        ----------\n        s1 : tuple[str, uuid.UUID, str, uuid.UUID] | None\n            Information tuple for the destination `State` (row)\n        s2 : tuple[str, uuid.UUID, str, uuid.UUID] | None\n            Information tuple for the source `State` (column)\n        \"\"\"\n\n        # Store the UUIDs of the selected states\n        self.pair_selection = [s1, s2]\n        if (s1 is None) or (s2 is None):\n            self.hopping_view.table_stack.setCurrentWidget(\n                self.hopping_view.table_info_label\n            )\n        else:\n            self.hopping_view.table_stack.setCurrentWidget(\n                self.hopping_view.table_panel\n            )\n\n            # Update the table title to show the selected states\n            # (source \u2192 destination)\n            self.hopping_view.table_panel.table_title.setText(\n                f\"{s2[0]}.{s2[2]} \u2192 {s1[0]}.{s1[2]}\"\n            )\n            self._refresh_table()\n\n    def _refresh_table(self):\n        \"\"\"Clear the table and repopulate it with the latest hopping terms\"\"\"\n        self.hopping_view.table_panel.hopping_table.setRowCount(\n            0\n        )  # Clear existing data\n        for (d1, d2, d3), amplitude in self.hoppings.get(\n            (self.pair_selection[0][3], self.pair_selection[1][3]), []\n        ):\n            row_index = self.hopping_view.table_panel.hopping_table.rowCount()\n            self.hopping_view.table_panel.hopping_table.insertRow(row_index)\n\n            # Use cell widgets instead of QTableWidgetItem\n            spinbox_d1 = self._make_spinbox(value=d1)\n            spinbox_d2 = self._make_spinbox(value=d2)\n            spinbox_d3 = self._make_spinbox(value=d3)\n            re_box = self._make_doublespinbox(value=np.real(amplitude))\n            im_box = self._make_doublespinbox(value=np.imag(amplitude))\n\n            self.hopping_view.table_panel.hopping_table.setCellWidget(\n                row_index, 0, spinbox_d1\n            )\n            self.hopping_view.table_panel.hopping_table.setCellWidget(\n                row_index, 1, spinbox_d2\n            )\n            self.hopping_view.table_panel.hopping_table.setCellWidget(\n                row_index, 2, spinbox_d3\n            )\n            self.hopping_view.table_panel.hopping_table.setCellWidget(\n                row_index, 3, re_box\n            )\n            self.hopping_view.table_panel.hopping_table.setCellWidget(\n                row_index, 4, im_box\n            )\n        self.hopping_segments_requested.emit()\n\n    def _make_spinbox(self, value=0, minimum=-99, maximum=99):\n        \"\"\"Auxiliary function to create a spinbox for hopping displacement\"\"\"\n        box = QSpinBox()\n        box.setRange(minimum, maximum)\n        box.setValue(value)\n        box.setButtonSymbols(QSpinBox.NoButtons)\n        return box\n\n    def _make_doublespinbox(\n        self, value=0.0, minimum=-1e6, maximum=1e6, decimals=3\n    ):\n        \"\"\"\n        Auxiliary function to create a double spinbox for hopping amplitude\n        \"\"\"\n        box = QDoubleSpinBox()\n        box.setRange(minimum, maximum)\n        box.setDecimals(decimals)\n        box.setValue(value)\n        box.setButtonSymbols(QDoubleSpinBox.NoButtons)\n\n        return box\n\n    def _add_empty_row(self):\n        \"\"\"Add a new empty row to the table\"\"\"\n        row_index = self.hopping_view.table_panel.hopping_table.rowCount()\n        self.hopping_view.table_panel.hopping_table.insertRow(row_index)\n\n        # Pre-fill with default values\n        self.hopping_view.table_panel.hopping_table.setCellWidget(\n            row_index, 0, self._make_spinbox()\n        )\n        self.hopping_view.table_panel.hopping_table.setCellWidget(\n            row_index, 1, self._make_spinbox()\n        )\n        self.hopping_view.table_panel.hopping_table.setCellWidget(\n            row_index, 2, self._make_spinbox()\n        )\n        self.hopping_view.table_panel.hopping_table.setCellWidget(\n            row_index, 3, self._make_doublespinbox()\n        )\n        self.hopping_view.table_panel.hopping_table.setCellWidget(\n            row_index, 4, self._make_doublespinbox()\n        )\n\n    def _remove_selected_coupling(self):\n        \"\"\"Remove selected row(s) from the table\"\"\"\n        selected_rows = set()\n\n        # Get the selection model from the table\n        selection_model = (\n            self.hopping_view.table_panel.hopping_table.selectionModel()\n        )\n\n        # Get the selected rows\n        selected_indexes = selection_model.selectedRows()\n\n        # Extract the row numbers from the selected indexes\n        for index in selected_indexes:\n            selected_rows.add(index.row())\n\n        # Remove the rows from the table in reverse order to avoid\n        # shifting issues\n        for row in sorted(selected_rows, reverse=True):\n            self.hopping_view.table_panel.hopping_table.removeRow(row)\n\n    def _save_couplings(self):\n        \"\"\"\n        Extract data from the hopping table and save it to the `UnitCell`.\n\n        Read all rows from the table, converting cell values to the\n        appropriate types:\n        - First 3 columns (d\u2081,d\u2082,d\u2083) to integers (displacement vector)\n        - Last 2 columns (Re(t), Im(t)) to floats (complex amplitude)\n\n        If the same triplet (d\u2081,d\u2082,d\u2083) appears more than once,\n        the amplitudes are summed. The data is then passed to the\n        `SaveHoppingsCommand` to update the unit cell model.\n        \"\"\"\n        new_couplings: dict[tuple[int, int, int], np.complex128] = {}\n        # Extract values from each row in the table\n        for row in range(\n            self.hopping_view.table_panel.hopping_table.rowCount()\n        ):\n            d1, d2, d3, re, im = [\n                self.hopping_view.table_panel.hopping_table.cellWidget(\n                    row, n\n                ).value()\n                for n in range(5)\n            ]\n\n            # Create the complex amplitude\n            amplitude = np.complex128(re + im * 1j)\n\n            # Create a tuple for the displacement vector (d\u2081, d\u2082, d\u2083)\n            triplet = (d1, d2, d3)\n            # If the triplet already exists, merge amplitudes by adding\n            # the new amplitude\n            if triplet in new_couplings:\n                new_couplings[triplet] += amplitude\n            else:\n                new_couplings[triplet] = amplitude\n\n        # Convert the dictionary to the expected format of the list of tuples.\n        # Remove any entries with non-finite or zero amplitudes\n        merged_couplings = [\n            ((d1, d2, d3), amplitude)\n            for (d1, d2, d3), amplitude in new_couplings.items()\n            if np.isfinite(amplitude.real)\n            and np.isfinite(amplitude.imag)\n            and not np.isclose(amplitude, 0)\n        ]\n        # Only update the model if the hoppings have changed\n        if set(merged_couplings) == set(\n            self.unit_cells[self.selection.unit_cell].hoppings.get(\n                (self.pair_selection[0][3], self.pair_selection[1][3]), []\n            )\n        ):\n            # No changes detected, just refresh the table in case the user\n            # rearranged the rows without actually changing the data or\n            # added rows with zero amplitude\n            self._refresh_table()\n            return\n\n        # Update the data model with the new couplings and emit the signal\n        self.undo_stack.push(\n            SaveHoppingsCommand(\n                unit_cells=self.unit_cells,\n                selection=self.selection,\n                pair_selection=self.pair_selection,\n                new_hoppings=merged_couplings,\n                signal=self.hoppings_changed,\n            )\n        )\n\n    def _add_context_menu(self, button, ii, jj):\n        \"\"\"\n        Create a context menu for the button to manage hoppings.\n\n        Parameters\n        ----------\n        button : QPushButton\n            The button that was right-clicked\n        ii : int\n            Row index of the button in the matrix\n        jj : int\n            Column index of the button in the matrix\n        \"\"\"\n        menu = QMenu()\n        # Send hopping data to the transpose element\n        action_send_hoppings = QAction(\"Set transpose element\", self)\n        action_send_hoppings.triggered.connect(\n            lambda: self._create_hermitian_partner(ii, jj)\n        )\n        menu.addAction(action_send_hoppings)\n\n        # Get hopping data from the transpose element\n        action_get_hoppings = QAction(\"Get transpose element\", self)\n        action_get_hoppings.triggered.connect(\n            lambda: self._create_hermitian_partner(jj, ii)\n        )\n        menu.addAction(action_get_hoppings)\n\n        # Clear hoppings\n        action_clear_hoppings = QAction(\"Clear hoppings\", self)\n        action_clear_hoppings.triggered.connect(\n            lambda: self._delete_coupling(ii, jj)\n        )\n        menu.addAction(action_clear_hoppings)\n\n        menu.exec_(button.mapToGlobal(QPoint(0, button.height())))\n\n    def _create_hermitian_partner(self, ii, jj):\n        \"\"\"\n        Create a Hermitian partner for the selected hopping.\n\n        The Hermitian partner is created by negating the displacement vector\n        and taking the complex conjugate of the amplitude.\n\n        Parameters\n        ----------\n        ii : int\n            Index of the destination state in the matrix\n        jj : int\n            Index of the source state in the matrix\n        \"\"\"\n        s1 = self.state_info[ii]  # Destination\n        s2 = self.state_info[jj]  # Source\n        hop = self.hoppings.get((s1[3], s2[3]), [])\n        hop_herm = [((-d1, -d2, -d3), np.conj(x)) for ((d1, d2, d3), x) in hop]\n        self.pair_selection = [s2, s1]\n\n        self.undo_stack.push(\n            SaveHoppingsCommand(\n                unit_cells=self.unit_cells,\n                selection=self.selection,\n                pair_selection=self.pair_selection,\n                new_hoppings=hop_herm,\n                signal=self.hoppings_changed,\n            )\n        )\n\n    def _delete_coupling(self, ii, jj):\n        \"\"\"\n        Delete the coupling between two states.\n\n        Parameters\n        ----------\n        ii : int\n            Index of the destination state in the matrix (row index)\n        jj : int\n            Index of the source state in the matrix (column index)\n        \"\"\"\n        s1 = self.state_info[ii]  # Destination\n        s2 = self.state_info[jj]  # Source\n\n        self._update_pair_selection(s1, s2)\n\n        self.undo_stack.push(\n            SaveHoppingsCommand(\n                unit_cells=self.unit_cells,\n                selection=self.selection,\n                pair_selection=self.pair_selection,\n                new_hoppings=[],\n                signal=self.hoppings_changed,\n            )\n        )\n\n    def _handle_hoppings_changed(self, uc_id, site_id, state_id, s1, s2):\n        \"\"\"\n        Redraw the matrix and table when hoppings are modified.\n\n        If the selection at the point of the hopping change is different\n        from the current one, emit a signal to update the selection in\n        the tree. Otherwise, refresh the matrix. Additionally, select\n        the pair of states and update the table.\n\n        Parameters\n        ----------\n        uc_id : uuid.UUID\n            UUID of the unit cell\n        site_id : uuid.UUID\n            UUID of the site\n        state_id : uuid.UUID\n            UUID of the state\n        s1 : tuple[str, uuid.UUID, str, uuid.UUID]\n            Information tuple for the destination `State` (row)\n        s2 : tuple[str, uuid.UUID, str, uuid.UUID]\n            Information tuple for the source `State` (column)\n        \"\"\"\n        # If the unit cell selection needs to change, matrix redrawing\n        # will be handled by the app controller as all panels are updated\n        # Otherwise, we need to refresh the matrix manually.\n\n        if self.selection.unit_cell == uc_id:\n            self._refresh_matrix()\n\n        if (\n            self.selection.unit_cell != uc_id\n            or self.selection.site != site_id\n            or self.selection.state != state_id\n        ):\n            self.selection_requested.emit(uc_id, site_id, state_id)\n\n        # Update Pair Selection\n        self._update_pair_selection(s1, s2)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.hopping_controller.HoppingController.update_unit_cell","title":"<code>update_unit_cell()</code>","text":"<p>Update the hopping data model with the selected <code>UnitCell</code>'s hoppings.</p> <p>This method is called when the selection changes in the tree view. It retrieves the currently selected unit cell and its hoppings, refreshing the matrix.</p> Source code in <code>TiBi/controllers/hopping_controller.py</code> <pre><code>def update_unit_cell(self):\n    \"\"\"\n    Update the hopping data model with the selected `UnitCell`'s hoppings.\n\n    This method is called when the selection changes in the tree view.\n    It retrieves the currently selected unit cell and its hoppings,\n    refreshing the matrix.\n    \"\"\"\n    uc_id = self.selection.unit_cell\n    # Deselect the previous states\n    self._update_pair_selection(None, None)\n\n    # If no unit cell selected, hide the panels and exit early\n    if uc_id is None:\n        self.hopping_view.panel_stack.setCurrentWidget(\n            self.hopping_view.info_label\n        )\n        return\n\n    else:\n        uc = self.unit_cells[uc_id]\n\n        # Get the states and their \"info\" from inside the unit cell\n        _, new_info = uc.get_states()\n\n        # Use the states and the info to construct the hopping matrix grid\n        self.hoppings = uc.hoppings\n        self.state_info = new_info\n        # If there are no states in the unit cell, hide the panels\n        if new_info == []:\n            self.hopping_view.panel_stack.setCurrentWidget(\n                self.hopping_view.info_label\n            )\n        else:\n            self.hopping_view.panel_stack.setCurrentWidget(\n                self.hopping_view.panel\n            )\n            self._refresh_matrix()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.MainUIController","title":"<code>TiBi.controllers.MainUIController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller for the main UI components (menu bar, toolbar, status bar).</p> <p>This controller connects the UI elements to the application logic and manages the action manager that provides shared actions to the menu bar and toolbar.</p> <p>Attributes:</p> Name Type Description <code>project_path</code> <code>str | None</code> <p>The file to which the dictionary containing the unit cell objects is saved</p> <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>main_window</code> <code>MainWindow</code> <p>Subclass of QMainWindow containing the application's main view</p> <code>menu_bar_view</code> <code>MenuBarView</code> <p>Standard menu bar</p> <code>toolbar_view</code> <code>MainToolbarView</code> <p>Toolbar at the top of the application window</p> <code>status_bar_view</code> <code>StatusBarView</code> <p>Status bar at the bottom of the application window</p> <code>undo_stack</code> <code>QUndoStack</code> <p>Stack for 'undo-able' actions</p> <code>project_refresh_requested</code> <code>Signal</code> <p>Request to refresh the project view after loading or creating a new one</p> <code>unit_cell_update_requested</code> <code>Signal</code> <p>Request to update the unit cell plot with new parameters</p> <p>Methods:</p> Name Description <code>get_uc_plot_properties</code> <p>Get the unit cell visualization properties.</p> <code>set_spinbox_status</code> <p>Activate/deactivate unit cell spinboxes.</p> <code>update_status</code> <p>Display a message in the status bar.</p> Source code in <code>TiBi/controllers/main_ui_controller.py</code> <pre><code>class MainUIController(QObject):\n    \"\"\"\n    Controller for the main UI components (menu bar, toolbar, status bar).\n\n    This controller connects the UI elements to the application logic and\n    manages the action manager that provides shared actions to the menu\n    bar and toolbar.\n\n    Attributes\n    ----------\n    project_path : str | None\n        The file to which the dictionary containing the unit\n        cell objects is saved\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    main_window : MainWindow\n        Subclass of QMainWindow containing the application's main view\n    menu_bar_view : MenuBarView\n        Standard menu bar\n    toolbar_view : MainToolbarView\n        Toolbar at the top of the application window\n    status_bar_view : StatusBarView\n        Status bar at the bottom of the application window\n    undo_stack : QUndoStack\n        Stack for 'undo-able' actions\n    project_refresh_requested : Signal\n        Request to refresh the project view after loading or creating a new one\n    unit_cell_update_requested : Signal\n        Request to update the unit cell plot with new parameters\n\n    Methods\n    -------\n    get_uc_plot_properties()\n        Get the unit cell visualization properties.\n    set_spinbox_status()\n        Activate/deactivate unit cell spinboxes.\n    update_status(message : str)\n        Display a message in the status bar.\n    \"\"\"\n\n    unit_cell_update_requested = Signal()\n    # Requst an updated unit cell plot\n    # Request a UI refresh after creating a new project\n    # or loading an existing one\n    project_refresh_requested = Signal()\n\n    def __init__(\n        self,\n        project_path: str | None,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        main_window: MainWindow,\n        menu_bar_view: MenuBarView,\n        toolbar_view: MainToolbarView,\n        status_bar_view: StatusBarView,\n        undo_stack: QUndoStack,\n    ):\n        super().__init__()\n        self.project_path = project_path\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.main_window = main_window\n        self.menu_bar = menu_bar_view\n        self.toolbar = toolbar_view\n        self.status_bar = status_bar_view\n        self.undo_stack = undo_stack\n\n        # Create the action manager\n        self.action_manager = ActionManager(\n            undo_stack=self.undo_stack, parent=self\n        )\n\n        # Set up action handlers\n        self._connect_action_handlers()\n\n        # Set actions to views\n        self.menu_bar.set_actions(self.action_manager)\n        self.toolbar.set_actions(self.action_manager)\n\n        # Connect spinbox signals\n        self.toolbar.n1_spinbox.valueChanged.connect(\n            lambda _: self.unit_cell_update_requested.emit()\n        )\n        self.toolbar.n2_spinbox.valueChanged.connect(\n            lambda _: self.unit_cell_update_requested.emit()\n        )\n        self.toolbar.n3_spinbox.valueChanged.connect(\n            lambda _: self.unit_cell_update_requested.emit()\n        )\n\n    def _connect_action_handlers(self):\n        \"\"\"Connect actions to their handler methods.\"\"\"\n        # Create a dictionary mapping action names to handler methods\n        handlers = {\n            # File actions\n            \"new_project\": self._handle_new_project,\n            \"open_project\": self._handle_open_project,\n            \"import_project\": self._handle_import_project,\n            \"save_project\": partial(\n                self._handle_save_project, use_existing_path=True\n            ),\n            \"save_project_as\": partial(\n                self._handle_save_project, use_existing_path=False\n            ),\n            # Undo/Redo actions\n            \"undo\": self.undo_stack.undo,\n            \"redo\": self.undo_stack.redo,\n            # Unit cell actions\n            \"wireframe\": self._handle_wireframe_toggle,\n        }\n\n        # Connect actions to handlers\n        self.action_manager.connect_signals(handlers)\n\n    # Methods to get information about the current state\n    def get_uc_plot_properties(self):\n        \"\"\"\n        Get the unit cell visualization properties.\n\n        The function returns the number of unit cells to be plotted\n        along each basis vector, as well as whether the wireframe\n        is plotted.\n\n        Returns\n        -------\n        int, int, int, bool\n            Numbers of unit cells along each of the three vectors and\n            a boolean for the wireframe.\n        \"\"\"\n        n1, n2, n3 = [\n            spinbox.value() if spinbox.isEnabled() else 1\n            for spinbox in (\n                self.toolbar.n1_spinbox,\n                self.toolbar.n2_spinbox,\n                self.toolbar.n3_spinbox,\n            )\n        ]\n        wireframe_enabled = self.action_manager.unit_cell_actions[\n            \"wireframe\"\n        ].isChecked()\n        return n1, n2, n3, wireframe_enabled\n\n    def set_spinbox_status(self, n1_enabled, n2_enabled, n3_enabled):\n        \"\"\"Activate/deactivate the unit cell spinboxes\"\"\"\n        self.toolbar.n1_spinbox.setEnabled(n1_enabled)\n        self.toolbar.n2_spinbox.setEnabled(n2_enabled)\n        self.toolbar.n3_spinbox.setEnabled(n3_enabled)\n\n    # Handler methods for actions\n    @Slot()\n    def _handle_new_project(self):\n        \"\"\"\n        Handle request to create a new project.\n\n        A new project clears the current project, so the user has to\n        respond to a warning. If the user confirms the creation of the project,\n        the unit_cells dictionary is cleared, the project_path is set to None,\n        and a request is set to reset all the models to the pristine state.\n        \"\"\"\n        self.update_status(\"Creating new project...\")\n        reply = QMessageBox.question(\n            self.main_window,\n            \"Start New Project?\",\n            \"\"\"\u26a0\ufe0f  This will clear your current project.\\n\\n\n            Are you sure you want to continue?\"\"\",\n            QMessageBox.Yes | QMessageBox.No,\n            QMessageBox.No,\n        )\n\n        if reply == QMessageBox.Yes:\n            self.project_path = None\n            self.unit_cells.clear()\n            self.undo_stack.clear()\n            self.project_refresh_requested.emit()\n\n    @Slot()\n    def _handle_open_project(self):\n        \"\"\"\n        Handle request to open a project from a JSON file.\n\n        Opening a project clears the current project.\n        The JSON data from the loaded file is deserialized so that the\n        unit_cell dictionary can be filled. The project path is updated\n        and a request is sent out to reset all other models\n        to the pristine state (nothing selected).\n        \"\"\"\n        self.update_status(\"Opening project...\")\n\n        # Open a file dialog for selecting a JSON file\n        file_path, _ = QFileDialog.getOpenFileName(\n            self.main_window,\n            \"Open Unit Cells JSON\",\n            os.getcwd(),  # starting directory\n            \"JSON Files (*.json);;All Files (*)\",\n        )\n\n        if file_path:\n            try:\n                with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                    json_string = f.read()\n                unit_cells = deserialize_unit_cells(json_string)\n                self.unit_cells.clear()\n                self.unit_cells.update(unit_cells)\n                self.project_path = file_path\n                self.project_refresh_requested.emit()\n            except Exception as e:\n                QMessageBox.critical(\n                    self.main_window,\n                    \"Error\",\n                    f\"Failed to open file:\\n{str(e)}\",\n                )\n                self.update_status(\"Failed to open project.\")\n\n    @Slot()\n    def _handle_import_project(self):\n        \"\"\"\n        Handle request to import a project.\n\n        Importing a project is similar to loading with the difference being\n        that the imported unit cells are added to the current project\n        rather than replacing them.\n        To avoid UUID clashes (if one imports the same project twice),\n        the newly-imported unit cells have their UUID's regenerated.\n        \"\"\"\n        self.update_status(\"Importing project...\")\n\n        # Open a file dialog for selecting a JSON file\n        file_path, _ = QFileDialog.getOpenFileName(\n            self.main_window,\n            \"Open Unit Cells JSON\",\n            os.getcwd(),  # starting directory\n            \"JSON Files (*.json);;All Files (*)\",\n        )\n\n        if file_path:\n            try:\n                with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                    json_string = f.read()\n                unit_cells = deserialize_unit_cells(json_string)\n\n                # Go over the imported unit cells and regenerate their UUID's\n                new_unit_cells = {}\n                for _, uc in unit_cells.items():\n                    new_id = uuid.uuid4()\n                    uc.id = new_id\n                    new_unit_cells[new_id] = uc\n\n                self.unit_cells.update(new_unit_cells)\n                self.project_refresh_requested.emit()\n            except Exception as e:\n                QMessageBox.critical(\n                    self.main_window,\n                    \"Error\",\n                    f\"Failed to open file:\\n{str(e)}\",\n                )\n                self.update_status(\"Failed to open project.\")\n\n    @Slot()\n    def _handle_save_project(self, use_existing_path=True):\n        \"\"\"\n        Handle request to save the current project.\n\n        Save the current project to a JSON file. If the project already has\n        a path, depending on whether the user clicks on Save or Save As,\n        the project is either saved to that path or the user chooses a\n        new file name. If there is no path, Save acts as Save As.\n        \"\"\"\n        self.update_status(\"Saving project...\")\n        json_string = serialize_unit_cells(self.unit_cells)\n        if use_existing_path:\n            file_path = self.project_path\n        else:\n            file_path = None\n\n        # If there is no path, open a dialog for the user to pick it\n        if not file_path:\n            # Open a save file dialog\n            file_path, _ = QFileDialog.getSaveFileName(\n                self.main_window,\n                \"Save Unit Cells As JSON\",\n                os.getcwd(),  # starting directory\n                \"JSON Files (*.json)\",\n            )\n\n        if file_path:\n            if file_path and not file_path.endswith(\".json\"):\n                file_path += \".json\"\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(json_string)\n            self.project_path = file_path\n\n    @Slot()\n    def _handle_wireframe_toggle(self):\n        \"\"\"\n        Handle wireframe toggle.\n\n        Request a redrawing of the unit cell plot with/without the wireframe.\n        \"\"\"\n        # Implementation will be added later\n        self.unit_cell_update_requested.emit()\n\n    # Methods to be called from other controllers\n    def update_status(self, message):\n        \"\"\"\n        Display a message in the status bar.\n\n        Parameters\n        ----------\n        message : str\n            Message to display\n        \"\"\"\n        self.status_bar.update_status(message)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.MainUIController.get_uc_plot_properties","title":"<code>get_uc_plot_properties()</code>","text":"<p>Get the unit cell visualization properties.</p> <p>The function returns the number of unit cells to be plotted along each basis vector, as well as whether the wireframe is plotted.</p> <p>Returns:</p> Type Description <code>(int, int, int, bool)</code> <p>Numbers of unit cells along each of the three vectors and a boolean for the wireframe.</p> Source code in <code>TiBi/controllers/main_ui_controller.py</code> <pre><code>def get_uc_plot_properties(self):\n    \"\"\"\n    Get the unit cell visualization properties.\n\n    The function returns the number of unit cells to be plotted\n    along each basis vector, as well as whether the wireframe\n    is plotted.\n\n    Returns\n    -------\n    int, int, int, bool\n        Numbers of unit cells along each of the three vectors and\n        a boolean for the wireframe.\n    \"\"\"\n    n1, n2, n3 = [\n        spinbox.value() if spinbox.isEnabled() else 1\n        for spinbox in (\n            self.toolbar.n1_spinbox,\n            self.toolbar.n2_spinbox,\n            self.toolbar.n3_spinbox,\n        )\n    ]\n    wireframe_enabled = self.action_manager.unit_cell_actions[\n        \"wireframe\"\n    ].isChecked()\n    return n1, n2, n3, wireframe_enabled\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.MainUIController.set_spinbox_status","title":"<code>set_spinbox_status(n1_enabled, n2_enabled, n3_enabled)</code>","text":"<p>Activate/deactivate the unit cell spinboxes</p> Source code in <code>TiBi/controllers/main_ui_controller.py</code> <pre><code>def set_spinbox_status(self, n1_enabled, n2_enabled, n3_enabled):\n    \"\"\"Activate/deactivate the unit cell spinboxes\"\"\"\n    self.toolbar.n1_spinbox.setEnabled(n1_enabled)\n    self.toolbar.n2_spinbox.setEnabled(n2_enabled)\n    self.toolbar.n3_spinbox.setEnabled(n3_enabled)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.MainUIController.update_status","title":"<code>update_status(message)</code>","text":"<p>Display a message in the status bar.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to display</p> required Source code in <code>TiBi/controllers/main_ui_controller.py</code> <pre><code>def update_status(self, message):\n    \"\"\"\n    Display a message in the status bar.\n\n    Parameters\n    ----------\n    message : str\n        Message to display\n    \"\"\"\n    self.status_bar.update_status(message)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.PlotController","title":"<code>TiBi.controllers.PlotController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller for the 2D plot view.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>plot_view</code> <code>PlotView</code> <p>2D plot for displaying computed results.</p> <p>Methods:</p> Name Description <code>plot_band_structure</code> <p>Plot the band structure for the selected unit cell.</p> <code>plot_dos</code> <p>Plot the density of states for the selected unit cell.</p> Source code in <code>TiBi/controllers/plot_controller.py</code> <pre><code>class PlotController(QObject):\n    \"\"\"\n    Controller for the 2D plot view.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    plot_view : PlotView\n        2D plot for displaying computed results.\n\n    Methods\n    -------\n    plot_band_structure(states: list[int])\n        Plot the band structure for the selected unit cell.\n    plot_dos(num_bins: int, states: list[int], plot_type: int,\\\n             broadening: np.float64)\n        Plot the density of states for the selected unit cell.\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        plot_view: PlotView,\n    ):\n        super().__init__()\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.plot_view = plot_view\n\n    def plot_band_structure(self, states: list[int]):\n        \"\"\"\n        Plot the band structure.\n\n        Parameters\n        ----------\n        states : list[int]\n            List of integers denoting onto which states\n            the bands need to be projected.\n        \"\"\"\n\n        self.plot_view.ax.clear()\n\n        uc_id = self.selection.unit_cell\n        if uc_id:\n            bandstructure = self.unit_cells[uc_id].bandstructure\n            # Set labels and grid\n            self.plot_view.ax.set_xlabel(\"k-vector\")\n            self.plot_view.ax.set_ylabel(\"Energy\")\n            # Hide x-axis tick and keep the grid only for y-axis\n            self.plot_view.ax.set_xticks([])\n            self.plot_view.ax.grid(True, axis=\"y\")\n            # Extract the band structure quantities\n            path = np.array(\n                bandstructure.path\n            )  # Array of momenta for which the bands were computed\n            special_points = np.array(\n                bandstructure.special_points\n            )  # High symmetry points used to construct the BZ path\n            bands = np.array(\n                bandstructure.eigenvalues\n            )  # Array of arrays of computed eigenvalues\n            eigenvectors = np.array(\n                bandstructure.eigenvectors\n            )  # Array of 2D arrays of eigenvectors. Eigenvectors are columns\n\n            if len(path) &gt; 0 and len(bands) &gt; 0:\n                # Get the positions along the path reflecting the point spacing\n                step = np.linalg.norm(np.diff(path, axis=0), axis=1)\n                pos = np.hstack((0, np.cumsum(step)))\n\n                pos = pos / pos[-1]  # Normalize the path length to 1\n\n                # Repeat the same for special points\n                step_special_points = np.linalg.norm(\n                    np.diff(special_points, axis=0), axis=1\n                )\n                pos_special_points = np.hstack(\n                    (0, np.cumsum(step_special_points))\n                )\n                pos_special_points = (\n                    pos_special_points / pos_special_points[-1]\n                )\n                # Compute projection magnitude squared for each k-point\n                projections = np.sum(\n                    np.abs(eigenvectors[:, states, :]) ** 2, axis=1\n                )\n                for band_idx in range(bands.shape[1]):\n                    sizes = DEFAULT_SCATTER_RADIUS * projections[:, band_idx]\n\n                    # Plot the bands as lines\n                    self.plot_view.ax.plot(\n                        pos, bands[:, band_idx], linestyle=\"-\", color=CF_SKY\n                    )\n                    # Plot the bands as scatterplots\n                    self.plot_view.ax.scatter(\n                        pos,\n                        bands[:, band_idx],\n                        s=sizes,\n                        color=CF_VERMILLION,\n                        alpha=0.6,\n                    )\n\n                # Plot vertical lines at special points\n                for x in pos_special_points:\n                    self.plot_view.ax.axvline(\n                        x=x, color=\"gray\", linestyle=\"--\", linewidth=0.8\n                    )\n            # Draw the canvas\n            self.plot_view.canvas.draw()\n\n    def plot_dos(self, num_bins, states, plot_type, broadening):\n        \"\"\"\n        Plot the density of states using the Brillouin zone grid.\n\n        Parameters\n        ----------\n        num_bins : int\n            Number of histogram bins\n        states : list[int]\n            List of integers denoting onto which states\n            the bands need to be projected.\n        plot_type : int\n            Histogram (0) or Lorentzian (1)\n        broadening : np.float64\n            Broadening parameter for the Lorentzian DOS\n        \"\"\"\n        self.plot_view.ax.clear()\n\n        uc_id = self.selection.unit_cell\n\n        if uc_id and self.unit_cells[uc_id].bz_grid.eigenvalues:\n            bz_grid = self.unit_cells[uc_id].bz_grid\n\n            # Set labels and grid\n            self.plot_view.ax.set_xlabel(\"Energy\")\n            self.plot_view.ax.set_ylabel(\"DOS\")\n\n            # Extract the relevant qantities\n            eigenvectors = np.array(\n                bz_grid.eigenvectors\n            )  # Array of 2D arrays of eigenvectors. Eigenvectors are columns\n            # Create a single array of energies\n            energies = np.concatenate(bz_grid.eigenvalues)\n            # For each k-point and each eigenstate, keep only the selected\n            # basis states. Sum over the squared amplitudes of the selected\n            # basis states for each state\n\n            # eigenvectors: shape (num_kpts, num_states, num_basis),\n            # where num_states = num_basis\n            # eigenvectors[:, states, :] selects the desired basis projections\n            projections = np.concatenate(\n                np.sum(np.abs(eigenvectors[:, states, :]) ** 2, axis=1), axis=0\n            )\n\n            bin_edges = np.histogram_bin_edges(energies, bins=num_bins)\n            # Histogram or Lorentzian:\n            if plot_type == 0:  # Histogram\n                # Construct a histogram using the selected states' probability\n                # for each eigenvalue as the weight\n                hist, _ = np.histogram(\n                    energies, bins=bin_edges, weights=projections\n                )\n                # Get the bind centers and normalize the histogram\n                bin_centers = 0.5 * (bin_edges[1:] + bin_edges[:-1])\n                bin_width = bin_edges[1] - bin_edges[0]\n\n                dos = hist / len(bz_grid.k_points)\n                self.plot_view.ax.bar(\n                    bin_centers,\n                    dos,\n                    width=bin_width,\n                    color=CF_SKY,\n                    edgecolor=CF_BLUE,\n                )\n            else:\n                # Get pairwise differences between the energy grid\n                # and the centers of the Lorentzians\n                delta = energies[:, None] - bin_edges[None, :]\n                lorentzians = (broadening / np.pi) / (delta**2 + broadening**2)\n                dos = projections @ lorentzians / len(bz_grid.k_points)\n                self.plot_view.ax.plot(\n                    bin_edges, dos, linestyle=\"-\", color=CF_SKY\n                )\n\n            # Draw the canvas\n            self.plot_view.canvas.draw()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.PlotController.plot_band_structure","title":"<code>plot_band_structure(states)</code>","text":"<p>Plot the band structure.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>list[int]</code> <p>List of integers denoting onto which states the bands need to be projected.</p> required Source code in <code>TiBi/controllers/plot_controller.py</code> <pre><code>def plot_band_structure(self, states: list[int]):\n    \"\"\"\n    Plot the band structure.\n\n    Parameters\n    ----------\n    states : list[int]\n        List of integers denoting onto which states\n        the bands need to be projected.\n    \"\"\"\n\n    self.plot_view.ax.clear()\n\n    uc_id = self.selection.unit_cell\n    if uc_id:\n        bandstructure = self.unit_cells[uc_id].bandstructure\n        # Set labels and grid\n        self.plot_view.ax.set_xlabel(\"k-vector\")\n        self.plot_view.ax.set_ylabel(\"Energy\")\n        # Hide x-axis tick and keep the grid only for y-axis\n        self.plot_view.ax.set_xticks([])\n        self.plot_view.ax.grid(True, axis=\"y\")\n        # Extract the band structure quantities\n        path = np.array(\n            bandstructure.path\n        )  # Array of momenta for which the bands were computed\n        special_points = np.array(\n            bandstructure.special_points\n        )  # High symmetry points used to construct the BZ path\n        bands = np.array(\n            bandstructure.eigenvalues\n        )  # Array of arrays of computed eigenvalues\n        eigenvectors = np.array(\n            bandstructure.eigenvectors\n        )  # Array of 2D arrays of eigenvectors. Eigenvectors are columns\n\n        if len(path) &gt; 0 and len(bands) &gt; 0:\n            # Get the positions along the path reflecting the point spacing\n            step = np.linalg.norm(np.diff(path, axis=0), axis=1)\n            pos = np.hstack((0, np.cumsum(step)))\n\n            pos = pos / pos[-1]  # Normalize the path length to 1\n\n            # Repeat the same for special points\n            step_special_points = np.linalg.norm(\n                np.diff(special_points, axis=0), axis=1\n            )\n            pos_special_points = np.hstack(\n                (0, np.cumsum(step_special_points))\n            )\n            pos_special_points = (\n                pos_special_points / pos_special_points[-1]\n            )\n            # Compute projection magnitude squared for each k-point\n            projections = np.sum(\n                np.abs(eigenvectors[:, states, :]) ** 2, axis=1\n            )\n            for band_idx in range(bands.shape[1]):\n                sizes = DEFAULT_SCATTER_RADIUS * projections[:, band_idx]\n\n                # Plot the bands as lines\n                self.plot_view.ax.plot(\n                    pos, bands[:, band_idx], linestyle=\"-\", color=CF_SKY\n                )\n                # Plot the bands as scatterplots\n                self.plot_view.ax.scatter(\n                    pos,\n                    bands[:, band_idx],\n                    s=sizes,\n                    color=CF_VERMILLION,\n                    alpha=0.6,\n                )\n\n            # Plot vertical lines at special points\n            for x in pos_special_points:\n                self.plot_view.ax.axvline(\n                    x=x, color=\"gray\", linestyle=\"--\", linewidth=0.8\n                )\n        # Draw the canvas\n        self.plot_view.canvas.draw()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.PlotController.plot_dos","title":"<code>plot_dos(num_bins, states, plot_type, broadening)</code>","text":"<p>Plot the density of states using the Brillouin zone grid.</p> <p>Parameters:</p> Name Type Description Default <code>num_bins</code> <code>int</code> <p>Number of histogram bins</p> required <code>states</code> <code>list[int]</code> <p>List of integers denoting onto which states the bands need to be projected.</p> required <code>plot_type</code> <code>int</code> <p>Histogram (0) or Lorentzian (1)</p> required <code>broadening</code> <code>float64</code> <p>Broadening parameter for the Lorentzian DOS</p> required Source code in <code>TiBi/controllers/plot_controller.py</code> <pre><code>def plot_dos(self, num_bins, states, plot_type, broadening):\n    \"\"\"\n    Plot the density of states using the Brillouin zone grid.\n\n    Parameters\n    ----------\n    num_bins : int\n        Number of histogram bins\n    states : list[int]\n        List of integers denoting onto which states\n        the bands need to be projected.\n    plot_type : int\n        Histogram (0) or Lorentzian (1)\n    broadening : np.float64\n        Broadening parameter for the Lorentzian DOS\n    \"\"\"\n    self.plot_view.ax.clear()\n\n    uc_id = self.selection.unit_cell\n\n    if uc_id and self.unit_cells[uc_id].bz_grid.eigenvalues:\n        bz_grid = self.unit_cells[uc_id].bz_grid\n\n        # Set labels and grid\n        self.plot_view.ax.set_xlabel(\"Energy\")\n        self.plot_view.ax.set_ylabel(\"DOS\")\n\n        # Extract the relevant qantities\n        eigenvectors = np.array(\n            bz_grid.eigenvectors\n        )  # Array of 2D arrays of eigenvectors. Eigenvectors are columns\n        # Create a single array of energies\n        energies = np.concatenate(bz_grid.eigenvalues)\n        # For each k-point and each eigenstate, keep only the selected\n        # basis states. Sum over the squared amplitudes of the selected\n        # basis states for each state\n\n        # eigenvectors: shape (num_kpts, num_states, num_basis),\n        # where num_states = num_basis\n        # eigenvectors[:, states, :] selects the desired basis projections\n        projections = np.concatenate(\n            np.sum(np.abs(eigenvectors[:, states, :]) ** 2, axis=1), axis=0\n        )\n\n        bin_edges = np.histogram_bin_edges(energies, bins=num_bins)\n        # Histogram or Lorentzian:\n        if plot_type == 0:  # Histogram\n            # Construct a histogram using the selected states' probability\n            # for each eigenvalue as the weight\n            hist, _ = np.histogram(\n                energies, bins=bin_edges, weights=projections\n            )\n            # Get the bind centers and normalize the histogram\n            bin_centers = 0.5 * (bin_edges[1:] + bin_edges[:-1])\n            bin_width = bin_edges[1] - bin_edges[0]\n\n            dos = hist / len(bz_grid.k_points)\n            self.plot_view.ax.bar(\n                bin_centers,\n                dos,\n                width=bin_width,\n                color=CF_SKY,\n                edgecolor=CF_BLUE,\n            )\n        else:\n            # Get pairwise differences between the energy grid\n            # and the centers of the Lorentzians\n            delta = energies[:, None] - bin_edges[None, :]\n            lorentzians = (broadening / np.pi) / (delta**2 + broadening**2)\n            dos = projections @ lorentzians / len(bz_grid.k_points)\n            self.plot_view.ax.plot(\n                bin_edges, dos, linestyle=\"-\", color=CF_SKY\n            )\n\n        # Draw the canvas\n        self.plot_view.canvas.draw()\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.UnitCellController","title":"<code>TiBi.controllers.UnitCellController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller managing the <code>UnitCell</code>, <code>Site</code>, and <code>State</code> creation panel.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>unit_cell_view</code> <code>UnitCellView</code> <p>The main view component</p> <code>undo_stack</code> <code>QUndoStack</code> <p><code>QUndoStack</code> to hold \"undo-able\" commands</p> <code>v1, v2, v3</code> <code>list[EnterKeySpinBox]</code> <p>Lists of spinboxes for basis vector components</p> <code>R, c1, c2, c3</code> <code>EnterKeySpinBox</code> <p>Spinboxes for site properties</p> <code>tree_view_panel</code> <code>TreeViewPanel</code> <p>The tree view panel component</p> <code>tree_view</code> <code>SystemTree</code> <p>The tree view component</p> <code>tree_model</code> <code>QStandardItemModel</code> <p>The model backing the tree view</p> <code>unit_cell_parameter_changed</code> <code>Signal</code> <p>Signal emitted when a unit cell parameter is changed. This triggers a redraw of the panels orchestrated by the app_controller. Whenever unit cell parameter changes, the derived quantities (band structure, BZ grid, etc), are discarded due to being stale. The clearing is handled by the associated commands.</p> <code>site_parameter_changed</code> <code>Signal</code> <p>Signal emitted when a site parameter is changed. This triggers a redraw only of the unit cell plot. Changing site parameters does not invalidate the derived quantities since the site parameters are purely cosmetic.</p> <code>hopping_projection_update_requested</code> <code>Signal</code> <p>Signal emitted when a tree item is renamed or the structure of the unit cell changes (adding/removing states), requiring an update of the hopping matrix and the projection selection.</p> <p>Methods:</p> Name Description <code>refresh_tree</code> <p>Redraw the system tree using the current system state.</p> <code>select_item</code> <p>Select a tree item using the ID's.</p> Source code in <code>TiBi/controllers/uc_controller.py</code> <pre><code>class UnitCellController(QObject):\n    \"\"\"\n    Controller managing the `UnitCell`, `Site`, and `State` creation panel.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    unit_cell_view : UnitCellView\n        The main view component\n    undo_stack : QUndoStack\n        `QUndoStack` to hold \"undo-able\" commands\n    v1, v2, v3 : list[EnterKeySpinBox]\n        Lists of spinboxes for basis vector components\n    R, c1, c2, c3 : EnterKeySpinBox\n        Spinboxes for site properties\n    tree_view_panel : TreeViewPanel\n        The tree view panel component\n    tree_view : SystemTree\n        The tree view component\n    tree_model : QStandardItemModel\n        The model backing the tree view\n    unit_cell_parameter_changed : Signal\n        Signal emitted when a unit cell parameter is changed.\n        This triggers a redraw of the panels orchestrated by\n        the app_controller. Whenever unit cell parameter changes,\n        the derived quantities (band structure, BZ grid, etc),\n        are discarded due to being stale. The clearing is handled\n        by the associated commands.\n    site_parameter_changed : Signal\n        Signal emitted when a site parameter is changed.\n        This triggers a redraw only of the unit cell plot.\n        Changing site parameters does not invalidate the derived quantities\n        since the site parameters are purely cosmetic.\n    hopping_projection_update_requested : Signal\n        Signal emitted when a tree item is renamed or the structure of the\n        unit cell changes (adding/removing states), requiring\n        an update of the hopping matrix and the projection selection.\n\n    Methods\n    -------\n    refresh_tree()\n        Redraw the system tree using the current system state.\n    select_item(uc_id: uuid.UUID, site_id: uuid.UUID, state_id: uuid.UUID):\n        Select a tree item using the ID's.\n    \"\"\"\n\n    unit_cell_parameter_changed = Signal()\n    site_parameter_changed = Signal()\n    hopping_projection_update_requested = Signal()\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        unit_cell_view: UnitCellView,\n        undo_stack: QUndoStack,\n    ):\n        super().__init__()\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.unit_cell_view = unit_cell_view\n        self.undo_stack = undo_stack\n\n        # Get the fields from unit_cell_view for convenience\n        # For the basis vectors, each reference has three spinboxes\n        # corresponding to the Cartesian coordinates\n        # Unit Cell fields\n        self.v1 = self.unit_cell_view.unit_cell_panel.v1\n        self.v2 = self.unit_cell_view.unit_cell_panel.v2\n        self.v3 = self.unit_cell_view.unit_cell_panel.v3\n\n        # Site fields\n        self.R = self.unit_cell_view.site_panel.R\n        self.c1 = self.unit_cell_view.site_panel.c1\n        self.c2 = self.unit_cell_view.site_panel.c2\n        self.c3 = self.unit_cell_view.site_panel.c3\n\n        # Store the tree_view_panel, tree_view and tree_model as\n        # attributes for convenience\n        self.tree_view_panel = self.unit_cell_view.tree_view_panel\n        self.tree_view = self.tree_view_panel.tree_view\n        self.tree_model = self.tree_view.tree_model\n\n        # Rebuild the tree view from scratch in the beginning\n        self.tree_view.refresh_tree(self.unit_cells)\n\n        # SIGNALS\n        # Selection change.\n        self.selection.selection_changed.connect(self._show_panels)\n\n        # Tree view signals\n        # When the tree selection changes, the selection model is updated\n        self.tree_view.tree_selection_changed.connect(\n            lambda x: self.selection.set_selection(\n                uc_id=x[\"unit_cell\"], site_id=x[\"site\"], state_id=x[\"state\"]\n            )\n        )\n\n        # Triggered when a tree item's name is changed by double clicking on it\n        self.tree_view_panel.name_edit_finished.connect(\n            lambda x: self.undo_stack.push(\n                RenameTreeItemCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    tree_view=self.tree_view,\n                    signal=self.hopping_projection_update_requested,\n                    item=self.tree_model.itemFromIndex(x),\n                )\n            )\n        )\n\n        # Triggered when the user presses Del or Backspace while\n        # a tree item is highlighted, or clicks the Delete button\n        # The signal is emitted only when there are states that are deleted\n        # (either directly or as part of a site). If a state is deleted,\n        # derived quantities (bands, BZ grid, etc.) are discarded\n        # due to being stale.\n        # If a unit cell is deleted,\n        # the signal is not emitted as the unit cell deletion changes the\n        # selection, which is handled separately.\n        self.tree_view_panel.delete_requested.connect(\n            lambda: self.undo_stack.push(\n                DeleteItemCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    tree_view=self.tree_view,\n                    signal=self.hopping_projection_update_requested,\n                )\n            )\n        )\n        # New item creation using the tree delegate.\n        self.tree_view_panel.new_unit_cell_requested.connect(\n            lambda: self.undo_stack.push(\n                AddUnitCellCommand(\n                    unit_cells=self.unit_cells, tree_view=self.tree_view\n                )\n            )\n        )\n\n        self.tree_view_panel.new_site_requested.connect(\n            lambda: self.undo_stack.push(\n                AddSiteCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    tree_view=self.tree_view,\n                )\n            )\n        )\n        self.tree_view_panel.new_state_requested.connect(\n            lambda: self.undo_stack.push(\n                AddStateCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    tree_view=self.tree_view,\n                    signal=self.hopping_projection_update_requested,\n                )\n            )\n        )\n\n        # Unit Cell basis vector signals. Emitted when the user confirms\n        # the change in the corresponding field but pressing Enter.\n        def connect_vector_fields(\n            vector_name, spinboxes: list[EnterKeySpinBox]\n        ):\n            for ii, axis in enumerate(\"xyz\"):\n                spinboxes[ii].editingConfirmed.connect(\n                    lambda ii=ii, axis=axis: self.undo_stack.push(\n                        UpdateUnitCellParameterCommand(\n                            unit_cells=self.unit_cells,\n                            selection=self.selection,\n                            vector=vector_name,\n                            coordinate=axis,\n                            spinbox=spinboxes[ii],\n                            signal=self.unit_cell_parameter_changed,\n                        )\n                    )\n                )\n\n        # Connect the fields for the three basis vectors\n        connect_vector_fields(\"v1\", self.v1)\n        connect_vector_fields(\"v2\", self.v2)\n        connect_vector_fields(\"v3\", self.v3)\n\n        # Dimensionality radio buttons\n        self.radio_buttons = [\n            self.unit_cell_view.unit_cell_panel.radio0D,\n            self.unit_cell_view.unit_cell_panel.radio1D,\n            self.unit_cell_view.unit_cell_panel.radio2D,\n            self.unit_cell_view.unit_cell_panel.radio3D,\n        ]\n        # Dimensionality change signals from the radio buttons.\n        # Changes in dimensionality trigger the same response\n        # as in the basis vector coordinates.\n        for dim, radio in enumerate(self.radio_buttons):\n            radio.toggled.connect(\n                lambda checked, d=dim: (\n                    self.undo_stack.push(\n                        ChangeDimensionalityCommand(\n                            unit_cells=self.unit_cells,\n                            selection=self.selection,\n                            unit_cell_view=self.unit_cell_view,\n                            signal=self.unit_cell_parameter_changed,\n                            dim=d,\n                            buttons=self.radio_buttons,\n                        )\n                    )\n                    if checked\n                    else None\n                )\n            )\n\n        # Site panel signals.\n        # Signals for fractional site coordinates.\n        for param in [\"c1\", \"c2\", \"c3\"]:\n            spinbox: EnterKeySpinBox = getattr(self, param)\n            spinbox.editingConfirmed.connect(\n                lambda p=param, s=spinbox: self.undo_stack.push(\n                    UpdateSiteParameterCommand(\n                        unit_cells=self.unit_cells,\n                        selection=self.selection,\n                        param=p,\n                        spinbox=s,\n                        signal=self.site_parameter_changed,\n                    )\n                )\n            )\n\n        # Site radius\n        self.R.editingConfirmed.connect(\n            lambda: self.undo_stack.push(\n                UpdateSiteParameterCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    param=\"R\",\n                    spinbox=self.R,\n                    signal=self.site_parameter_changed,\n                )\n            )\n        )\n\n        # Button signals\n        # Reduce button--LLL argorithm to obtain the primitive cell.\n        self.unit_cell_view.unit_cell_panel.reduce_btn.clicked.connect(\n            lambda: self.undo_stack.push(\n                ReduceBasisCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    unit_cell_view=self.unit_cell_view,\n                    signal=self.unit_cell_parameter_changed,\n                )\n            )\n        )\n        # Opens a color picker to change the color of the selected site\n        self.unit_cell_view.site_panel.color_picker_btn.clicked.connect(\n            self._pick_site_color\n        )\n\n    def _show_panels(self):\n        \"\"\"\n        Update the UI panels based on the current selection state.\n\n        This method is called whenever the selection changes. It determines\n        which panels should be visible and populates them with data from\n        the selected items.\n        The panels are shown or hidden using a stacked widget approach.\n\n        The method handles all three levels of the hierarchy:\n        - When a unit cell is selected, its properties are shown in\n        the unit cell panel\n        - When a site is selected, its properties are shown in the site panel\n        - When a state is selected, no additional panel is shown as the state\n        is only described by its name\n\n        Buttons are also enabled/disabled based on the selection context.\n        \"\"\"\n        unit_cell_id = self.selection.unit_cell\n        site_id = self.selection.site\n        if unit_cell_id:\n            # Get the selected unit cell\n            uc = self.unit_cells[unit_cell_id]\n\n            # Get the system dimensionality\n            dim = uc.v1.is_periodic + uc.v2.is_periodic + uc.v3.is_periodic\n            # Set the dimensionality radio button.\n            # Suppress the dim_listener since we are updating the radio\n            # button programmatically\n            for btn in self.radio_buttons:\n                btn.blockSignals(True)\n            self.unit_cell_view.unit_cell_panel.radio_group.button(\n                dim\n            ).setChecked(True)\n            # Enable the coordinate fields depending on the dimensionality\n            self.unit_cell_view.unit_cell_panel.v1[0].setEnabled(True)\n            self.unit_cell_view.unit_cell_panel.v1[1].setEnabled(dim &gt; 1)\n            self.unit_cell_view.unit_cell_panel.v1[2].setEnabled(dim &gt; 2)\n\n            self.unit_cell_view.unit_cell_panel.v2[0].setEnabled(dim &gt; 1)\n            self.unit_cell_view.unit_cell_panel.v2[1].setEnabled(True)\n            self.unit_cell_view.unit_cell_panel.v2[2].setEnabled(dim &gt; 2)\n\n            self.unit_cell_view.unit_cell_panel.v3[0].setEnabled(dim &gt; 2)\n            self.unit_cell_view.unit_cell_panel.v3[1].setEnabled(dim &gt; 2)\n            self.unit_cell_view.unit_cell_panel.v3[2].setEnabled(True)\n\n            for btn in self.radio_buttons:\n                btn.blockSignals(False)\n\n            # Set the basis vector fields\n            self.unit_cell_view.unit_cell_panel.set_basis_vectors(\n                uc.v1, uc.v2, uc.v3\n            )\n\n            # Show the UnitCellPanel\n            self.unit_cell_view.uc_stack.setCurrentWidget(\n                self.unit_cell_view.unit_cell_panel\n            )\n\n            if site_id:\n                site = uc.sites[site_id]\n                # Set the fractional coordinates and radius fields\n                self.c1.setValue(site.c1)\n                self.c2.setValue(site.c2)\n                self.c3.setValue(site.c3)\n                self.R.setValue(site.R)\n\n                # Set the color for the color picker button\n                site_color = site.color\n\n                c = (\n                    int(site_color[0] * 255),\n                    int(site_color[1] * 255),\n                    int(site_color[2] * 255),\n                    int(site_color[3] * 255),\n                )  # Color in 0-255 component range\n\n                self.unit_cell_view.site_panel.color_picker_btn.setStyleSheet(\n                    f\"background-color: rgba({c[0]}, {c[1]}, {c[2]}, {c[3]});\"\n                )\n\n                # Show the SitePanel\n                self.unit_cell_view.site_stack.setCurrentWidget(\n                    self.unit_cell_view.site_panel\n                )\n\n            else:\n                # If no site is selected, hide the SitePanel\n                self.unit_cell_view.site_stack.setCurrentWidget(\n                    self.unit_cell_view.site_info_label\n                )\n        else:\n            # If no unit cell is selected, hide the SitePanel and UnitCellPanel\n            self.unit_cell_view.uc_stack.setCurrentWidget(\n                self.unit_cell_view.uc_info_label\n            )\n            self.unit_cell_view.site_stack.setCurrentWidget(\n                self.unit_cell_view.site_info_label\n            )\n\n    def _pick_site_color(self):\n        \"\"\"\n        Open a color dialog to select a color for the selected site.\n\n        After the color is picked, an undoable command is issued.\n        \"\"\"\n        old_color = (\n            self.unit_cells[self.selection.unit_cell]\n            .sites[self.selection.site]\n            .color\n        )\n\n        # Open the color dialog with the current color selected\n        start_color = QColor(\n            int(old_color[0] * 255),\n            int(old_color[1] * 255),\n            int(old_color[2] * 255),\n            int(old_color[3] * 255),\n        )\n        new_color = QColorDialog.getColor(\n            initial=start_color,\n            options=QColorDialog.ShowAlphaChannel,\n        )\n\n        # Update the button color\n        if new_color.isValid():\n            self.undo_stack.push(\n                ChangeSiteColorCommand(\n                    unit_cells=self.unit_cells,\n                    selection=self.selection,\n                    new_color=new_color,\n                    old_color=start_color,\n                    unit_cell_view=self.unit_cell_view,\n                    signal=self.site_parameter_changed,\n                )\n            )\n\n    def refresh_tree(self):\n        \"\"\"\n        Redraw the system tree using the current system state.\n        \"\"\"\n        self.tree_view.refresh_tree(self.unit_cells)\n\n    def select_item(self, uc_id, site_id, state_id):\n        \"\"\"\n        Select a tree item using the ID's.\n        \"\"\"\n        self.tree_view._select_item_by_id(uc_id, site_id, state_id)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.UnitCellController.refresh_tree","title":"<code>refresh_tree()</code>","text":"<p>Redraw the system tree using the current system state.</p> Source code in <code>TiBi/controllers/uc_controller.py</code> <pre><code>def refresh_tree(self):\n    \"\"\"\n    Redraw the system tree using the current system state.\n    \"\"\"\n    self.tree_view.refresh_tree(self.unit_cells)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.UnitCellController.select_item","title":"<code>select_item(uc_id, site_id, state_id)</code>","text":"<p>Select a tree item using the ID's.</p> Source code in <code>TiBi/controllers/uc_controller.py</code> <pre><code>def select_item(self, uc_id, site_id, state_id):\n    \"\"\"\n    Select a tree item using the ID's.\n    \"\"\"\n    self.tree_view._select_item_by_id(uc_id, site_id, state_id)\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.UnitCellPlotController","title":"<code>TiBi.controllers.UnitCellPlotController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller for the unit cell 3D visualization.</p> <p>This controller manages the 3D visualization of unit cells, handling the rendering of unit cell wireframes, site positions, and periodic repetitions.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>uc_plot_view</code> <code>UnitCellPlotView</code> <p>The view component for the 3D visualization</p> <code>unit_cell</code> <code>UnitCell</code> <p>The unit cell currently being visualized</p> <code>uc_plot_items</code> <code>dict</code> <p>Dictionary to store plot items</p> <p>Methods:</p> Name Description <code>update_hopping_segments</code> <p>Draw segments to indicate hopping connections.</p> <code>update_unit_cell</code> <p>Draw the selected <code>UnitCell</code> in the 3D view.</p> Source code in <code>TiBi/controllers/uc_plot_controller.py</code> <pre><code>class UnitCellPlotController(QObject):\n    \"\"\"\n    Controller for the unit cell 3D visualization.\n\n    This controller manages the 3D visualization of unit cells, handling the\n    rendering of unit cell wireframes, site positions, and periodic\n    repetitions.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    uc_plot_view : UnitCellPlotView\n        The view component for the 3D visualization\n    unit_cell : UnitCell\n        The unit cell currently being visualized\n    uc_plot_items : dict\n        Dictionary to store plot items\n\n    Methods\n    -------\n    update_hopping_segments(pair_selection: \\\n        tuple[tuple[str, uuid.UUID, str, uuid.UUID],\\\n            tuple[str, uuid.UUID, str, uuid.UUID]])\n        Draw segments to indicate hopping connections.\n    update_unit_cell(wireframe_shown: bool, n1: int, n2: int, n3: int)\n        Draw the selected `UnitCell` in the 3D view.\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        uc_plot_view: UnitCellPlotView,\n    ):\n        super().__init__()\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.uc_plot_view = uc_plot_view\n\n        # Internal controller state\n        self.unit_cell = None  # Unit cell being plotted\n        self.uc_plot_items = {}  # Dictionary to store plot items\n\n    def update_unit_cell(\n        self, wireframe_shown: bool, n1: int, n2: int, n3: int\n    ):\n        \"\"\"\n        Draw the selected `UnitCell` in the 3D view.\n\n        Parameters\n        ----------\n        wireframe_shown : bool\n            Denotes whether the primitive vector wireframe is drawn\n        n1, n2, n3 : int\n            Number of repetitions along the corresponding basis vector\n        \"\"\"\n        uc_id = self.selection.unit_cell\n        # Clear previous plot items except axes\n        for key, item in list(self.uc_plot_items.items()):\n            self.uc_plot_view.view.removeItem(item)\n            del self.uc_plot_items[key]\n        # Early exit if no unit cell selected\n        if uc_id is None:\n            return\n\n        self.unit_cell = self.unit_cells[uc_id]\n        self.n1, self.n2, self.n3 = n1, n2, n3\n\n        # Collect line vertices\n        unique_edges = (\n            set()\n        )  # Unique edges to avoid duplication from neighboring unit cells\n        # Loop over the unit cell indices\n        for jj, kk, ll in product(\n            range(self.n1), range(self.n2), range(self.n3)\n        ):\n            # List of tuples with vertices defining edges\n            edges = self._get_unit_cell_edges(jj, kk, ll)\n            for edge in edges:\n                unique_edges.add(edge)  # Keep only unique edges\n            self._plot_sites(jj, kk, ll)\n\n        # Convert edges to line vertices\n        line_vertices = []\n        for v1, v2 in unique_edges:\n            line_vertices.extend([v1, v2])\n        # Create the wireframe using GLLinePlotItem\n        unit_cell_edges = gl.GLLinePlotItem(\n            pos=line_vertices, color=\"w\", width=1, mode=\"lines\"  # White color\n        )\n\n        # Shift the unit cells so that they are centered around the origin\n        shift = (\n            -(\n                self.n1 * self.unit_cell.v1.as_array()\n                + self.n2 * self.unit_cell.v2.as_array()\n                + self.n3 * self.unit_cell.v3.as_array()\n            )\n            / 2\n        )\n\n        unit_cell_edges.translate(shift[0], shift[1], shift[2])\n\n        # Plot the wireframe if requested\n        if wireframe_shown:\n            self.uc_plot_view.view.addItem(unit_cell_edges)\n            self.uc_plot_items[\"unit_cell_edges\"] = unit_cell_edges\n\n    def _plot_sites(self, a1, a2, a3):\n        \"\"\"\n        Plot all `Site`s within the `UnitCell` at (a1,a2,a3).\n\n        Each site is represented as a colored sphere positioned according to\n        its fractional coordinates within the unit cell. Sites can be selected\n        and change size when highlighted. Spheres also store the site id\n        to draw the coupling links when pairs of states are selected from\n        the hopping panel.\n\n        Parameters\n        ----------\n        a1, a2, a3 : int\n            Integer multiples of the unit cell basis vectors v1, v2, and v3.\n        \"\"\"\n        # Early exit if no unit cell or it contains no sites\n        if not self.unit_cell or not self.unit_cell.sites:\n            return\n\n        # Extract basis vectors\n        v1 = self.unit_cell.v1.as_array()\n        v2 = self.unit_cell.v2.as_array()\n        v3 = self.unit_cell.v3.as_array()\n\n        # Plot each site as a sphere\n        for site_id, site in self.unit_cell.sites.items():\n            # Calculate the position in Cartesian coordinates\n            pos = (\n                (a1 + site.c1) * v1 + (a2 + site.c2) * v2 + (a3 + site.c3) * v3\n            )\n            sphere_color = self.unit_cell.sites[site_id].color\n\n            sphere_radius = (\n                self.unit_cell.sites[site_id].R * DEFAULT_SITE_SCALING\n                if site_id == self.selection.site\n                else self.unit_cell.sites[site_id].R\n            )\n            # Create a sphere for the site.\n            sphere = gl.GLMeshItem(\n                meshdata=gl.MeshData.sphere(\n                    rows=10, cols=10, radius=sphere_radius\n                ),\n                smooth=True,\n                color=(\n                    sphere_color[0],\n                    sphere_color[1],\n                    sphere_color[2],\n                    sphere_color[3],\n                ),\n                shader=\"shaded\",\n                glOptions=\"translucent\",\n            )\n            # Shift the objects so that the illustration is centered\n            # at the origin\n            shift = -(self.n1 * v1 + self.n2 * v2 + self.n3 * v3) / 2 + pos\n            sphere.translate(shift[0], shift[1], shift[2])\n\n            # Store site ID as user data for interaction\n            sphere.site_id = site_id\n\n            self.uc_plot_view.view.addItem(sphere)\n            self.uc_plot_items[f\"site_{site_id}_{a1}_{a2}_{a3}\"] = sphere\n\n    def _get_unit_cell_edges(\n        self, a1, a2, a3\n    ) -&gt; tuple[tuple[float, float, float], tuple[float, float, float]]:\n        \"\"\"\n        Get the edges of the unit cell parallelepiped.\n\n        Parameters\n        ----------\n        a1, a2, a3 : int\n            Integer multiples of the unit cell basis vectors v1, v2, and v3.\n\n        Returns\n        -------\n        list[tuple[tuple[float, float, float], tuple[float, float, float]]]\n            A list of edges in the unit cell parallelepiped.\n            Each edge is represented as a tuple of two vertices.\n            Each vertex is a tuple of three floats (x, y, z).\n        \"\"\"\n        if not self.unit_cell:\n            return\n\n        # Extract basis vectors\n        v1 = self.unit_cell.v1.as_array()\n        v2 = self.unit_cell.v2.as_array()\n        v3 = self.unit_cell.v3.as_array()\n\n        # Define the 8 corners of the parallelepiped\n        verts = np.array(\n            [\n                [0, 0, 0],\n                v1,\n                v2,\n                v1 + v2,  # Bottom 4 vertices\n                v3,\n                v1 + v3,\n                v2 + v3,\n                v1 + v2 + v3,  # Top 4 vertices\n            ]\n        )\n        # Shift the corners by the appropriate multiples of basis vectors\n        verts = [v + (a1 * v1 + a2 * v2 + a3 * v3) for v in verts]\n        # Define the 12 edges of the parallelepiped\n        edges = np.array(\n            [\n                [0, 1],\n                [0, 2],\n                [1, 3],\n                [2, 3],  # Bottom square\n                [4, 5],\n                [4, 6],\n                [5, 7],\n                [6, 7],  # Top square\n                [0, 4],\n                [1, 5],\n                [2, 6],\n                [3, 7],  # Vertical edges\n            ]\n        )\n        # Convert edges into line segments\n        vertex_tuples = []\n        for edge in edges:\n            vert1 = tuple(verts[edge[0]])\n            vert2 = tuple(verts[edge[1]])\n            vertex_tuples.append(tuple(sorted((vert1, vert2))))\n\n        return vertex_tuples\n\n    def update_hopping_segments(self, pair_selection):\n        \"\"\"\n        Draw segments to indicate hopping connections.\n\n        When a pair is selected from the hopping matrix, this function\n        draws lines starting from the site hosting the source state\n        inside the unit cell around (0,0,0) to all the sites hosting\n        the target sites.\n\n        Parameters\n        ----------\n        pair_selection : tuple\n            A tuple of (site_name, site_id, state_name, state_id)\n            representing the selected pair of states.\n            The first element is the source state and the second\n            element is the target state.\n        \"\"\"\n\n        # Clear previous hopping segments\n        hopping_segments = self.uc_plot_items.get(\"hopping_segments\")\n        if hopping_segments is not None:\n            self.uc_plot_view.view.removeItem(hopping_segments)\n            del self.uc_plot_items[\"hopping_segments\"]\n\n        # s1 and s2 are tuples (site_name, site_id, state_name, state_id)\n        s1, s2 = pair_selection\n        hoppings = self.unit_cell.hoppings.get((s1[3], s2[3]))\n        # Early exit if the states are not coupled\n        if hoppings is None:\n            return\n        # Get the basis vectors\n        v1 = self.unit_cell.v1.as_array()\n        v2 = self.unit_cell.v2.as_array()\n        v3 = self.unit_cell.v3.as_array()\n\n        # Get the location of the source site in the (0,0,0) unit cell\n        source = self.unit_cell.sites[s2[1]]\n        source_pos = source.c1 * v1 + source.c2 * v2 + source.c3 * v3\n\n        # Get the location of the target sites in the (0,0,0) unit cell\n        target = self.unit_cell.sites[s1[1]]\n        target_pos = target.c1 * v1 + target.c2 * v2 + target.c3 * v3\n\n        segments = []\n        # Extract the displacements for the selected state pair\n        for (d1, d2, d3), _ in hoppings:\n            target = target_pos + d1 * v1 + d2 * v2 + d3 * v3\n            # Sequentially append the source and the target for each\n            # coupling segment\n            segments.append(source_pos)\n            segments.append(target)\n\n        hopping_segments = gl.GLLinePlotItem(\n            pos=segments,\n            color=CF_YELLOW,\n            width=5,\n            mode=\"lines\",\n        )\n        # Shift so that the source state is in a unit cell at the origin\n        shift = (\n            (self.n1 % 2) * v1 + (self.n2 % 2) * v2 + (self.n3 % 2) * v3\n        ) / 2\n\n        hopping_segments.translate(-shift[0], -shift[1], -shift[2])\n\n        # Add to the view\n        self.uc_plot_view.view.addItem(hopping_segments)\n        # Store it so we can remove it later\n        self.uc_plot_items[\"hopping_segments\"] = hopping_segments\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.UnitCellPlotController.update_hopping_segments","title":"<code>update_hopping_segments(pair_selection)</code>","text":"<p>Draw segments to indicate hopping connections.</p> <p>When a pair is selected from the hopping matrix, this function draws lines starting from the site hosting the source state inside the unit cell around (0,0,0) to all the sites hosting the target sites.</p> <p>Parameters:</p> Name Type Description Default <code>pair_selection</code> <code>tuple</code> <p>A tuple of (site_name, site_id, state_name, state_id) representing the selected pair of states. The first element is the source state and the second element is the target state.</p> required Source code in <code>TiBi/controllers/uc_plot_controller.py</code> <pre><code>def update_hopping_segments(self, pair_selection):\n    \"\"\"\n    Draw segments to indicate hopping connections.\n\n    When a pair is selected from the hopping matrix, this function\n    draws lines starting from the site hosting the source state\n    inside the unit cell around (0,0,0) to all the sites hosting\n    the target sites.\n\n    Parameters\n    ----------\n    pair_selection : tuple\n        A tuple of (site_name, site_id, state_name, state_id)\n        representing the selected pair of states.\n        The first element is the source state and the second\n        element is the target state.\n    \"\"\"\n\n    # Clear previous hopping segments\n    hopping_segments = self.uc_plot_items.get(\"hopping_segments\")\n    if hopping_segments is not None:\n        self.uc_plot_view.view.removeItem(hopping_segments)\n        del self.uc_plot_items[\"hopping_segments\"]\n\n    # s1 and s2 are tuples (site_name, site_id, state_name, state_id)\n    s1, s2 = pair_selection\n    hoppings = self.unit_cell.hoppings.get((s1[3], s2[3]))\n    # Early exit if the states are not coupled\n    if hoppings is None:\n        return\n    # Get the basis vectors\n    v1 = self.unit_cell.v1.as_array()\n    v2 = self.unit_cell.v2.as_array()\n    v3 = self.unit_cell.v3.as_array()\n\n    # Get the location of the source site in the (0,0,0) unit cell\n    source = self.unit_cell.sites[s2[1]]\n    source_pos = source.c1 * v1 + source.c2 * v2 + source.c3 * v3\n\n    # Get the location of the target sites in the (0,0,0) unit cell\n    target = self.unit_cell.sites[s1[1]]\n    target_pos = target.c1 * v1 + target.c2 * v2 + target.c3 * v3\n\n    segments = []\n    # Extract the displacements for the selected state pair\n    for (d1, d2, d3), _ in hoppings:\n        target = target_pos + d1 * v1 + d2 * v2 + d3 * v3\n        # Sequentially append the source and the target for each\n        # coupling segment\n        segments.append(source_pos)\n        segments.append(target)\n\n    hopping_segments = gl.GLLinePlotItem(\n        pos=segments,\n        color=CF_YELLOW,\n        width=5,\n        mode=\"lines\",\n    )\n    # Shift so that the source state is in a unit cell at the origin\n    shift = (\n        (self.n1 % 2) * v1 + (self.n2 % 2) * v2 + (self.n3 % 2) * v3\n    ) / 2\n\n    hopping_segments.translate(-shift[0], -shift[1], -shift[2])\n\n    # Add to the view\n    self.uc_plot_view.view.addItem(hopping_segments)\n    # Store it so we can remove it later\n    self.uc_plot_items[\"hopping_segments\"] = hopping_segments\n</code></pre>"},{"location":"dev/controllers/#TiBi.controllers.UnitCellPlotController.update_unit_cell","title":"<code>update_unit_cell(wireframe_shown, n1, n2, n3)</code>","text":"<p>Draw the selected <code>UnitCell</code> in the 3D view.</p> <p>Parameters:</p> Name Type Description Default <code>wireframe_shown</code> <code>bool</code> <p>Denotes whether the primitive vector wireframe is drawn</p> required <code>n1</code> <code>int</code> <p>Number of repetitions along the corresponding basis vector</p> required <code>n2</code> <code>int</code> <p>Number of repetitions along the corresponding basis vector</p> required <code>n3</code> <code>int</code> <p>Number of repetitions along the corresponding basis vector</p> required Source code in <code>TiBi/controllers/uc_plot_controller.py</code> <pre><code>def update_unit_cell(\n    self, wireframe_shown: bool, n1: int, n2: int, n3: int\n):\n    \"\"\"\n    Draw the selected `UnitCell` in the 3D view.\n\n    Parameters\n    ----------\n    wireframe_shown : bool\n        Denotes whether the primitive vector wireframe is drawn\n    n1, n2, n3 : int\n        Number of repetitions along the corresponding basis vector\n    \"\"\"\n    uc_id = self.selection.unit_cell\n    # Clear previous plot items except axes\n    for key, item in list(self.uc_plot_items.items()):\n        self.uc_plot_view.view.removeItem(item)\n        del self.uc_plot_items[key]\n    # Early exit if no unit cell selected\n    if uc_id is None:\n        return\n\n    self.unit_cell = self.unit_cells[uc_id]\n    self.n1, self.n2, self.n3 = n1, n2, n3\n\n    # Collect line vertices\n    unique_edges = (\n        set()\n    )  # Unique edges to avoid duplication from neighboring unit cells\n    # Loop over the unit cell indices\n    for jj, kk, ll in product(\n        range(self.n1), range(self.n2), range(self.n3)\n    ):\n        # List of tuples with vertices defining edges\n        edges = self._get_unit_cell_edges(jj, kk, ll)\n        for edge in edges:\n            unique_edges.add(edge)  # Keep only unique edges\n        self._plot_sites(jj, kk, ll)\n\n    # Convert edges to line vertices\n    line_vertices = []\n    for v1, v2 in unique_edges:\n        line_vertices.extend([v1, v2])\n    # Create the wireframe using GLLinePlotItem\n    unit_cell_edges = gl.GLLinePlotItem(\n        pos=line_vertices, color=\"w\", width=1, mode=\"lines\"  # White color\n    )\n\n    # Shift the unit cells so that they are centered around the origin\n    shift = (\n        -(\n            self.n1 * self.unit_cell.v1.as_array()\n            + self.n2 * self.unit_cell.v2.as_array()\n            + self.n3 * self.unit_cell.v3.as_array()\n        )\n        / 2\n    )\n\n    unit_cell_edges.translate(shift[0], shift[1], shift[2])\n\n    # Plot the wireframe if requested\n    if wireframe_shown:\n        self.uc_plot_view.view.addItem(unit_cell_edges)\n        self.uc_plot_items[\"unit_cell_edges\"] = unit_cell_edges\n</code></pre>"},{"location":"dev/core/","title":"Core","text":"<p>This page provides the documentation for the core physics functions used by the application.</p>"},{"location":"dev/core/#TiBi.core.get_BZ_grid","title":"<code>TiBi.core.get_BZ_grid(unit_cell, n1, n2, n3, typ)</code>","text":"<p>Generate a grid of points in the BZ.</p> <p>Depending on the system dimensionality, the output momentum arrays have different lengths. The user can choose between Gamma-centered and Monkhorst-Pack grids.</p> <p>Parameters:</p> Name Type Description Default <code>unit_cell</code> <code>UnitCell</code> <p><code>UnitCell</code> whose grid is being calculated.</p> required <code>n1</code> <code>int</code> <p>Number of points along each reciprocal vector</p> required <code>n2</code> <code>int</code> <p>Number of points along each reciprocal vector</p> required <code>n3</code> <code>int</code> <p>Number of points along each reciprocal vector</p> required <code>typ</code> <code>int</code> <p>0 or 1, with 0 corresponding to the MP and 1 to Gamma-centered grids.</p> required <p>Returns:</p> Type Description <code>NDArray[NDArray[float64]]</code> <p>Array of k-points comprising the grid.</p> Source code in <code>TiBi/core/bz_points.py</code> <pre><code>def get_BZ_grid(\n    unit_cell: UnitCell,\n    n1: int,\n    n2: int,\n    n3: int,\n    typ: int,\n) -&gt; list[NDArray[np.float64]]:\n    \"\"\"\n    Generate a grid of points in the BZ.\n\n    Depending on the system dimensionality, the output momentum arrays\n    have different lengths. The user can choose between Gamma-centered\n    and Monkhorst-Pack grids.\n\n    Parameters\n    ----------\n    unit_cell : UnitCell\n        `UnitCell` whose grid is being calculated.\n    n1, n2, n3 : int\n        Number of points along each reciprocal vector\n    typ : int\n        0 or 1, with 0 corresponding to the MP and 1 to Gamma-centered grids.\n\n    Returns\n    -------\n    NDArray[NDArray[np.float64]]\n        Array of k-points comprising the grid.\n    \"\"\"\n    reciprocal_vectors = unit_cell.reciprocal_vectors()\n    dim = (\n        unit_cell.v1.is_periodic\n        + unit_cell.v2.is_periodic\n        + unit_cell.v3.is_periodic\n    )\n\n    # Multiples of each vector based on the type of the grid\n    def get_multiples(n, grid_type):\n        if grid_type == 1:\n            return [(jj - np.floor(n / 2)) / n for jj in range(n)]\n        else:\n            return [(jj + 1 / 2) / n - 1 / 2 for jj in range(n)]\n\n    m1 = get_multiples(n1, typ) if unit_cell.v1.is_periodic else [0.0]\n    m2 = get_multiples(n2, typ) if unit_cell.v2.is_periodic else [0.0]\n    m3 = get_multiples(n3, typ) if unit_cell.v3.is_periodic else [0.0]\n\n    multiples = [m1, m2, m3][0:dim]\n    k_points = []\n    for ms in itertools.product(*multiples):\n        k = sum([ms[d] * reciprocal_vectors[d] for d in range(dim)])\n        k_points.append(k[0:dim])\n\n    return k_points\n</code></pre>"},{"location":"dev/core/#TiBi.core.interpolate_k_path","title":"<code>TiBi.core.interpolate_k_path(points, n_total)</code>","text":"<p>Interpolate a path through k-space special points.</p> <p>The path has the special points distributed along segments proportionally to their lengths in reciprocal space.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[NDArray[float64]]</code> <p>List or array of k-points defining the path</p> required <code>n_total</code> <code>int</code> <p>Total number of points to distribute along the entire path</p> required <p>Returns:</p> Type Description <code>NDArray[NDArray[float64]]</code> <p>Array of interpolated k-points along the path</p> Source code in <code>TiBi/core/bz_points.py</code> <pre><code>def interpolate_k_path(points: list[NDArray[np.float64]], n_total: int):\n    \"\"\"\n    Interpolate a path through k-space special points.\n\n    The path has the special points distributed along\n    segments proportionally to their lengths in reciprocal space.\n\n    Parameters\n    ----------\n    points : list[NDArray[np.float64]]\n        List or array of k-points defining the path\n    n_total : int\n        Total number of points to distribute along the entire path\n\n    Returns\n    -------\n    NDArray[NDArray[np.float64]]\n        Array of interpolated k-points along the path\n    \"\"\"\n    points = np.array(points)\n    # Get the distances between consecutive points\n    distances = np.linalg.norm(np.diff(points, axis=0), axis=1)\n    # Get the total distance of the path in the reciprocal space\n    total_distance = np.sum(distances)\n\n    # Allocate number of points per segment\n    n_segments = len(points) - 1\n    fractions = distances / total_distance\n    n_points_segment = [max(2, int(round(f * n_total))) for f in fractions]\n\n    # Build the full path\n    k_path = []\n    for ii in range(n_segments):\n        start = points[ii]\n        end = points[ii + 1]\n        n_pts = n_points_segment[ii]\n        segment = np.linspace(start, end, n_pts, endpoint=False)\n        k_path.extend(segment)\n\n    # Add the final high-symmetry point\n    k_path.append(points[-1])\n\n    return k_path\n</code></pre>"},{"location":"dev/logic/","title":"Logic","text":"<p>This page provides the documentation for the commands encoding undo/redo actions, data serialization, and workers used for running processes on parallel threads.</p>"},{"location":"dev/logic/#brillouin-zone-commands","title":"Brillouin Zone Commands","text":""},{"location":"dev/logic/#TiBi.logic.commands.AddBZPointCommand","title":"<code>TiBi.logic.commands.AddBZPointCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Add a point to the special points path in the Brillouin zone.</p> <p>Because this action would invalidate the already-calculated bands, the band structure is reset.</p> <p>Attributes:</p> Name Type Description <code>unit_cell</code> <code>UnitCell</code> <p><code>UnitCell</code> to which the point will be addeed</p> <code>point</code> <code>NDArray[float64]</code> <p>The point to be added</p> <code>computation_view</code> <code>ComputationView</code> <p>UI object containing the computation view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted to trigger a redraw of the BZ path</p> Source code in <code>TiBi/logic/commands/bz_commands.py</code> <pre><code>class AddBZPointCommand(QUndoCommand):\n    \"\"\"\n    Add a point to the special points path in the Brillouin zone.\n\n    Because this action would invalidate the already-calculated bands,\n    the band structure is reset.\n\n    Attributes\n    ----------\n    unit_cell : UnitCell\n        `UnitCell` to which the point will be addeed\n    point : NDArray[np.float64]\n        The point to be added\n    computation_view : ComputationView\n        UI object containing the computation view\n    signal : Signal\n        Signal to be emitted to trigger a redraw of the BZ path\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cell: UnitCell,\n        point: NDArray[np.float64],\n        computation_view: ComputationView,\n        signal: Signal,\n    ):\n        super().__init__(\"Add BZ Path Point\")\n        self.unit_cell = unit_cell\n        self.point = point\n        self.computation_view = computation_view\n        self.signal = signal\n\n    def redo(self):\n\n        self.unit_cell.bandstructure.add_point(self.point)\n        self.computation_view.bands_panel.remove_last_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.clear_path_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.compute_bands_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 1\n        )\n        self.signal.emit()\n\n    def undo(self):\n\n        self.unit_cell.bandstructure.remove_point()\n        self.computation_view.bands_panel.remove_last_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.clear_path_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.compute_bands_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 1\n        )\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.ClearBZPathCommand","title":"<code>TiBi.logic.commands.ClearBZPathCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Clear the special points path in the Brillouin zone.</p> <p>Because this action would invalidate the already-calculated bands, the band structure is reset.</p> <p>Attributes:</p> Name Type Description <code>unit_cell</code> <code>UnitCell</code> <p><code>UnitCell</code> whose path will be cleared</p> <code>special_points</code> <code>list[NDArray[float64]]</code> <p>List of special points before clearing the path</p> <code>computation_view</code> <code>ComputationView</code> <p>UI object containing the computation view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted to trigger a redraw of the BZ path</p> Source code in <code>TiBi/logic/commands/bz_commands.py</code> <pre><code>class ClearBZPathCommand(QUndoCommand):\n    \"\"\"\n    Clear the special points path in the Brillouin zone.\n\n    Because this action would invalidate the already-calculated bands,\n    the band structure is reset.\n\n    Attributes\n    ----------\n    unit_cell : UnitCell\n        `UnitCell` whose path will be cleared\n    special_points : list[NDArray[np.float64]]\n        List of special points before clearing the path\n    computation_view : ComputationView\n        UI object containing the computation view\n    signal : Signal\n        Signal to be emitted to trigger a redraw of the BZ path\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cell: UnitCell,\n        computation_view: ComputationView,\n        signal: Signal,\n    ):\n        super().__init__(\"Add BZ Path Point\")\n        self.unit_cell = unit_cell\n        self.computation_view = computation_view\n        self.signal = signal\n\n        self.special_points = copy.deepcopy(\n            self.unit_cell.bandstructure.special_points\n        )\n\n    def redo(self):\n        self.unit_cell.bandstructure.clear()\n        self.computation_view.bands_panel.remove_last_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.clear_path_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.compute_bands_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 1\n        )\n        self.signal.emit()\n\n    def undo(self):\n        self.unit_cell.bandstructure.clear()\n        self.unit_cell.bandstructure.special_points = copy.deepcopy(\n            self.special_points\n        )\n        self.computation_view.bands_panel.remove_last_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.clear_path_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.compute_bands_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 1\n        )\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.RemoveBZPointCommand","title":"<code>TiBi.logic.commands.RemoveBZPointCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Remove the last point from the special points path in the Brillouin zone.</p> <p>Because this action would invalidate the already-calculated bands, the band structure is reset.</p> <p>Attributes:</p> Name Type Description <code>unit_cell</code> <code>UnitCell</code> <p><code>UnitCell</code> from which the point will be removed</p> <code>point</code> <code>NDArray</code> <p>The point to be removed</p> <code>computation_view</code> <code>ComputationView</code> <p>UI object containing the computation view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted to trigger a redraw of the BZ path</p> Source code in <code>TiBi/logic/commands/bz_commands.py</code> <pre><code>class RemoveBZPointCommand(QUndoCommand):\n    \"\"\"\n    Remove the last point from the special points path in the Brillouin zone.\n\n    Because this action would invalidate the already-calculated bands,\n    the band structure is reset.\n\n    Attributes\n    ----------\n    unit_cell : UnitCell\n        `UnitCell` from which the point will be removed\n    point : NDArray\n        The point to be removed\n    computation_view : ComputationView\n        UI object containing the computation view\n    signal : Signal\n        Signal to be emitted to trigger a redraw of the BZ path\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cell: UnitCell,\n        computation_view: ComputationView,\n        signal: Signal,\n    ):\n        super().__init__(\"Remove BZ Path Point\")\n        self.unit_cell = unit_cell\n        self.computation_view = computation_view\n        self.signal = signal\n\n        self.point = copy.deepcopy(\n            self.unit_cell.bandstructure.special_points[-1]\n        )\n\n    def redo(self):\n        self.unit_cell.bandstructure.remove_point()\n        self.computation_view.bands_panel.remove_last_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.clear_path_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.compute_bands_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 1\n        )\n        self.signal.emit()\n\n    def undo(self):\n        self.unit_cell.bandstructure.add_point(self.point)\n        self.computation_view.bands_panel.remove_last_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.clear_path_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 0\n        )\n        self.computation_view.bands_panel.compute_bands_btn.setEnabled(\n            len(self.unit_cell.bandstructure.special_points) &gt; 1\n        )\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#tree-commands","title":"Tree Commands","text":""},{"location":"dev/logic/#TiBi.logic.commands.AddSiteCommand","title":"<code>TiBi.logic.commands.AddSiteCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Create a new site in the currently selected unit cell.</p> <p>Creates a site with default name and coordinates (0,0,0), adds it to the sites dictionary of the selected unit cell and to the tree.</p> <p>The default site has: - Name: \"New Site\" - Coordinates (0,0,0) - No states initially - Default radius - Random color</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Dictionary containing the current selection</p> <code>tree_view</code> <code>SystemTree</code> <p>UI object containing the tree view</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>site</code> <code>Site</code> <p>Newly created <code>Site</code></p> Source code in <code>TiBi/logic/commands/tree_commands.py</code> <pre><code>class AddSiteCommand(QUndoCommand):\n    \"\"\"\n    Create a new site in the currently selected unit cell.\n\n    Creates a site with default name and coordinates (0,0,0), adds it to\n    the sites dictionary of the selected unit cell and to the tree.\n\n    The default site has:\n    - Name: \"New Site\"\n    - Coordinates (0,0,0)\n    - No states initially\n    - Default radius\n    - Random color\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Dictionary containing the current selection\n    tree_view : SystemTree\n        UI object containing the tree view\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    site : Site\n        Newly created `Site`\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        tree_view: SystemTree,\n    ):\n        super().__init__(\"Add Site\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.tree_view = tree_view\n        self.uc_id = self.selection.unit_cell\n        self.site = mk_new_site()\n\n    # Add the newly-created site to the dictionary and create a tree item\n    # Add entries to the size and colors dictionaries for the site\n    def redo(self):\n        unit_cell = self.unit_cells[self.uc_id]\n        unit_cell.sites[self.site.id] = self.site\n        self.tree_view.add_tree_item(self.site.name, self.uc_id, self.site.id)\n\n    # Remove the unit cell from the dictionary and the tree using its id\n    # Remove the color and size entries\n    def undo(self):\n        del self.unit_cells[self.uc_id].sites[self.site.id]\n        self.tree_view.remove_tree_item(self.uc_id, self.site.id)\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.AddStateCommand","title":"<code>TiBi.logic.commands.AddStateCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Create a new state in the currently selected site.</p> <p>Creates a state with default name, adds it to the states dictionary of the selected site and to the tree.</p> <p>The default state has: - Name: \"New State\"</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Model containing the current selection</p> <code>tree_view</code> <code>SystemTree</code> <p>UI object containing the tree view</p> <code>signal</code> <code>Signal</code> <p>Signal emitted when the state is added/removed</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>site_id</code> <code>UUID</code> <p>UUID of the selected <code>Site</code> when the command was issued</p> <code>state</code> <code>State</code> <p>Newly created <code>State</code></p> Source code in <code>TiBi/logic/commands/tree_commands.py</code> <pre><code>class AddStateCommand(QUndoCommand):\n    \"\"\"\n    Create a new state in the currently selected site.\n\n    Creates a state with default name, adds it to the\n    states dictionary of the selected site and to the tree.\n\n    The default state has:\n    - Name: \"New State\"\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Model containing the current selection\n    tree_view : SystemTree\n        UI object containing the tree view\n    signal : Signal\n        Signal emitted when the state is added/removed\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    site_id : uuid.UUID\n        UUID of the selected `Site` when the command was issued\n    state : State\n        Newly created `State`\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        tree_view: SystemTree,\n        signal: Signal,\n    ):\n        super().__init__(\"Add State\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.tree_view = tree_view\n        self.signal = signal\n        self.uc_id = self.selection.unit_cell\n        self.site_id = self.selection.site\n        self.state = mk_new_state()\n\n    # Add the newly-created state to the dictionary and create a tree item\n    def redo(self):\n        unit_cell = self.unit_cells[self.uc_id]\n        site = unit_cell.sites[self.site_id]\n        site.states[self.state.id] = self.state\n        unit_cell.bandstructure.reset_bands()\n        unit_cell.bz_grid.clear()\n        self.tree_view.add_tree_item(\n            self.state.name, self.uc_id, self.site_id, self.state.id\n        )\n        self.signal.emit()\n\n    # Remove the site from the dictionary and the tree using its id\n    def undo(self):\n        del (\n            self.unit_cells[self.uc_id]\n            .sites[self.site_id]\n            .states[self.state.id]\n        )\n        self.unit_cells[self.uc_id].bandstructure.reset_bands()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        self.tree_view.remove_tree_item(\n            self.uc_id, self.site_id, self.state.id\n        )\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.AddUnitCellCommand","title":"<code>TiBi.logic.commands.AddUnitCellCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Create a new unit cell with default properties and add it to the model.</p> <p>Creates a unit cell with orthogonal basis vectors along the x, y, and z axes, adds it to the unit_cells dictionary and to the tree view.</p> <p>The default unit cell has: - Name: \"New Unit Cell\" - Three orthogonal unit vectors along the x, y, and z axes - No periodicity (0D system) - No sites or states initially</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>tree_view</code> <code>SystemTree</code> <p>UI object containing the tree view</p> <code>unit_cell</code> <code>UnitCell</code> <p>Newly created <code>UnitCell</code></p> Source code in <code>TiBi/logic/commands/tree_commands.py</code> <pre><code>class AddUnitCellCommand(QUndoCommand):\n    \"\"\"\n    Create a new unit cell with default properties and add it to the model.\n\n    Creates a unit cell with orthogonal basis vectors along\n    the x, y, and z axes, adds it to the unit_cells dictionary\n    and to the tree view.\n\n    The default unit cell has:\n    - Name: \"New Unit Cell\"\n    - Three orthogonal unit vectors along the x, y, and z axes\n    - No periodicity (0D system)\n    - No sites or states initially\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    tree_view : SystemTree\n        UI object containing the tree view\n    unit_cell : UnitCell\n        Newly created `UnitCell`\n    \"\"\"\n\n    def __init__(\n        self, unit_cells: dict[uuid.UUID, UnitCell], tree_view: SystemTree\n    ):\n        super().__init__(\"Add Unit Cell\")\n        self.unit_cells = unit_cells\n        self.tree_view = tree_view\n        self.unit_cell = mk_new_unit_cell()\n\n    # Add the newly-created unit cell to the dictionary and create a tree item\n    def redo(self):\n        self.unit_cells[self.unit_cell.id] = self.unit_cell\n        self.tree_view.add_tree_item(self.unit_cell.name, self.unit_cell.id)\n\n    # Remove the unit cell from the dictionary and the tree using its id\n    def undo(self):\n        del self.unit_cells[self.unit_cell.id]\n        self.tree_view.remove_tree_item(self.unit_cell.id)\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.DeleteItemCommand","title":"<code>TiBi.logic.commands.DeleteItemCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Delete the currently selected item from the model.</p> <p>This command handles deletion of <code>UnitCell</code>s, <code>Site</code>s, and <code>State</code>s based on the current selection. It updates both the data model and the tree view to reflect the deletion, and ensures that the selection is updated appropriately.</p> <p>The deletion follows the containment hierarchy: - Deleting a <code>UnitCell</code> also removes all its <code>Site</code>s and <code>State</code>s - Deleting a <code>Site</code> also removes all its <code>State</code>s - Deleting a <code>State</code> only removes that specific <code>State</code></p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Dictionary containing the current selection</p> <code>tree_view</code> <code>SystemTree</code> <p>UI object containing the tree view</p> <code>signal</code> <code>Signal</code> <p>Signal emitted when a state is added/removed</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>site_id</code> <code>UUID</code> <p>UUID of the selected <code>Site</code> when the command was issued</p> <code>state_id</code> <code>UUID</code> <p>UUID of the selected <code>State</code> when the command was issued</p> Source code in <code>TiBi/logic/commands/tree_commands.py</code> <pre><code>class DeleteItemCommand(QUndoCommand):\n    \"\"\"\n    Delete the currently selected item from the model.\n\n    This command handles deletion of `UnitCell`s, `Site`s, and `State`s\n    based on the current selection. It updates both the data model and\n    the tree view to reflect the deletion, and ensures that\n    the selection is updated appropriately.\n\n    The deletion follows the containment hierarchy:\n    - Deleting a `UnitCell` also removes all its `Site`s and `State`s\n    - Deleting a `Site` also removes all its `State`s\n    - Deleting a `State` only removes that specific `State`\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Dictionary containing the current selection\n    tree_view : SystemTree\n        UI object containing the tree view\n    signal : Signal\n        Signal emitted when a state is added/removed\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    site_id : uuid.UUID\n        UUID of the selected `Site` when the command was issued\n    state_id : uuid.UUID\n        UUID of the selected `State` when the command was issued\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        tree_view: SystemTree,\n        signal: Signal,\n    ):\n        super().__init__(\"Delete Item\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.tree_view = tree_view\n        self.signal = signal\n\n        self.uc_id = self.selection.unit_cell\n        self.site_id = self.selection.site\n        self.state_id = self.selection.state\n\n        # Save the item to be deleted for undo\n        if self.state_id:\n            self.item = copy.deepcopy(\n                self.unit_cells[self.uc_id]\n                .sites[self.site_id]\n                .states[self.state_id]\n            )\n        # No state selected, therefore remove the site from the unit cell\n        elif self.site_id:\n            self.item = copy.deepcopy(\n                self.unit_cells[self.uc_id].sites[self.site_id]\n            )\n\n        # No site selected, therefore remove the unit cell from the model\n        elif self.uc_id:\n            self.item = copy.deepcopy(self.unit_cells[self.uc_id])\n\n    # Delete the item\n    def redo(self):\n        if self.state_id:\n            # Get the hoppings involving the states, remove them\n            # from the hopping dictionary and store them to be used\n            # in the undo method\n            self.removed_hoppings = {}\n            kept_hoppings = {}\n            for k, v in self.unit_cells[self.uc_id].hoppings.items():\n                if self.state_id in k:\n                    self.removed_hoppings[k] = v\n                else:\n                    kept_hoppings[k] = v\n            self.unit_cells[self.uc_id].hoppings = kept_hoppings\n            self.unit_cells[self.uc_id].bandstructure.reset_bands()\n            self.unit_cells[self.uc_id].bz_grid.clear()\n            # Delete the selected state from the site\n            del (\n                self.unit_cells[self.uc_id]\n                .sites[self.site_id]\n                .states[self.state_id]\n            )\n            self.signal.emit()\n\n        # No state selected, therefore remove the site from the unit cell\n        elif self.site_id:\n            self.removed_hoppings = {}\n            kept_hoppings = {}\n            for state in (\n                self.unit_cells[self.uc_id].sites[self.site_id].states.values()\n            ):\n                for k, v in self.unit_cells[self.uc_id].hoppings.items():\n                    if state.id in k:\n                        self.removed_hoppings[k] = v\n                    else:\n                        kept_hoppings[k] = v\n            self.unit_cells[self.uc_id].hoppings = kept_hoppings\n            if self.removed_hoppings:\n                self.unit_cells[self.uc_id].bandstructure.reset_bands()\n                self.unit_cells[self.uc_id].bz_grid.clear()\n            # If the site has states, request a redraw of the hopping matrix\n            if self.unit_cells[self.uc_id].sites[self.site_id].states:\n                del self.unit_cells[self.uc_id].sites[self.site_id]\n                self.signal.emit()\n            else:\n                del self.unit_cells[self.uc_id].sites[self.site_id]\n        # No site selected, therefore remove the unit cell from the model\n        elif self.uc_id:\n            del self.unit_cells[self.uc_id]\n\n        self.tree_view.remove_tree_item(\n            self.uc_id, self.site_id, self.state_id\n        )\n\n    def undo(self):\n        # Reinsert the item into the model\n        if self.state_id:\n            unit_cell = self.unit_cells[self.uc_id]\n            site = unit_cell.sites[self.site_id]\n            site.states[self.item.id] = self.item\n            unit_cell.bandstructure.reset_bands()\n            unit_cell.bz_grid.clear()\n            unit_cell.hoppings.update(self.removed_hoppings)\n            self.signal.emit()\n\n        elif self.site_id:\n            unit_cell = self.unit_cells[self.uc_id]\n            unit_cell.sites[self.item.id] = self.item\n            if self.removed_hoppings:\n                unit_cell.bandstructure.reset_bands()\n                unit_cell.bz_grid.clear()\n            unit_cell.hoppings.update(self.removed_hoppings)\n            # If the site has states, request a redraw of the hopping matrix\n            if self.unit_cells[self.uc_id].sites[self.site_id].states:\n                self.signal.emit()\n        elif self.uc_id:\n            self.unit_cells[self.item.id] = self.item\n\n        # Refresh the tree and select the item\n        self.tree_view.refresh_tree(self.unit_cells)\n        index = self.tree_view.find_item_by_id(\n            uc_id=self.uc_id, site_id=self.site_id, state_id=self.state_id\n        ).index()\n        self.tree_view.selectionModel().setCurrentIndex(\n            index, QItemSelectionModel.ClearAndSelect\n        )\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.RenameTreeItemCommand","title":"<code>TiBi.logic.commands.RenameTreeItemCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Change the name of a tree item in the unit cells model.</p> <p>The name is changed by double-clicking on an item in the tree view.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Dictionary containing the current selection</p> <code>tree_view</code> <code>SystemTree</code> <p>UI object containing the tree view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed</p> <code>item</code> <code>QStandardItem</code> <p>The item in the tree view that was changed</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>site_id</code> <code>UUID</code> <p>UUID of the selected <code>Site</code> when the command was issued</p> <code>state_id</code> <code>UUID</code> <p>UUID of the selected <code>State</code> when the command was issued</p> <code>old_name</code> <code>str</code> <p>The old name of the item before the change</p> <code>new_name</code> <code>str</code> <p>The new name of the item after the change</p> Source code in <code>TiBi/logic/commands/tree_commands.py</code> <pre><code>class RenameTreeItemCommand(QUndoCommand):\n    \"\"\"\n    Change the name of a tree item in the unit cells model.\n\n    The name is changed by double-clicking on an item in the tree view.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Dictionary containing the current selection\n    tree_view : SystemTree\n        UI object containing the tree view\n    signal : Signal\n        Signal to be emitted when the command is executed\n    item : QStandardItem\n        The item in the tree view that was changed\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    site_id : uuid.UUID\n        UUID of the selected `Site` when the command was issued\n    state_id : uuid.UUID\n        UUID of the selected `State` when the command was issued\n    old_name : str\n        The old name of the item before the change\n    new_name : str\n        The new name of the item after the change\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        tree_view: SystemTree,\n        signal: Signal,\n        item: QStandardItem,\n    ):\n        super().__init__(\"Rename Tree Item\")\n\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.tree_view = tree_view\n        self.signal = signal\n        self.new_name = item.text()\n\n        self.uc_id = self.selection.unit_cell\n        self.site_id = self.selection.site\n        self.state_id = self.selection.state\n\n        # Get the old name\n        if self.state_id:\n            self.old_name = (\n                self.unit_cells[self.uc_id]\n                .sites[self.site_id]\n                .states[self.state_id]\n                .name\n            )\n        elif self.site_id:\n            self.old_name = (\n                self.unit_cells[self.uc_id].sites[self.site_id].name\n            )\n        else:\n            self.old_name = self.unit_cells[self.uc_id].name\n\n    def redo(self):\n        item = self.tree_view.find_item_by_id(\n            self.uc_id, self.site_id, self.state_id\n        )\n        if self.state_id:\n            self.unit_cells[self.uc_id].sites[self.site_id].states[\n                self.state_id\n            ].name = self.new_name\n\n        elif self.site_id:\n            self.unit_cells[self.uc_id].sites[\n                self.site_id\n            ].name = self.new_name\n        else:\n            self.unit_cells[self.uc_id].name = self.new_name\n\n        item.setText(self.new_name)\n        self.signal.emit()\n\n    def undo(self):\n        item = self.tree_view.find_item_by_id(\n            self.uc_id, self.site_id, self.state_id\n        )\n        if self.state_id:\n            self.unit_cells[self.uc_id].sites[self.site_id].states[\n                self.state_id\n            ].name = self.old_name\n\n        elif self.site_id:\n            self.unit_cells[self.uc_id].sites[\n                self.site_id\n            ].name = self.old_name\n        else:\n            self.unit_cells[self.uc_id].name = self.old_name\n\n        item.setText(self.old_name)\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#hopping-commands","title":"Hopping Commands","text":""},{"location":"dev/logic/#TiBi.logic.commands.SaveHoppingsCommand","title":"<code>TiBi.logic.commands.SaveHoppingsCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Save the hoppings between two states.</p> <p>Update the entry in the <code>hoppings</code> dictionary of the selected unit for the selected pair of states.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Reference to the dictionary mapping UUIDs to UnitCell objects</p> <code>selection</code> <code>Selection</code> <p>Reference to the dictionary containing the current selection</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>site_id</code> <code>UUID</code> <p>UUID of the selected <code>Site</code> when the command was issued</p> <code>state_id</code> <code>UUID</code> <p>UUID of the selected <code>State</code> when the command was issued</p> <code>pair_selection</code> <code>list[Tuple[str, UUID, str, UUID]]</code> <p>Reference to the list of selected <code>State</code>s</p> <code>s1, s2</code> <code>Tuple[str, UUID, str, UUID]</code> <p>Information tuples for the selected <code>State</code>s, containing (site name, site UUID, state name, state UUID) when the command was issued</p> <code>new_hoppings</code> <code>list[Tuple[Tuple[int, int, int], complex128]]</code> <p>List of new hoppings to be added to the <code>hoppings</code> dictionary</p> <code>old_hoppings</code> <code>list[Tuple[Tuple[int, int, int], complex128]]</code> <p>List of old hoppings to be removed from the <code>hoppings</code> dictionary</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed. The signal carries the information about the selected <code>UnitCell</code>, <code>Site</code>, <code>State</code>, and the selected pair of <code>State</code>s.</p> Source code in <code>TiBi/logic/commands/hopping_commands.py</code> <pre><code>class SaveHoppingsCommand(QUndoCommand):\n    \"\"\"\n    Save the hoppings between two states.\n\n    Update the entry in the `hoppings` dictionary of the selected unit\n    for the selected pair of states.\n\n    Attributes\n    ----------\n\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Reference to the dictionary mapping UUIDs to UnitCell objects\n    selection : Selection\n        Reference to the dictionary containing the current selection\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    site_id : uuid.UUID\n        UUID of the selected `Site` when the command was issued\n    state_id : uuid.UUID\n        UUID of the selected `State` when the command was issued\n    pair_selection : list[Tuple[str, uuid.UUID, str, uuid.UUID]]\n        Reference to the list of selected `State`s\n    s1, s2 : Tuple[str, uuid.UUID, str, uuid.UUID]\n        Information tuples for the selected `State`s, containing\n        (site name, site UUID, state name, state UUID) when the\n        command was issued\n    new_hoppings : list[Tuple[Tuple[int, int, int], np.complex128]]\n        List of new hoppings to be added to the `hoppings` dictionary\n    old_hoppings : list[Tuple[Tuple[int, int, int], np.complex128]]\n        List of old hoppings to be removed from the `hoppings` dictionary\n    signal : Signal\n        Signal to be emitted when the command is executed. The signal\n        carries the information about the selected `UnitCell`, `Site`,\n        `State`, and the selected pair of `State`s.\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        pair_selection: list[Tuple[str, uuid.UUID, str, uuid.UUID]],\n        new_hoppings: list[Tuple[Tuple[int, int, int], np.complex128]],\n        signal: Signal,\n    ):\n        super().__init__(\"Modify Hoppings\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.uc_id = self.selection.unit_cell\n        self.site_id = self.selection.site\n        self.state_id = self.selection.state\n\n        # Selected state UUIDs\n        self.pair_selection = pair_selection\n        self.s1 = pair_selection[0]\n        self.s2 = pair_selection[1]\n\n        self.new_hoppings = new_hoppings\n        self.old_hoppings = copy.deepcopy(\n            self.unit_cells[self.uc_id].hoppings.get(\n                (self.s1[3], self.s2[3]), []\n            )\n        )\n        self.signal = signal\n\n    def redo(self):\n        # Insert the hoppings into the unit cell model\n        if self.new_hoppings == []:\n            self.unit_cells[self.uc_id].hoppings.pop(\n                (self.s1[3], self.s2[3]), None\n            )\n        else:\n            self.unit_cells[self.uc_id].hoppings[\n                (self.s1[3], self.s2[3])\n            ] = self.new_hoppings\n        self.unit_cells[self.uc_id].bandstructure.reset_bands()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        # Emit the signal with appropriate selection parameters\n        self.signal.emit(\n            self.uc_id, self.site_id, self.state_id, self.s1, self.s2\n        )\n\n    def undo(self):\n        # Insert the hoppings into the unit cell model\n        if self.old_hoppings == []:\n            self.unit_cells[self.uc_id].hoppings.pop(\n                (self.s1[3], self.s2[3]), None\n            )\n        else:\n            self.unit_cells[self.uc_id].hoppings[\n                (self.s1[3], self.s2[3])\n            ] = self.old_hoppings\n        self.unit_cells[self.uc_id].bandstructure.reset_bands()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        # Emit the signal with appropriate selection parameters\n        self.signal.emit(\n            self.uc_id, self.site_id, self.state_id, self.s1, self.s2\n        )\n</code></pre>"},{"location":"dev/logic/#unit-cell-commands","title":"Unit Cell Commands","text":""},{"location":"dev/logic/#TiBi.logic.commands.UpdateUnitCellParameterCommand","title":"<code>TiBi.logic.commands.UpdateUnitCellParameterCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Update a parameter of the selected <code>UnitCell</code>.</p> <p>This command is used to update the basis vectors of the unit cell when the user types in the spinbox.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>vector</code> <code>str</code> <p>The vector to be updated (v1, v2, or v3)</p> <code>coordinate</code> <code>str</code> <p>The coordinate to be updated (x, y, or z)</p> <code>spinbox</code> <code>QDoubleSpinBox</code> <p>The spinbox widget used to input the new value</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed, requesting a plot update</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>old_value</code> <code>float</code> <p>The old value of the parameter before the change</p> <code>new_value</code> <code>float</code> <p>The new value of the parameter after the change</p> Source code in <code>TiBi/logic/commands/uc_commands.py</code> <pre><code>class UpdateUnitCellParameterCommand(QUndoCommand):\n    \"\"\"\n    Update a parameter of the selected `UnitCell`.\n\n    This command is used to update the basis vectors of the unit cell\n    when the user types in the spinbox.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    vector : str\n        The vector to be updated (v1, v2, or v3)\n    coordinate : str\n        The coordinate to be updated (x, y, or z)\n    spinbox : QDoubleSpinBox\n        The spinbox widget used to input the new value\n    signal : Signal\n        Signal to be emitted when the command is executed,\n        requesting a plot update\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    old_value : float\n        The old value of the parameter before the change\n    new_value : float\n        The new value of the parameter after the change\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        vector: str,\n        coordinate: str,\n        spinbox: QDoubleSpinBox,\n        signal: Signal,\n    ):\n        super().__init__(\"Update Unit Cell Parameter\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.vector = vector\n        self.coordinate = coordinate\n        self.spinbox = spinbox\n        self.signal = signal\n        self.new_value = self.spinbox.value()\n\n        self.uc_id = self.selection.unit_cell\n\n        self.old_value = getattr(\n            getattr(self.unit_cells[self.uc_id], self.vector),\n            self.coordinate,\n        )\n\n    def redo(self):\n        setattr(\n            getattr(self.unit_cells[self.uc_id], self.vector),\n            self.coordinate,\n            self.new_value,\n        )\n        self.spinbox.setValue(self.new_value)\n        self.unit_cells[self.uc_id].bandstructure.clear()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        self.signal.emit()\n\n    def undo(self):\n        setattr(\n            getattr(self.unit_cells[self.uc_id], self.vector),\n            self.coordinate,\n            self.old_value,\n        )\n        self.spinbox.setValue(self.old_value)\n        self.unit_cells[self.uc_id].bandstructure.clear()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.ReduceBasisCommand","title":"<code>TiBi.logic.commands.ReduceBasisCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Reduce the basis vectors of the selected unit cell.</p> <p>This method applies the Lenstra-Lenstra-Lov\u00e1sz (LLL) lattice reduction algorithm to find a more orthogonal set of basis vectors that spans the same lattice. This is useful for finding a 'nicer' representation of the unit cell with basis vectors that are shorter and more orthogonal to each other.</p> <p>The method only affects the periodic directions of the unit cell. After reduction, the UI is updated to reflect the new basis vectors.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>unit_cell_view</code> <code>UnitCellView</code> <p>UI object containing the unit cell view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed, requesting a plot update</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>old_basis</code> <code>list[BasisVector]</code> <p>The old basis vectors of the unit cell before reduction</p> <code>new_basis</code> <code>list[BasisVector]</code> <p>The new basis vectors of the unit cell after reduction</p> Source code in <code>TiBi/logic/commands/uc_commands.py</code> <pre><code>class ReduceBasisCommand(QUndoCommand):\n    \"\"\"\n    Reduce the basis vectors of the selected unit cell.\n\n    This method applies the Lenstra-Lenstra-Lov\u00e1sz (LLL) lattice\n    reduction algorithm to find a more orthogonal set of basis\n    vectors that spans the same lattice.\n    This is useful for finding a 'nicer' representation of the unit cell\n    with basis vectors that are shorter and more orthogonal to each other.\n\n    The method only affects the periodic directions of the unit cell. After\n    reduction, the UI is updated to reflect the new basis vectors.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    unit_cell_view : UnitCellView\n        UI object containing the unit cell view\n    signal : Signal\n        Signal to be emitted when the command is executed,\n        requesting a plot update\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    old_basis : list[BasisVector]\n        The old basis vectors of the unit cell before reduction\n    new_basis : list[BasisVector]\n        The new basis vectors of the unit cell after reduction\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        unit_cell_view: UnitCellView,\n        signal: Signal,\n    ):\n        super().__init__(\"Reduce Basis\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.unit_cell_view = unit_cell_view\n        self.signal = signal\n\n        self.uc_id = self.selection.unit_cell\n\n        if self.uc_id:\n            uc = self.unit_cells[self.uc_id]\n            self.old_basis = [uc.v1, uc.v2, uc.v3]\n            self.new_basis = uc.reduced_basis()\n\n    def redo(self):\n        if self.uc_id:\n            uc = self.unit_cells[self.uc_id]\n            uc.v1 = self.new_basis[0]\n            uc.v2 = self.new_basis[1]\n            uc.v3 = self.new_basis[2]\n\n            # Clear focus to avoid conflicts with programmatic\n            # filling of the boxes\n            focused_widget = QApplication.focusWidget()\n            if focused_widget:\n                focused_widget.clearFocus()\n            QApplication.processEvents()\n\n            self.unit_cell_view.unit_cell_panel.set_basis_vectors(\n                uc.v1, uc.v2, uc.v3\n            )\n            self.unit_cells[self.uc_id].bandstructure.clear()\n            self.unit_cells[self.uc_id].bz_grid.clear()\n            self.signal.emit()\n\n    def undo(self):\n        if self.uc_id:\n            uc = self.unit_cells[self.uc_id]\n            uc.v1 = self.old_basis[0]\n            uc.v2 = self.old_basis[1]\n            uc.v3 = self.old_basis[2]\n\n            # Clear focus to avoid conflicts with programmatic\n            # filling of the boxes\n            focused_widget = QApplication.focusWidget()\n            if focused_widget:\n                focused_widget.clearFocus()\n            QApplication.processEvents()\n\n            self.unit_cell_view.unit_cell_panel.set_basis_vectors(\n                uc.v1, uc.v2, uc.v3\n            )\n            self.unit_cells[self.uc_id].bandstructure.clear()\n            self.unit_cells[self.uc_id].bz_grid.clear()\n            self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.ChangeDimensionalityCommand","title":"<code>TiBi.logic.commands.ChangeDimensionalityCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Change the dimensionality of the selected <code>UnitCell</code> (0D, 1D, 2D, 3D).</p> <p>This method is called when the user selects a different dimensionality radio button. It updates the unit cell's periodicity flags and enables/disables appropriate basis vector components based on the selected dimensionality.</p> <p>For example: - 0D: All directions are non-periodic (isolated system) - 1D: First direction is periodic, others are not - 2D: First and second directions are periodic, third is not - 3D: All directions are periodic (fully periodic crystal)</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>unit_cell_view</code> <code>UnitCellView</code> <p>UI object containing the unit cell view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed, requesting a plot update</p> <code>dim</code> <code>int</code> <p>The new dimensionality of the unit cell (0, 1, 2, or 3)</p> <code>buttons</code> <code>list[QRadioButton]</code> <p>List of radio buttons corresponding to the dimensionality options in the UI</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>old_v1</code> <code>BasisVector</code> <p>The old basis vector 1 of the unit cell before the change</p> <code>old_v2</code> <code>BasisVector</code> <p>The old basis vector 2 of the unit cell before the change</p> <code>old_v3</code> <code>BasisVector</code> <p>The old basis vector 3 of the unit cell before the change</p> <code>old_dim</code> <code>int</code> <p>The old dimensionality of the unit cell before the change</p> <code>new_v1</code> <code>BasisVector</code> <p>The new basis vector 1 of the unit cell after the change</p> <code>new_v2</code> <code>BasisVector</code> <p>The new basis vector 2 of the unit cell after the change</p> <code>new_v3</code> <code>BasisVector</code> <p>The new basis vector 3 of the unit cell after the change</p> Source code in <code>TiBi/logic/commands/uc_commands.py</code> <pre><code>class ChangeDimensionalityCommand(QUndoCommand):\n    \"\"\"\n    Change the dimensionality of the selected `UnitCell` (0D, 1D, 2D, 3D).\n\n    This method is called when the user selects a different dimensionality\n    radio button.\n    It updates the unit cell's periodicity flags and enables/disables\n    appropriate basis vector components based on\n    the selected dimensionality.\n\n    For example:\n    - 0D: All directions are non-periodic (isolated system)\n    - 1D: First direction is periodic, others are not\n    - 2D: First and second directions are periodic, third is not\n    - 3D: All directions are periodic (fully periodic crystal)\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    unit_cell_view : UnitCellView\n        UI object containing the unit cell view\n    signal : Signal\n        Signal to be emitted when the command is executed,\n        requesting a plot update\n    dim : int\n        The new dimensionality of the unit cell (0, 1, 2, or 3)\n    buttons : list[QRadioButton]\n        List of radio buttons corresponding to the dimensionality\n        options in the UI\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    old_v1 : BasisVector\n        The old basis vector 1 of the unit cell before the change\n    old_v2 : BasisVector\n        The old basis vector 2 of the unit cell before the change\n    old_v3 : BasisVector\n        The old basis vector 3 of the unit cell before the change\n    old_dim : int\n        The old dimensionality of the unit cell before the change\n    new_v1 : BasisVector\n        The new basis vector 1 of the unit cell after the change\n    new_v2 : BasisVector\n        The new basis vector 2 of the unit cell after the change\n    new_v3 : BasisVector\n        The new basis vector 3 of the unit cell after the change\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        unit_cell_view: UnitCellView,\n        signal: Signal,\n        dim: int,\n        buttons: list[QRadioButton],\n    ):\n        super().__init__(\"Change dimensionality\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.unit_cell_view = unit_cell_view\n        self.signal = signal\n        self.new_dim = dim\n        self.buttons = buttons\n\n        self.uc_id = self.selection.unit_cell\n        uc = self.unit_cells[self.uc_id]\n        self.old_v1 = uc.v1\n        self.old_v2 = uc.v2\n        self.old_v3 = uc.v3\n        self.old_dim = (\n            uc.v1.is_periodic + uc.v2.is_periodic + uc.v3.is_periodic\n        )\n\n        if dim == 0:\n            self.new_v1 = BasisVector(1, 0, 0, False)\n            self.new_v2 = BasisVector(0, 1, 0, False)\n            self.new_v3 = BasisVector(0, 0, 1, False)\n\n        elif dim == 1:\n            self.new_v1 = BasisVector(self.old_v1.x, 0, 0, True)\n            self.new_v2 = BasisVector(0, self.old_v2.y, 0, False)\n            self.new_v3 = BasisVector(0, 0, self.old_v3.z, False)\n\n        elif dim == 2:\n            self.new_v1 = BasisVector(self.old_v1.x, self.old_v1.y, 0, True)\n            self.new_v2 = BasisVector(self.old_v2.x, self.old_v2.y, 0, True)\n            self.new_v3 = BasisVector(0, 0, self.old_v3.z, False)\n\n        else:\n            self.new_v1 = BasisVector(\n                self.old_v1.x, self.old_v1.y, self.old_v1.z, True\n            )\n            self.new_v2 = BasisVector(\n                self.old_v2.x, self.old_v2.y, self.old_v2.z, True\n            )\n            self.new_v3 = BasisVector(\n                self.old_v3.x, self.old_v3.y, self.old_v3.z, True\n            )\n\n    def redo(self):\n        self._set_vector_enables(self.new_dim)\n\n        uc = self.unit_cells[self.uc_id]\n        uc.v1 = self.new_v1\n        uc.v2 = self.new_v2\n        uc.v3 = self.new_v3\n\n        self.unit_cell_view.unit_cell_panel.set_basis_vectors(\n            uc.v1, uc.v2, uc.v3\n        )\n\n        self._set_checked_button(self.new_dim)\n        self.unit_cells[self.uc_id].bandstructure.clear()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        self.signal.emit()\n\n    def undo(self):\n\n        self._set_vector_enables(self.old_dim)\n\n        uc = self.unit_cells[self.uc_id]\n        uc.v1 = self.old_v1\n        uc.v2 = self.old_v2\n        uc.v3 = self.old_v3\n\n        self.unit_cell_view.unit_cell_panel.set_basis_vectors(\n            uc.v1, uc.v2, uc.v3\n        )\n\n        self._set_checked_button(self.old_dim)\n        self.unit_cells[self.uc_id].bandstructure.clear()\n        self.unit_cells[self.uc_id].bz_grid.clear()\n        self.signal.emit()\n\n    def _set_vector_enables(self, dim):\n        \"\"\"\n        Enable or disable the basis vector components.\n\n        The enabling/disabling is based on the\n        dimensionality of the unit cell.\n\n        Parameters\n        ----------\n        dim : int\n            The new dimensionality of the unit cell (0, 1, 2, or 3)\n        \"\"\"\n        self.unit_cell_view.unit_cell_panel.v1[0].setEnabled(True)\n        self.unit_cell_view.unit_cell_panel.v1[1].setEnabled(dim &gt; 1)\n        self.unit_cell_view.unit_cell_panel.v1[2].setEnabled(dim &gt; 2)\n\n        self.unit_cell_view.unit_cell_panel.v2[0].setEnabled(dim &gt; 1)\n        self.unit_cell_view.unit_cell_panel.v2[1].setEnabled(True)\n        self.unit_cell_view.unit_cell_panel.v2[2].setEnabled(dim &gt; 2)\n\n        self.unit_cell_view.unit_cell_panel.v3[0].setEnabled(dim &gt; 2)\n        self.unit_cell_view.unit_cell_panel.v3[1].setEnabled(dim &gt; 2)\n        self.unit_cell_view.unit_cell_panel.v3[2].setEnabled(True)\n\n    def _set_checked_button(self, dim):\n        \"\"\"\n        Set the radio button corresponding to the dimensionality.\n\n        The radio button is checked and all others are unchecked.\n        This is done by blocking signals to avoid triggering\n        the button's clicked signal when setting the checked state.\n\n        Parameters\n        ----------\n        dim : int\n            The new dimensionality of the unit cell (0, 1, 2, or 3)\n        \"\"\"\n        for btn in self.buttons:\n            btn.blockSignals(True)\n        self.buttons[dim].setChecked(True)\n        for btn in self.buttons:\n            btn.blockSignals(False)\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.UpdateSiteParameterCommand","title":"<code>TiBi.logic.commands.UpdateSiteParameterCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Update a parameter of the selected <code>Site</code>.</p> <p>This command is used to update the basis vectors of the site when the user types in the spinbox.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>param</code> <code>str</code> <p>The parameter to be updated (radius, color, etc.)</p> <code>spinbox</code> <code>QDoubleSpinBox</code> <p>The spinbox widget used to input the new value</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed, requesting a plot update</p> <code>uc_id</code> <code>UUID</code> <p>UUID of the selected <code>UnitCell</code> when the command was issued</p> <code>site_id</code> <code>UUID</code> <p>UUID of the selected <code>Site</code> when the command was issued</p> <code>old_value</code> <code>float</code> <p>The old value of the parameter before the change</p> <code>new_value</code> <code>float</code> <p>The new value of the parameter after the change</p> Source code in <code>TiBi/logic/commands/uc_commands.py</code> <pre><code>class UpdateSiteParameterCommand(QUndoCommand):\n    \"\"\"\n    Update a parameter of the selected `Site`.\n\n    This command is used to update the basis vectors of the site\n    when the user types in the spinbox.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    param : str\n        The parameter to be updated (radius, color, etc.)\n    spinbox : QDoubleSpinBox\n        The spinbox widget used to input the new value\n    signal : Signal\n        Signal to be emitted when the command is executed,\n        requesting a plot update\n    uc_id : uuid.UUID\n        UUID of the selected `UnitCell` when the command was issued\n    site_id : uuid.UUID\n        UUID of the selected `Site` when the command was issued\n    old_value : float\n        The old value of the parameter before the change\n    new_value : float\n        The new value of the parameter after the change\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        param: str,\n        spinbox: QDoubleSpinBox,\n        signal: Signal,\n    ):\n        super().__init__(\"Update Site Parameter\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.param = param\n        self.spinbox = spinbox\n        self.signal = signal\n        self.new_value = self.spinbox.value()\n\n        self.uc_id = self.selection.unit_cell\n        self.site_id = self.selection.site\n\n        self.old_value = getattr(\n            self.unit_cells[self.uc_id].sites[self.site_id],\n            self.param,\n        )\n\n    def redo(self):\n        setattr(\n            self.unit_cells[self.uc_id].sites[self.site_id],\n            self.param,\n            self.new_value,\n        )\n        self.spinbox.setValue(self.new_value)\n        self.signal.emit()\n\n    def undo(self):\n        setattr(\n            self.unit_cells[self.uc_id].sites[self.site_id],\n            self.param,\n            self.old_value,\n        )\n        self.spinbox.setValue(self.old_value)\n        self.signal.emit()\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.commands.ChangeSiteColorCommand","title":"<code>TiBi.logic.commands.ChangeSiteColorCommand</code>","text":"<p>               Bases: <code>QUndoCommand</code></p> <p>Change the color of the selected <code>Site</code>.</p> <p>Attributes:</p> Name Type Description <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> <code>selection</code> <code>Selection</code> <p>Model tracking the currently selected unit cell, site, and state</p> <code>new_color</code> <code>QColor</code> <p>The new color to be set for the site</p> <code>old_color</code> <code>QColor</code> <p>The old color of the site before the change</p> <code>unit_cell_view</code> <code>UnitCellView</code> <p>UI object containing the unit cell view</p> <code>signal</code> <code>Signal</code> <p>Signal to be emitted when the command is executed, requesting a plot update</p> Source code in <code>TiBi/logic/commands/uc_commands.py</code> <pre><code>class ChangeSiteColorCommand(QUndoCommand):\n    \"\"\"\n    Change the color of the selected `Site`.\n\n    Attributes\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    selection : Selection\n        Model tracking the currently selected unit cell, site, and state\n    new_color : QColor\n        The new color to be set for the site\n    old_color : QColor\n        The old color of the site before the change\n    unit_cell_view : UnitCellView\n        UI object containing the unit cell view\n    signal : Signal\n        Signal to be emitted when the command is executed,\n        requesting a plot update\n    \"\"\"\n\n    def __init__(\n        self,\n        unit_cells: dict[uuid.UUID, UnitCell],\n        selection: Selection,\n        new_color: QColor,\n        old_color: QColor,\n        unit_cell_view: UnitCellView,\n        signal: Signal,\n    ):\n        super().__init__(\"Change Site Color\")\n        self.unit_cells = unit_cells\n        self.selection = selection\n        self.new_color = new_color\n        self.old_color = old_color\n        self.unit_cell_view = unit_cell_view\n        self.signal = signal\n\n    def redo(self):\n        self._set_color(self.new_color)\n        self.signal.emit()\n\n    def undo(self):\n        self._set_color(self.old_color)\n        self.signal.emit()\n\n    def _set_color(self, color):\n        rgba = (\n            f\"rgba({color.red()}, \"\n            f\"{color.green()}, \"\n            f\"{color.blue()}, \"\n            f\"{color.alpha()})\"\n        )\n        self.unit_cell_view.site_panel.color_picker_btn.setStyleSheet(\n            f\"background-color: {rgba};\"\n        )\n\n        # Update the color in the dictionary (0-1 scale)\n        self.unit_cells[self.selection.unit_cell].sites[\n            self.selection.site\n        ].color = (\n            color.redF(),\n            color.greenF(),\n            color.blueF(),\n            color.alphaF(),\n        )\n</code></pre>"},{"location":"dev/logic/#serialization","title":"Serialization","text":""},{"location":"dev/logic/#TiBi.logic.serialization.UnitCellEncoder","title":"<code>TiBi.logic.serialization.UnitCellEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSON encoder for UnitCell objects and their components.</p> <p>Handles serialization of custom types to JSON-compatible formats: - UUID objects are converted to strings - NumPy complex values are converted to [real, imag] lists - NumPy arrays are converted to lists - BasisVector, State, Site, and UnitCell objects are converted to dicts - Dictionaries with UUID keys are converted to dicts with string keys - Tuples with UUID elements are converted to strings</p> Source code in <code>TiBi/logic/serialization/serialization.py</code> <pre><code>class UnitCellEncoder(json.JSONEncoder):\n    \"\"\"\n    Custom JSON encoder for UnitCell objects and their components.\n\n    Handles serialization of custom types to JSON-compatible formats:\n    - UUID objects are converted to strings\n    - NumPy complex values are converted to [real, imag] lists\n    - NumPy arrays are converted to lists\n    - BasisVector, State, Site, and UnitCell objects are converted to dicts\n    - Dictionaries with UUID keys are converted to dicts with string keys\n    - Tuples with UUID elements are converted to strings\n    \"\"\"\n\n    def default(self, obj):\n        # Handle UUID objects\n        if isinstance(obj, uuid.UUID):\n            return str(obj)\n\n        # Handle NumPy complex numbers\n        if isinstance(obj, complex) or np.issubdtype(\n            type(obj), np.complexfloating\n        ):\n            return [obj.real, obj.imag]\n\n        # Handle NumPy arrays\n        if isinstance(obj, np.ndarray):\n            return obj.tolist()\n\n        # Handle BandStructure objects\n        if isinstance(obj, BandStructure):\n            return {\n                \"type\": \"BandStructure\",\n                \"path\": [x.tolist() for x in obj.path],\n                \"special_points\": [x.tolist() for x in obj.special_points],\n                \"eigenvalues\": [x.tolist() for x in obj.eigenvalues],\n                \"eigenvectors\": [x.tolist() for x in obj.eigenvectors],\n            }\n\n        # Handle BrillouinZoneGrid objects\n        if isinstance(obj, BrillouinZoneGrid):\n            return {\n                \"type\": \"BrillouinZoneGrid\",\n                \"is_gamma_centered\": obj.is_gamma_centered,\n                \"grid_divs\": list(obj.grid_divs),\n                \"k_points\": [x.tolist() for x in obj.k_points],\n                \"eigenvalues\": [x.tolist() for x in obj.eigenvalues],\n                \"eigenvectors\": [x.tolist() for x in obj.eigenvectors],\n            }\n\n        # Handle BasisVector objects\n        if isinstance(obj, BasisVector):\n            return {\n                \"type\": \"BasisVector\",\n                \"x\": obj.x,\n                \"y\": obj.y,\n                \"z\": obj.z,\n                \"is_periodic\": obj.is_periodic,\n            }\n\n        # Handle State objects\n        if isinstance(obj, State):\n            return {\"type\": \"State\", \"name\": obj.name, \"id\": obj.id}\n\n        # Handle Site objects\n        if isinstance(obj, Site):\n            # Convert states dictionary to have string keys\n            states_dict = {str(k): v for k, v in obj.states.items()}\n            return {\n                \"type\": \"Site\",\n                \"name\": obj.name,\n                \"c1\": obj.c1,\n                \"c2\": obj.c2,\n                \"c3\": obj.c3,\n                \"R\": obj.R,\n                \"color\": obj.color,\n                \"states\": states_dict,\n                \"id\": obj.id,\n            }\n\n        # Handle UnitCell objects\n        if isinstance(obj, UnitCell):\n            # Convert sites dictionary to have string keys\n            sites_dict = {str(k): v for k, v in obj.sites.items()}\n\n            # Convert hoppings dictionary with tuple keys to string keys\n            hoppings_dict = {\n                f\"{str(k[0])},{str(k[1])}\": v for k, v in obj.hoppings.items()\n            }\n\n            return {\n                \"type\": \"UnitCell\",\n                \"name\": obj.name,\n                \"v1\": obj.v1,\n                \"v2\": obj.v2,\n                \"v3\": obj.v3,\n                \"sites\": sites_dict,\n                \"hoppings\": hoppings_dict,\n                \"bandstructure\": obj.bandstructure,\n                \"bz_grid\": obj.bz_grid,\n                \"id\": obj.id,\n            }\n\n        # Let the parent class handle all other types\n        return super().default(obj)\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.serialization.decode_unit_cell_json","title":"<code>TiBi.logic.serialization.decode_unit_cell_json(json_obj)</code>","text":"<p>Decode JSON objects into their appropriate custom types.</p> <p>This is used as the object_hook for json.loads() to deserialize JSON data back into UnitCell, Site, State, and BasisVector objects.</p> <p>Parameters:</p> Name Type Description Default <code>json_obj</code> <code>dict</code> <p>A dictionary representing a JSON object</p> required <p>Returns:</p> Type Description <code>The appropriate Python object based on the 'type' field</code> Source code in <code>TiBi/logic/serialization/serialization.py</code> <pre><code>def decode_unit_cell_json(json_obj: dict[str, Any]) -&gt; Any:\n    \"\"\"\n    Decode JSON objects into their appropriate custom types.\n\n    This is used as the object_hook for json.loads() to deserialize\n    JSON data back into UnitCell, Site, State, and BasisVector objects.\n\n    Parameters\n    ----------\n    json_obj : dict\n        A dictionary representing a JSON object\n\n    Returns\n    -------\n    The appropriate Python object based on the 'type' field\n    \"\"\"\n    # Check if this is one of our custom types\n    if \"type\" in json_obj:\n        obj_type = json_obj[\"type\"]\n\n        # Handle BandStructure\n        if obj_type == \"BandStructure\":\n            return BandStructure(\n                path=[np.array(x) for x in json_obj[\"path\"]],\n                special_points=[\n                    np.array(x) for x in json_obj[\"special_points\"]\n                ],\n                eigenvalues=[np.array(x) for x in json_obj[\"eigenvalues\"]],\n                eigenvectors=[\n                    np.array(\n                        [\n                            [\n                                complex(real=real, imag=imag)\n                                for real, imag in row\n                                # Destructure each length-2 list\n                            ]\n                            for row in mat\n                        ],\n                        dtype=np.complex128,\n                    )\n                    for mat in json_obj[\n                        \"eigenvectors\"\n                    ]  # Each mat corresponds to a momentum point\n                ],\n            )\n        # Handle BandStructure\n        elif obj_type == \"BrillouinZoneGrid\":\n            return BrillouinZoneGrid(\n                is_gamma_centered=json_obj[\"is_gamma_centered\"],\n                grid_divs=tuple(json_obj[\"grid_divs\"]),\n                k_points=[np.array(x) for x in json_obj[\"k_points\"]],\n                eigenvalues=[np.array(x) for x in json_obj[\"eigenvalues\"]],\n                eigenvectors=[\n                    np.array(\n                        [\n                            [\n                                complex(real=real, imag=imag)\n                                for real, imag in row\n                                # Destructure each length-2 list\n                            ]\n                            for row in mat\n                        ],\n                        dtype=np.complex128,\n                    )\n                    for mat in json_obj[\n                        \"eigenvectors\"\n                    ]  # Each mat corresponds to a momentum point\n                ],\n            )\n        # Handle BasisVector\n        elif obj_type == \"BasisVector\":\n            return BasisVector(\n                x=json_obj[\"x\"],\n                y=json_obj[\"y\"],\n                z=json_obj[\"z\"],\n                is_periodic=json_obj[\"is_periodic\"],\n            )\n\n        # Handle State\n        elif obj_type == \"State\":\n            return State(name=json_obj[\"name\"], id=uuid.UUID(json_obj[\"id\"]))\n\n        # Handle Site\n        elif obj_type == \"Site\":\n            site = Site(\n                name=json_obj[\"name\"],\n                c1=json_obj[\"c1\"],\n                c2=json_obj[\"c2\"],\n                c3=json_obj[\"c3\"],\n                R=json_obj[\"R\"],\n                color=tuple(json_obj[\"color\"]),\n                id=uuid.UUID(json_obj[\"id\"]),\n            )\n            # Convert state dict with string keys back to UUID keys\n            for state_id_str, state in json_obj[\"states\"].items():\n                site.states[uuid.UUID(state_id_str)] = state\n            return site\n\n        # Handle UnitCell\n        elif obj_type == \"UnitCell\":\n            unit_cell = UnitCell(\n                name=json_obj[\"name\"],\n                v1=json_obj[\"v1\"],\n                v2=json_obj[\"v2\"],\n                v3=json_obj[\"v3\"],\n                bandstructure=json_obj[\"bandstructure\"],\n                bz_grid=json_obj[\"bz_grid\"],\n                id=uuid.UUID(json_obj[\"id\"]),\n            )\n\n            # Convert sites dict with string keys back to UUID keys\n            for site_id_str, site in json_obj[\"sites\"].items():\n                unit_cell.sites[uuid.UUID(site_id_str)] = site\n\n            # Convert hoppings dict with tuple of string keys back to tuple of\n            # UUID keys and convert complex values from [real, imag] format\n            # back to complex numbers\n            for hopping_key_str, hopping_values in json_obj[\n                \"hoppings\"\n            ].items():\n                # Parse the string key '(uuid1, uuid2)' back to tuple of UUIDs\n                k1_str, k2_str = hopping_key_str.split(\",\")\n                key = (uuid.UUID(k1_str), uuid.UUID(k2_str))\n\n                # Convert the hopping values: [(displacement, amplitude), ...]\n                converted_values = []\n                for displacement_list, amplitude_list in hopping_values:\n                    # displacement = (\n                    #     displacement_list[0],\n                    #     displacement_list[1],\n                    #     displacement_list[2],\n                    # )\n                    displacement = tuple(displacement_list)\n                    # Convert [real, imag] list back to complex\n                    amplitude = complex(amplitude_list[0], amplitude_list[1])\n                    converted_values.append((displacement, amplitude))\n\n                unit_cell.hoppings[key] = converted_values\n\n            return unit_cell\n\n    # If not a custom type, return the object as is\n    return json_obj\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.serialization.serialize_unit_cells","title":"<code>TiBi.logic.serialization.serialize_unit_cells(unit_cells)</code>","text":"<p>Serialize a dictionary of <code>UnitCell</code> objects to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation of the unit_cells dictionary</p> Source code in <code>TiBi/logic/serialization/serialization.py</code> <pre><code>def serialize_unit_cells(unit_cells: dict[uuid.UUID, UnitCell]) -&gt; str:\n    \"\"\"\n    Serialize a dictionary of `UnitCell` objects to a JSON string.\n\n    Parameters\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n\n    Returns\n    -------\n    str\n        JSON string representation of the unit_cells dictionary\n    \"\"\"\n    # Convert dictionary with UUID keys to string keys for JSON serialization\n    serializable_dict = {str(k): v for k, v in unit_cells.items()}\n    return json.dumps(serializable_dict, cls=UnitCellEncoder, indent=2)\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.serialization.deserialize_unit_cells","title":"<code>TiBi.logic.serialization.deserialize_unit_cells(json_str)</code>","text":"<p>Deserialize a JSON string back into a dictionary of <code>UnitCell</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>JSON string representation of unit_cells dictionary</p> required <p>Returns:</p> Type Description <code>dict[UUID, UnitCell]</code> <p>Dictionary mapping UUIDs to <code>UnitCell</code> objects</p> Source code in <code>TiBi/logic/serialization/serialization.py</code> <pre><code>def deserialize_unit_cells(json_str: str) -&gt; dict[uuid.UUID, UnitCell]:\n    \"\"\"\n    Deserialize a JSON string back into a dictionary of `UnitCell` objects.\n\n    Parameters\n    ----------\n    json_str : str\n        JSON string representation of unit_cells dictionary\n\n    Returns\n    -------\n    dict[uuid.UUID, UnitCell]\n        Dictionary mapping UUIDs to `UnitCell` objects\n    \"\"\"\n    # Parse the JSON string with custom object hook\n    string_keyed_dict = json.loads(json_str, object_hook=decode_unit_cell_json)\n\n    # Convert string keys back to UUID keys\n    return {uuid.UUID(k): v for k, v in string_keyed_dict.items()}\n</code></pre>"},{"location":"dev/logic/#workers","title":"Workers","text":""},{"location":"dev/logic/#TiBi.logic.workers.DiagonalizationWorker","title":"<code>TiBi.logic.workers.DiagonalizationWorker</code>","text":"<p>               Bases: <code>Worker</code></p> <p>Worker for diagonalizing a Hamiltonian at multiple k-points.</p> <p>Attributes:</p> Name Type Description <code>hamiltonian_func</code> <code>callable</code> <p>Function that takes a k-point and returns the Hamiltonian matrix.</p> <code>k_points</code> <code>list</code> <p>List of k-points at which to diagonalize the Hamiltonian.</p> Source code in <code>TiBi/logic/workers/diagonalization_worker.py</code> <pre><code>class DiagonalizationWorker(Worker):\n    \"\"\"\n    Worker for diagonalizing a Hamiltonian at multiple k-points.\n\n    Attributes\n    ----------\n    hamiltonian_func : callable\n        Function that takes a k-point and returns the Hamiltonian matrix.\n    k_points : list\n        List of k-points at which to diagonalize the Hamiltonian.\n    \"\"\"\n\n    def __init__(self, hamiltonian_func, k_points):\n        super().__init__()\n        self.hamiltonian_func = hamiltonian_func\n        self.k_points = k_points\n\n    def do_work(self):\n        \"\"\"\n        Diagonalize the Hamiltonian at the specified k-points.\n\n        At the end of the computation, emit a signal with the results.\n        \"\"\"\n\n        emit_interval = max(len(self.k_points) // 100, 1)\n\n        eigenvalues = []\n        eigenvectors = []\n        self.progress_updated.emit(0)\n\n        for ii, k in enumerate(self.k_points):\n            if self._abort:\n                self.task_aborted.emit()\n                return\n\n            H = self.hamiltonian_func(k)\n            solution = np.linalg.eigh(H)\n            eigenvalues.append(solution[0])\n            eigenvectors.append(solution[1])\n\n            if ii % emit_interval == 0 or ii == len(self.k_points) - 1:\n                self.progress_updated.emit(\n                    int((ii + 1) / len(self.k_points) * 100)\n                )\n\n        self.task_finished.emit((eigenvalues, eigenvectors, self.k_points))\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.workers.DiagonalizationWorker.do_work","title":"<code>do_work()</code>","text":"<p>Diagonalize the Hamiltonian at the specified k-points.</p> <p>At the end of the computation, emit a signal with the results.</p> Source code in <code>TiBi/logic/workers/diagonalization_worker.py</code> <pre><code>def do_work(self):\n    \"\"\"\n    Diagonalize the Hamiltonian at the specified k-points.\n\n    At the end of the computation, emit a signal with the results.\n    \"\"\"\n\n    emit_interval = max(len(self.k_points) // 100, 1)\n\n    eigenvalues = []\n    eigenvectors = []\n    self.progress_updated.emit(0)\n\n    for ii, k in enumerate(self.k_points):\n        if self._abort:\n            self.task_aborted.emit()\n            return\n\n        H = self.hamiltonian_func(k)\n        solution = np.linalg.eigh(H)\n        eigenvalues.append(solution[0])\n        eigenvectors.append(solution[1])\n\n        if ii % emit_interval == 0 or ii == len(self.k_points) - 1:\n            self.progress_updated.emit(\n                int((ii + 1) / len(self.k_points) * 100)\n            )\n\n    self.task_finished.emit((eigenvalues, eigenvectors, self.k_points))\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.workers.Worker","title":"<code>TiBi.logic.workers.Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>General worker class for performing background tasks.</p> <p>Attributes:</p> Name Type Description <code>_abort</code> <code>bool</code> <p>Flag indicating whether the worker should abourt its task.</p> <code>progress_updated</code> <code>Signal</code> <p>Emitted to update the progress of the task.</p> <code>task_finished</code> <code>Signal</code> <p>Emitted when the task is completed successfully.</p> <code>task_aborted</code> <code>Signal</code> <p>Emitted when the task is aborted by the user.</p> <p>Methods:</p> Name Description <code>do_work</code> <p>Abstract method implemented by subclasses to perform the actual work.</p> <code>request_abort</code> <p>Set the abort flag to True, signaling the worker to stop its task.</p> Source code in <code>TiBi/logic/workers/worker.py</code> <pre><code>class Worker(QObject):\n    \"\"\"\n    General worker class for performing background tasks.\n\n    Attributes\n    ----------\n    _abort : bool\n        Flag indicating whether the worker should abourt its task.\n    progress_updated : Signal\n        Emitted to update the progress of the task.\n    task_finished : Signal\n        Emitted when the task is completed successfully.\n    task_aborted : Signal\n        Emitted when the task is aborted by the user.\n\n    Methods\n    -------\n    do_work() -&gt; None\n        Abstract method implemented by subclasses to perform the actual work.\n    request_abort() -&gt; None\n        Set the abort flag to True, signaling the worker to stop its task.\n    \"\"\"\n\n    progress_updated = Signal(int)\n    task_finished = Signal(object)\n    task_aborted = Signal()\n\n    def __init__(self):\n        super().__init__()\n        self._abort = False\n\n    def do_work(self):\n        raise NotImplementedError(\"Subclasses must implement do_work()\")\n\n    def request_abort(self):\n        \"\"\"\n        Set the abort flag to True, signaling the worker to stop its task.\n        \"\"\"\n        self._abort = True\n</code></pre>"},{"location":"dev/logic/#TiBi.logic.workers.Worker.request_abort","title":"<code>request_abort()</code>","text":"<p>Set the abort flag to True, signaling the worker to stop its task.</p> Source code in <code>TiBi/logic/workers/worker.py</code> <pre><code>def request_abort(self):\n    \"\"\"\n    Set the abort flag to True, signaling the worker to stop its task.\n    \"\"\"\n    self._abort = True\n</code></pre>"},{"location":"dev/models/","title":"Models","text":"<p>This page provides the documentation for the data models used by the Application, as well as relevant factories.</p>"},{"location":"dev/models/#TiBi.models.BandStructure","title":"<code>TiBi.models.BandStructure</code>  <code>dataclass</code>","text":"<p>A <code>UnitCell</code> attribute containing a system's band structure.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>list[NDArray[float64]]</code> <p>A list of point coordinates along which the bands are calculated.</p> <code>special_points</code> <code>list[NDArray[float64]]</code> <p>A list of high-symmetry point coordinates used for the path.</p> <code>eigenvalues</code> <code>list[NDArray[float64]]</code> <p>A list of arrays, where each array contains eigenvalues (energies) corresponding to each point on the path.</p> <code>eigenvectors</code> <code>list[NDArray[float64]]</code> <p>A list of square 2D arrays, where each array contains the eigenvectors corresponding to each point on the path. The eigenvectors are the columns of the 2D arrays.</p> <p>Methods:</p> Name Description <code>clear</code> <p>Reset the <code>BandStructure</code> to the initial state.</p> <code>reset_bands</code> <p>Reset the <code>BandStructure</code> by clearing the path, eigenvalues, and eigenvectors, but keeping the special points.</p> <code>add_point</code> <p>Add a point to the special points path. Reset all other fields.</p> <code>remove_point</code> <p>Remove the last point from the special points path. Reset all other fields.</p> Source code in <code>TiBi/models/band_structure.py</code> <pre><code>@dataclass\nclass BandStructure:\n    \"\"\"\n    A `UnitCell` attribute containing a system's band structure.\n\n    Attributes\n    ----------\n    path : list[NDArray[np.float64]]\n        A list of point coordinates along which the bands are calculated.\n    special_points : list[NDArray[np.float64]]\n        A list of high-symmetry point coordinates used for the path.\n    eigenvalues : list[NDArray[np.float64]]\n        A list of arrays, where each array contains eigenvalues (energies)\n        corresponding to each point on the path.\n    eigenvectors : list[NDArray[np.float64]]\n        A list of square 2D arrays, where each array contains the eigenvectors\n        corresponding to each point on the path. The\n        eigenvectors are the columns of the 2D arrays.\n\n    Methods\n    -------\n    clear()\n        Reset the `BandStructure` to the initial state.\n    reset_bands()\n        Reset the `BandStructure` by clearing the path, eigenvalues, and\n        eigenvectors, but keeping the special points.\n    add_point(point: NDArray[np.float64])\n        Add a point to the special points path. Reset all other fields.\n    remove_point()\n        Remove the last point from the special points path. Reset all other\n        fields.\n    \"\"\"\n\n    path: list[NDArray[np.float64]] = field(default_factory=list)\n    special_points: list[NDArray[np.float64]] = field(default_factory=list)\n    eigenvalues: list[NDArray[np.float64]] = field(default_factory=list)\n    eigenvectors: list[NDArray[np.float64]] = field(default_factory=list)\n\n    def clear(self):\n        \"\"\"Reset the `BandStructure` to the initial state.\"\"\"\n        self.special_points.clear()\n        self.reset_bands()\n\n    def reset_bands(self):\n        \"\"\"\n        Reset the `BandStructure` by clearing the path, eigenvalues, and\n        eigenvectors, but keeping the special points.\n        \"\"\"\n        self.path.clear()\n        self.eigenvalues.clear()\n        self.eigenvectors.clear()\n\n    def add_point(self, point: NDArray[np.float64]):\n        \"\"\"\n        Add a point to the special points path. Reset all other fields.\n\n        Parameters\n        ----------\n        point : NDArray[np.float64]\n            The point to be added to the special points path.\n        \"\"\"\n        self.reset_bands()\n        self.special_points.append(point)\n\n    def remove_point(self):\n        \"\"\"\n        Remove the last point from the special points path. Reset all other\n        fields.\n        \"\"\"\n        if self.special_points:\n            self.special_points.pop(-1)\n            self.reset_bands()\n</code></pre>"},{"location":"dev/models/#TiBi.models.BandStructure.add_point","title":"<code>add_point(point)</code>","text":"<p>Add a point to the special points path. Reset all other fields.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>NDArray[float64]</code> <p>The point to be added to the special points path.</p> required Source code in <code>TiBi/models/band_structure.py</code> <pre><code>def add_point(self, point: NDArray[np.float64]):\n    \"\"\"\n    Add a point to the special points path. Reset all other fields.\n\n    Parameters\n    ----------\n    point : NDArray[np.float64]\n        The point to be added to the special points path.\n    \"\"\"\n    self.reset_bands()\n    self.special_points.append(point)\n</code></pre>"},{"location":"dev/models/#TiBi.models.BandStructure.clear","title":"<code>clear()</code>","text":"<p>Reset the <code>BandStructure</code> to the initial state.</p> Source code in <code>TiBi/models/band_structure.py</code> <pre><code>def clear(self):\n    \"\"\"Reset the `BandStructure` to the initial state.\"\"\"\n    self.special_points.clear()\n    self.reset_bands()\n</code></pre>"},{"location":"dev/models/#TiBi.models.BandStructure.remove_point","title":"<code>remove_point()</code>","text":"<p>Remove the last point from the special points path. Reset all other fields.</p> Source code in <code>TiBi/models/band_structure.py</code> <pre><code>def remove_point(self):\n    \"\"\"\n    Remove the last point from the special points path. Reset all other\n    fields.\n    \"\"\"\n    if self.special_points:\n        self.special_points.pop(-1)\n        self.reset_bands()\n</code></pre>"},{"location":"dev/models/#TiBi.models.BandStructure.reset_bands","title":"<code>reset_bands()</code>","text":"<p>Reset the <code>BandStructure</code> by clearing the path, eigenvalues, and eigenvectors, but keeping the special points.</p> Source code in <code>TiBi/models/band_structure.py</code> <pre><code>def reset_bands(self):\n    \"\"\"\n    Reset the `BandStructure` by clearing the path, eigenvalues, and\n    eigenvectors, but keeping the special points.\n    \"\"\"\n    self.path.clear()\n    self.eigenvalues.clear()\n    self.eigenvectors.clear()\n</code></pre>"},{"location":"dev/models/#TiBi.models.BasisVector","title":"<code>TiBi.models.BasisVector</code>  <code>dataclass</code>","text":"<p>A basis vector in 3D space for a crystalline unit cell.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>x-component in Cartesian coordinates</p> <code>y</code> <code>float</code> <p>y-component in Cartesian coordinates</p> <code>z</code> <code>float</code> <p>z-component in Cartesian coordinates</p> <code>is_periodic</code> <code>bool</code> <p>Flag denoting whether the crystal repeats in this direction</p> <p>Methods:</p> Name Description <code>as_array</code> <p>Convert the <code>BasisVector</code> to a NumPy array with 3 elements.</p> Source code in <code>TiBi/models/basis_vector.py</code> <pre><code>@dataclass\nclass BasisVector:\n    \"\"\"\n    A basis vector in 3D space for a crystalline unit cell.\n\n    Attributes\n    ----------\n    x : float\n        x-component in Cartesian coordinates\n    y : float\n        y-component in Cartesian coordinates\n    z : float\n        z-component in Cartesian coordinates\n    is_periodic : bool\n        Flag denoting whether the crystal repeats in this direction\n\n    Methods\n    -------\n    as_array()\n        Convert the `BasisVector` to a NumPy array with 3 elements.\n    \"\"\"\n\n    x: float\n    y: float\n    z: float\n    is_periodic: bool = False\n\n    def as_array(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Convert the `BasisVector` to a NumPy array.\n\n        Returns\n        -------\n        NDArray[np.float64]\n            3D vector as a NumPy array [x, y, z]\n        \"\"\"\n        return np.array([self.x, self.y, self.z], dtype=np.float64)\n</code></pre>"},{"location":"dev/models/#TiBi.models.BasisVector.as_array","title":"<code>as_array()</code>","text":"<p>Convert the <code>BasisVector</code> to a NumPy array.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>3D vector as a NumPy array [x, y, z]</p> Source code in <code>TiBi/models/basis_vector.py</code> <pre><code>def as_array(self) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Convert the `BasisVector` to a NumPy array.\n\n    Returns\n    -------\n    NDArray[np.float64]\n        3D vector as a NumPy array [x, y, z]\n    \"\"\"\n    return np.array([self.x, self.y, self.z], dtype=np.float64)\n</code></pre>"},{"location":"dev/models/#TiBi.models.BrillouinZoneGrid","title":"<code>TiBi.models.BrillouinZoneGrid</code>  <code>dataclass</code>","text":"<p>A <code>UnitCell</code> attribute containing a system's computed Brillouin zone grid.</p> <p>Attributes:</p> Name Type Description <code>is_gamma_centered</code> <code>bool</code> <p>A boolean marking whether the grid is Gamma centered or Monkhorst-Pack</p> <code>grid_divs</code> <code>tuple[int, int, int]</code> <p>Number of divisions along each reciprocal basis vector</p> <code>k_points</code> <code>list[NDArray[float64]]</code> <p>The coordinates of the grid points.</p> <code>eigenvalues</code> <code>list[NDArray[float64]]</code> <p>A list of arrays, where each array contains eigenvalues (energies) corresponding to each grid point.</p> <code>eigenvectors</code> <code>list[NDArray[float64]]</code> <p>A list of square 2D arrays, where each array contains the eigenvectors corresponding to each grid point. The eigenvectors are the columns of the 2D arrays.</p> <p>Methods:</p> Name Description <code>clear</code> <p>Reset the grid to the initial state.</p> Source code in <code>TiBi/models/bz_grid.py</code> <pre><code>@dataclass\nclass BrillouinZoneGrid:\n    \"\"\"\n    A `UnitCell` attribute containing a system's computed Brillouin zone grid.\n\n    Attributes\n    ----------\n    is_gamma_centered : bool\n        A boolean marking whether the grid is Gamma centered or Monkhorst-Pack\n    grid_divs : tuple[int, int, int]\n        Number of divisions along each reciprocal basis vector\n    k_points : list[NDArray[np.float64]]\n        The coordinates of the grid points.\n    eigenvalues : list[NDArray[np.float64]]\n        A list of arrays, where each array contains eigenvalues (energies)\n        corresponding to each grid point.\n    eigenvectors : list[NDArray[np.float64]]\n        A list of square 2D arrays, where each array contains the eigenvectors\n        corresponding to each grid point. The\n        eigenvectors are the columns of the 2D arrays.\n\n    Methods\n    -------\n    clear()\n        Reset the grid to the initial state.\n    \"\"\"\n\n    is_gamma_centered: bool = True\n    grid_divs: tuple[int, int, int] = (30, 30, 30)\n    k_points: list[NDArray[np.float64]] = field(default_factory=list)\n    eigenvalues: list[NDArray[np.float64]] = field(default_factory=list)\n    eigenvectors: list[NDArray[np.float64]] = field(default_factory=list)\n\n    def clear(self):\n        \"\"\"\n        Reset the grid to the initial state.\n\n        The k points, eigenvalues, and eigenvectors are cleared,\n        while the gamma-centered flag and the grid divisions remain unchanged.\n        \"\"\"\n        self.k_points.clear()\n        self.eigenvalues.clear()\n        self.eigenvectors.clear()\n</code></pre>"},{"location":"dev/models/#TiBi.models.BrillouinZoneGrid.clear","title":"<code>clear()</code>","text":"<p>Reset the grid to the initial state.</p> <p>The k points, eigenvalues, and eigenvectors are cleared, while the gamma-centered flag and the grid divisions remain unchanged.</p> Source code in <code>TiBi/models/bz_grid.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Reset the grid to the initial state.\n\n    The k points, eigenvalues, and eigenvectors are cleared,\n    while the gamma-centered flag and the grid divisions remain unchanged.\n    \"\"\"\n    self.k_points.clear()\n    self.eigenvalues.clear()\n    self.eigenvectors.clear()\n</code></pre>"},{"location":"dev/models/#TiBi.models.Selection","title":"<code>TiBi.models.Selection</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Currently selected item.</p> <p>The item is characterized by a series of uuid.UUID's that can be viewed as a hierarchical address.</p> <p>Attributes:</p> Name Type Description <code>unit_cell</code> <code>UUID | None</code> <p>ID of the selected <code>UnitCell</code></p> <code>site</code> <code>UUID | None</code> <p>ID of the selected <code>Site</code></p> <code>state</code> <code>UUID | None</code> <p>ID of the selected <code>State</code></p> <code>unit_cell_updated</code> <code>Signal</code> <p>Emitted when a new <code>UnitCell</code> is selected.</p> <code>site_updated</code> <code>Signal</code> <p>Emitted when a new <code>Site</code> is selected.</p> <code>state_updated</code> <code>Signal</code> <p>Emitted when a new <code>State</code> is selected.</p> <code>selection_changed</code> <code>Signal</code> <p>Emitted when the selection changes, in addition to the specific signal.</p> <p>Methods:</p> Name Description <code>set_selection</code> <p>Update the selection and emit an appropriate signal.</p> Source code in <code>TiBi/models/selection.py</code> <pre><code>class Selection(QObject):\n    \"\"\"\n    Currently selected item.\n\n    The item is characterized by a series of uuid.UUID's\n    that can be viewed as a hierarchical address.\n\n    Attributes\n    ----------\n    unit_cell : uuid.UUID | None\n        ID of the selected `UnitCell`\n    site : uuid.UUID | None\n        ID of the selected `Site`\n    state : uuid.UUID | None\n        ID of the selected `State`\n    unit_cell_updated : Signal\n        Emitted when a new `UnitCell` is selected.\n    site_updated : Signal\n        Emitted when a new `Site` is selected.\n    state_updated : Signal\n        Emitted when a new `State` is selected.\n    selection_changed : Signal\n        Emitted when the selection changes, in addition\n        to the specific signal.\n\n    Methods\n    -------\n    set_selection(uc_id : uuid.UUID | None, site_id : uuid.UUID | None,\\\n          state_id : uuid.UUID | None)\n        Update the selection and emit an appropriate signal.\n    \"\"\"\n\n    unit_cell_updated = Signal()\n    site_updated = Signal()\n    state_updated = Signal()\n    selection_changed = Signal()\n\n    def __init__(self):\n        super().__init__()\n\n        self.unit_cell = None\n        self.site = None\n        self.state = None\n\n    def set_selection(self, uc_id, site_id, state_id):\n        \"\"\"\n        Update the selection and emit an appropriate signal.\n\n        Parameters\n        ----------\n        uc_id : uuid.UUID | None\n            New `UnitCell` id.\n        site_id : uuid.UUID | None\n            New `Site` id.\n        state_id : uuid.UUID | None\n            New `State` id.\n        \"\"\"\n        current_uc = self.unit_cell\n        current_site = self.site\n        current_state = self.state\n\n        self.unit_cell = uc_id\n        self.site = site_id\n        self.state = state_id\n\n        if current_uc != uc_id:\n            self.unit_cell_updated.emit()\n            self.selection_changed.emit()\n        elif current_site != site_id:\n            self.site_updated.emit()\n            self.selection_changed.emit()\n        elif current_state != state_id:\n            self.state_updated.emit()\n            self.selection_changed.emit()\n</code></pre>"},{"location":"dev/models/#TiBi.models.Selection.set_selection","title":"<code>set_selection(uc_id, site_id, state_id)</code>","text":"<p>Update the selection and emit an appropriate signal.</p> <p>Parameters:</p> Name Type Description Default <code>uc_id</code> <code>UUID | None</code> <p>New <code>UnitCell</code> id.</p> required <code>site_id</code> <code>UUID | None</code> <p>New <code>Site</code> id.</p> required <code>state_id</code> <code>UUID | None</code> <p>New <code>State</code> id.</p> required Source code in <code>TiBi/models/selection.py</code> <pre><code>def set_selection(self, uc_id, site_id, state_id):\n    \"\"\"\n    Update the selection and emit an appropriate signal.\n\n    Parameters\n    ----------\n    uc_id : uuid.UUID | None\n        New `UnitCell` id.\n    site_id : uuid.UUID | None\n        New `Site` id.\n    state_id : uuid.UUID | None\n        New `State` id.\n    \"\"\"\n    current_uc = self.unit_cell\n    current_site = self.site\n    current_state = self.state\n\n    self.unit_cell = uc_id\n    self.site = site_id\n    self.state = state_id\n\n    if current_uc != uc_id:\n        self.unit_cell_updated.emit()\n        self.selection_changed.emit()\n    elif current_site != site_id:\n        self.site_updated.emit()\n        self.selection_changed.emit()\n    elif current_state != state_id:\n        self.state_updated.emit()\n        self.selection_changed.emit()\n</code></pre>"},{"location":"dev/models/#TiBi.models.Site","title":"<code>TiBi.models.Site</code>  <code>dataclass</code>","text":"<p>A physical site (like an atom) within a <code>UnitCell</code>.</p> <p><code>Site</code>s are positioned using fractional coordinates relative to the <code>UnitCell</code>'s basis vectors, where each coordinate ranges from 0 to 1. Each <code>Site</code> can contain multiple <code>State</code>s.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the <code>Site</code> (e.g., atom name like \"C\", \"Fe\", etc.)</p> <code>c1, c2, c3</code> <code>float</code> <p>Fractional coordinates (0 \u2264 c \u2264 1) along the unit cell's <code>BasisVector</code>s</p> <code>R</code> <code>float</code> <p><code>Site</code> radius used for plotting (in arbitrary units)</p> <code>color</code> <code>tuple[float, float, float, float]</code> <p><code>Site</code> RGBA color used for plotting (0-1 range for each channel)</p> <code>states</code> <code>dict[UUID, State]</code> <p>Dictionary mapping state UUIDs to <code>State</code> objects</p> <code>id</code> <code>UUID</code> <p>Unique identifier for the <code>Site</code></p> Source code in <code>TiBi/models/site.py</code> <pre><code>@dataclass\nclass Site:\n    \"\"\"\n    A physical site (like an atom) within a `UnitCell`.\n\n    `Site`s are positioned using fractional coordinates relative to\n    the `UnitCell`'s basis vectors, where each coordinate ranges from 0 to 1.\n    Each `Site` can contain multiple `State`s.\n\n    Attributes\n    ----------\n    name : str\n        Name of the `Site` (e.g., atom name like \"C\", \"Fe\", etc.)\n    c1, c2, c3 : float\n        Fractional coordinates (0 \u2264 c \u2264 1) along the unit cell's `BasisVector`s\n    R : float\n        `Site` radius used for plotting (in arbitrary units)\n    color : tuple[float, float, float, float]\n        `Site` RGBA color used for plotting (0-1 range for each channel)\n    states : dict[uuid.UUID, State]\n        Dictionary mapping state UUIDs to `State` objects\n    id : uuid.UUID\n        Unique identifier for the `Site`\n    \"\"\"\n\n    name: str\n    c1: float\n    c2: float\n    c3: float\n    R: float\n    color: tuple[float, float, float, float]\n    states: dict[uuid.UUID, State] = field(default_factory=dict)\n    id: uuid.UUID = field(default_factory=uuid.uuid4)\n</code></pre>"},{"location":"dev/models/#TiBi.models.State","title":"<code>TiBi.models.State</code>  <code>dataclass</code>","text":"<p>A quantum state (orbital) within a <code>Site</code>.</p> <p>Each <code>State</code> has a <code>name</code> and belongs to a <code>Site</code> in the <code>UnitCell</code>. <code>State</code>s are the fundamental entities between which hopping can occur.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the <code>State</code> (e.g., \"s\", \"px\", \"py\", etc.)</p> <code>id</code> <code>UUID</code> <p>Unique identifier for the <code>State</code></p> Source code in <code>TiBi/models/state.py</code> <pre><code>@dataclass\nclass State:\n    \"\"\"\n    A quantum state (orbital) within a `Site`.\n\n    Each `State` has a `name` and belongs to a `Site` in the `UnitCell`.\n    `State`s are the fundamental entities between which hopping can occur.\n\n    Attributes\n    ----------\n    name : str\n        Name of the `State` (e.g., \"s\", \"px\", \"py\", etc.)\n    id : uuid.UUID\n        Unique identifier for the `State`\n    \"\"\"\n\n    name: str\n    id: uuid.UUID = field(default_factory=uuid.uuid4)\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell","title":"<code>TiBi.models.UnitCell</code>  <code>dataclass</code>","text":"<p>The funtamental object describing a crystal.</p> <p>The <code>UnitCell</code> is defined by three <code>BasisVector</code>s and contains <code>Site</code>s and hopping terms between <code>State</code>s. Additionally, <code>UnitCell</code> carries the calculated <code>BandStructure</code> and <code>BrillouinZoneGrid</code> objects.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the unit cell</p> <code>v1, v2, v3</code> <code>BasisVector</code> <p>Basis vectors</p> <code>sites</code> <code>dict[UUID, Site]</code> <p>Dictionary mapping site UUIDs to <code>Site</code> objects</p> <code>hoppings</code> <code>dict[tuple[UUID, UUID], list[tuple[tuple[int, int, int], complex128]]]</code> <p>Dictionary of hopping terms between states. Keys are pairs of state UUIDs (destination_state_id, source_state_id). Values are lists of (displacement, amplitude) pairs where:</p> <ul> <li>displacement is a tuple of three integers (n1,n2,n3) indicating which periodic image of the unit cell is involved (0,0,0 means within the same unit cell)</li> <li>amplitude is a complex number</li> </ul> <code>bandstructure</code> <code>BandStructure</code> <p>Band structure object for the <code>UnitCell</code></p> <code>bz_grid</code> <code>BrillouinZoneGrid</code> <p>Grid of points in the Brillouin zone</p> <code>id</code> <code>UUID</code> <p>Unique identifier for the <code>UnitCell</code></p> <p>Methods:</p> Name Description <code>volume</code> <p>Compute the volume of the <code>UnitCell</code> using the scalar triple product.</p> <code>is_hermitian</code> <p>Check whether the hoppings are Hermitian.</p> <code>reciprocal_vectors</code> <p>Compute the reciprocal lattice vectors for the periodic directions.</p> <code>reduced_basis</code> <p>Return a reduced set of periodic <code>BasisVector</code>s using LLL algorithm.</p> <code>get_states</code> <p>Extract all <code>State</code>s from a <code>UnitCell</code> along with their identifying information.</p> <code>get_BZ</code> <p>Compute the Brillouin zone vertices and faces.</p> <code>get_hamiltonian_function</code> <p>Generate a function that computes the Hamiltonian matrix for a given k-point.</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>@dataclass\nclass UnitCell:\n    \"\"\"\n    The funtamental object describing a crystal.\n\n    The `UnitCell` is defined by three `BasisVector`s and contains `Site`s\n    and hopping terms between `State`s. Additionally, `UnitCell` carries\n    the calculated `BandStructure` and `BrillouinZoneGrid` objects.\n\n    Attributes\n    ----------\n    name : str\n        Name of the unit cell\n    v1, v2, v3 : BasisVector\n        Basis vectors\n    sites : dict[uuid.UUID, Site]\n        Dictionary mapping site UUIDs to `Site` objects\n    hoppings : dict[tuple[uuid.UUID, uuid.UUID], \\\n        list[tuple[tuple[int, int, int], np.complex128]]]\n        Dictionary of hopping terms between states.\n        Keys are pairs of state UUIDs (destination_state_id,\n        source_state_id).\n        Values are lists of (displacement, amplitude) pairs where:\n\n        - displacement is a tuple of three integers (n1,n2,n3) indicating\n        which periodic image of the unit cell is involved\n        (0,0,0 means within the same unit cell)\n        - amplitude is a complex number\n    bandstructure : BandStructure\n        Band structure object for the `UnitCell`\n    bz_grid: BrillouinZoneGrid\n        Grid of points in the Brillouin zone\n    id : uuid.UUID\n        Unique identifier for the `UnitCell`\n\n    Methods\n    -------\n    volume()\n        Compute the volume of the `UnitCell` using the scalar triple\n        product.\n    is_hermitian()\n        Check whether the hoppings are Hermitian.\n    reciprocal_vectors()\n        Compute the reciprocal lattice vectors for the periodic directions.\n    reduced_basis()\n        Return a reduced set of periodic `BasisVector`s using LLL\n        algorithm.\n    get_states()\n        Extract all `State`s from a `UnitCell` along with their identifying\n        information.\n    get_BZ()\n        Compute the Brillouin zone vertices and faces.\n    get_hamiltonian_function()\n        Generate a function that computes the Hamiltonian matrix\n        for a given k-point.\n    \"\"\"\n\n    name: str\n    v1: BasisVector\n    v2: BasisVector\n    v3: BasisVector\n    sites: dict[uuid.UUID, Site] = field(default_factory=dict)\n    hoppings: dict[\n        tuple[uuid.UUID, uuid.UUID],\n        list[tuple[tuple[int, int, int], np.complex128]],\n    ] = field(default_factory=dict)\n    bandstructure: BandStructure = field(default_factory=BandStructure)\n    bz_grid: BrillouinZoneGrid = field(default_factory=BrillouinZoneGrid)\n    id: uuid.UUID = field(default_factory=uuid.uuid4)\n\n    def volume(self) -&gt; np.float64:\n        \"\"\"\n        Compute the volume of the `UnitCell` using the scalar triple product.\n\n        Returns\n        -------\n        np.float64\n            Volume of the unit cell in arbitrary units\n        \"\"\"\n        a1, a2, a3 = [v.as_array() for v in [self.v1, self.v2, self.v3]]\n        return np.abs(np.dot(a1, np.cross(a2, a3)))\n\n    def is_hermitian(self) -&gt; bool:\n        \"\"\"\n        Check whether the hoppings are Hermitian.\n\n        For each key (destination_state_id, source_state_id) in the\n        hoppings dictionary, check if there is a key\n        (source_state_id, destination_state_id). If so, check that the entries\n        are related by Hermitian conjugation.\n\n        Returns\n        -------\n        bool\n            `True` if Hermitian; `False` if not.\n        \"\"\"\n        hermitian = True\n\n        for key, val in self.hoppings.items():\n            s1 = key[0]\n            s2 = key[1]\n\n            hop = set(val)\n            hop_transpose = set(self.hoppings.get((s2, s1), []))\n\n            hop_neg_conj = set(\n                ((-d1, -d2, -d3), np.conj(x)) for ((d1, d2, d3), x) in hop\n            )\n\n            if hop_neg_conj != hop_transpose:\n                hermitian = False\n                break\n        return hermitian\n\n    def reciprocal_vectors(self) -&gt; list[NDArray[np.float64]]:\n        \"\"\"\n        Compute the reciprocal lattice vectors for the periodic directions.\n\n        Calculates the reciprocal lattice vectors corresponding to the\n        periodic directions in the `UnitCell`.\n        The number of reciprocal vectors depends on the number of\n        periodic dimensions (0-3).\n\n        Returns\n        -------\n        list[NDArray[np.float64]]\n            List of 3D reciprocal vectors (0 to 3 items depending on\n            periodicity)\n        \"\"\"\n        basis_vectors = [\n            v for v in [self.v1, self.v2, self.v3] if v.is_periodic\n        ]\n        num_periodic = len(basis_vectors)\n\n        if num_periodic == 0:\n            return []\n\n        elif num_periodic == 1:\n            a1 = basis_vectors[0].as_array()\n            g1 = 2 * np.pi * a1 / np.dot(a1, a1)\n            return [g1]\n\n        elif num_periodic == 2:\n            a1, a2 = [v.as_array() for v in basis_vectors]\n            normal = np.cross(a1, a2)\n            g1 = (\n                2\n                * np.pi\n                * np.cross(normal, a2)\n                / np.dot(a1, np.cross(a2, normal))\n            )\n            g2 = (\n                2\n                * np.pi\n                * np.cross(a1, normal)\n                / np.dot(a2, np.cross(normal, a1))\n            )\n            return [g1, g2]\n\n        elif num_periodic == 3:\n            a1, a2, a3 = [v.as_array() for v in basis_vectors]\n            volume = np.dot(a1, np.cross(a2, a3))\n            g1 = 2 * np.pi * np.cross(a2, a3) / volume\n            g2 = 2 * np.pi * np.cross(a3, a1) / volume\n            g3 = 2 * np.pi * np.cross(a1, a2) / volume\n            return [g1, g2, g3]\n\n        else:\n            raise ValueError(\"Invalid number of periodic vectors.\")\n\n    def reduced_basis(self, scale: float = 1e6) -&gt; list[BasisVector]:\n        \"\"\"\n        Return a reduced set of periodic `BasisVector`s using LLL algorithm.\n\n        Applies the Lenstra-Lenstra-Lov\u00e1sz (LLL) lattice reduction algorithm\n        to find a more orthogonal set of basis vectors that spans the same\n        lattice.\n\n        Only the periodic `BasisVector`s are reduced.\n        Non-periodic vectors are left unchanged.\n\n        Parameters\n        ----------\n        scale : float = 1e6\n            A float to scale the vectors for integer reduction.\n            Used because the LLL algorithm works with integer matrices.\n\n        Returns\n        -------\n        list[BasisVector]\n            A list of BasisVector objects representing the reduced basis\n        \"\"\"\n        vs = [self.v1, self.v2, self.v3]\n        # Determine which vectors are periodic\n        periodic_flags = [v.is_periodic for v in vs]\n        # Extract the periodic vectors. Scale them to be used in reduction\n        periodic_vectors = [\n            np.round(scale * vs[ii].as_array()).astype(int)\n            for ii in range(3)\n            if periodic_flags[ii]\n        ]\n\n        # If there are fewer than 2 periodic vectors,\n        # LLL reduction isn't meaningful\n        if len(periodic_vectors) &lt; 2:\n            return vs  # Return unchanged\n\n        # Reduced vectors\n        reduced = DM(periodic_vectors, ZZ).lll().to_list()\n        # Rebuild full list with reduced periodic vectors in original order\n        reduced_basis = []\n        # Rescale\n        reduced_vectors = [\n            np.array(vec, dtype=float) / scale for vec in reduced\n        ]\n\n        jj = 0  # Index for reduced_vectors\n        for ii in range(3):\n            if periodic_flags[ii]:\n                vec = reduced_vectors[jj]\n                reduced_basis.append(BasisVector(*vec, is_periodic=True))\n                jj += 1\n            else:\n                reduced_basis.append(vs[ii])  # Unchanged\n        return reduced_basis\n\n    def get_states(self):\n        \"\"\"\n        Extract all `State`s and their information from a `UnitCell` .\n\n        This is a helper function used by UI components to get a flattened\n        list of all states in the unit cell, regardless of which site they\n        belong to. It makes it easier to display states in UI components\n        like dropdown menus or lists.\n\n        Returns\n        -------\n        tuple[list[State], list[tuple[str, uuid.UUID, str, uuid.UUID]]]\n            A tuple containing a list of `State` objects and a list of\n            tuples (site_name, site_id, state_name, state_id)\n            providing context for each state (which site it belongs to).\n        \"\"\"\n        states = []\n        state_info = []\n        for site_id, site in self.sites.items():\n            for state_id, state in site.states.items():\n                states.append(state)\n                state_info.append((site.name, site_id, state.name, state_id))\n        return (states, state_info)\n\n    def get_BZ(self):\n        \"\"\"\n        Compute the Brillouin zone vertices and faces.\n\n        The Brillouin zone is the Wigner-Seitz cell of the reciprocal lattice.\n        This method calculates the vertices and faces of the Brillouin zone\n        using Voronoi construction. The dimensionality of the BZ depends on\n        the number of periodic dimensions in the unit cell (0-3).\n\n        For 1D, bz_vertices contains two points defining the BZ boundary.\n        For 2D, bz_faces contains the edges of the 2D BZ polygon.\n        For 3D, bz_faces contains the polygonal faces of the 3D BZ polyhedron.\n\n        Returns\n        -------\n        tuple[NDArray[NDArray[np.float64]],\\\n            NDArray[NDArray[NDArray[np.float64]]]]\n            The first element of the tuple gives the BZ vertex coordinates.\n            The second element gives a list of faces, where each face is\n            defined by vertex points. In 2D, the \"faces\" are edges.\n        \"\"\"\n        n_neighbors = (\n            1  # Number of neighboring reciprocal lattice points to consider\n        )\n        ranges = range(-n_neighbors, n_neighbors + 1)\n\n        reciprocal_vectors = self.reciprocal_vectors()\n        dim = len(reciprocal_vectors)\n\n        if dim == 0:\n            bz_vertices = np.array([])\n            bz_faces = np.array([])\n\n        elif dim == 1:\n            g1 = reciprocal_vectors[0]\n            bz_vertices = np.array([[g1[0] / 2], [-g1[0] / 2]])\n            bz_faces = np.array([])\n\n        else:\n\n            if dim == 2:\n                g1 = reciprocal_vectors[0][0:2]\n                g2 = reciprocal_vectors[1][0:2]\n                points = [\n                    ii * g1 + jj * g2\n                    for ii, jj in itertools.product(ranges, ranges)\n                    if (ii != 0 or jj != 0)\n                ]\n                all_points = np.vstack([np.zeros(2), points])\n            else:\n                g1 = reciprocal_vectors[0]\n                g2 = reciprocal_vectors[1]\n                g3 = reciprocal_vectors[2]\n                points = [\n                    ii * g1 + jj * g2 + kk * g3\n                    for ii, jj, kk in itertools.product(ranges, ranges, ranges)\n                    if (ii != 0 or jj != 0 or kk != 0)\n                ]\n                all_points = np.vstack([np.zeros(3), points])\n\n            vor = Voronoi(all_points)\n\n            # Start by getting the vertices of the Brillouin zone\n            # The first Brillouin zone is the Voronoi cell around\n            # the origin (index 0)\n            origin_region = vor.point_region[\n                0\n            ]  # Tells which Voronoi cell corresponds to origin point\n            vertex_indices = vor.regions[\n                origin_region\n            ]  # Tells which vertices defining Voronoi cell bound the region\n\n            # Extract vertices\n            bz_vertices = vor.vertices[\n                vertex_indices\n            ]  # Get the coordinates of the vertices\n\n            # Next, get a list of lists that defines the faces of the BZ\n            bz_faces = []\n            # ridge_points is a list of tuples corresponding to\n            # pairs of elements of all_points that are separated by\n            # a Voronoi boundary\n            for num, p in enumerate(vor.ridge_points):\n                # If one of the elements in the pair is the origin (index 0),\n                # this ridge separates the BZ from its neighbors\n                if p[0] == 0 or p[1] == 0:\n                    # ridge_vertices[num] contains the indices of the vertices\n                    # bounding the ridge\n                    ridge_vertices = vor.ridge_vertices[num]\n                    # finally, get the coordinates of the ridge vertices from\n                    # their indices\n                    face = vor.vertices[ridge_vertices]\n                    bz_faces.append(face)\n            bz_faces = np.array(bz_faces)\n        return bz_vertices, bz_faces\n\n    def get_hamiltonian_function(self):\n        \"\"\"\n        Generate a function that computes the Hamiltonian matrix.\n\n        This method creates a closure that precomputes all k-independent\n        data needed for the Hamiltonian, and returns a function that builds\n        the Hamiltonian matrix for any k-point in the Brillouin zone.\n\n        The dimension of the k-point must match the number of periodic\n        dimensions in the unit cell (1D, 2D, or 3D).\n\n        Returns\n        -------\n        function\n            A function that takes k-points (numpy array) and returns a\n            complex Hamiltonian matrix.\n        \"\"\"\n        # Get the list of all states in the unit cell for\n        # determining the Hamiltonian size\n        states, state_info = self.get_states()\n\n        # Get the reciprocal lattice vectors\n        reciprocal_vectors = self.reciprocal_vectors()\n        num_periodic = len(reciprocal_vectors)\n\n        # Create a mapping from state IDs to indices in the Hamiltonian matrix\n        # state_id identifies the state, idx is its index in the Hamiltonian\n        # matrix (to keep track of rows/columns)\n        state_to_idx = {\n            state_id: idx for idx, (_, _, _, state_id) in enumerate(state_info)\n        }\n\n        # Store the total number of states for matrix size\n        n_states = len(states)\n        # Basis vectors as arrays\n        v1 = self.v1.as_array() if self.v1.is_periodic else np.zeros(3)\n        v2 = self.v2.as_array() if self.v2.is_periodic else np.zeros(3)\n        v3 = self.v3.as_array() if self.v3.is_periodic else np.zeros(3)\n\n        # Define the Hamiltonian function that will be returned\n        def hamiltonian(k):\n            \"\"\"\n            Compute the Hamiltonian matrix for a given k-point.\n\n            This function constructs the Hamiltonian matrix in k-space\n            according to the tight-binding model defined by the `UnitCell`\n            and its hopping parameters.\n            The matrix elements include phase factors exp(-i k\u00b7R) for hoppings\n            between different unit cells, as required by Bloch's theorem.\n\n            Parameters\n            ----------\n            k : NDArray[np.float64]\n                k-point vector in the basis of reciprocal lattice vectors\n                If the system has n periodic directions, k should be an\n                n-dimensional vector\n\n            Returns\n            -------\n            NDArray[np.float64]\n                Complex Hamiltonian matrix of size (n_states, n_states)\n            \"\"\"\n            # Validate the k-point dimension matches the number of\n            # periodic directions\n            if len(k) != num_periodic:\n                raise ValueError(\"Momentum does not match system periodicity\")\n\n            # Initialize the Hamiltonian matrix with zeros\n            H = np.zeros((n_states, n_states), dtype=np.complex128)\n\n            # Fill the Hamiltonian matrix\n            for (dest_id, source_id), hoppings in self.hoppings.items():\n                dest_idx = state_to_idx[dest_id]  # Destination state index\n                source_idx = state_to_idx[source_id]  # Source state index\n\n                for displacement, amplitude in hoppings:\n                    d1, d2, d3 = displacement\n\n                    # Calculate the real-space displacement vector\n                    # This is the sum of the periodic vectors scaled by\n                    # the displacement\n                    R = d1 * v1 + d2 * v2 + d3 * v3\n\n                    # Apply Bloch phase factor: exp(-i k\u00b7R)\n                    if num_periodic == 0:\n                        phase = 1.0\n                    else:\n                        phase = np.exp(1j * np.dot(k, R[0:num_periodic]))\n\n                    # Add the term to the Hamiltonian\n                    H[dest_idx, source_idx] += amplitude * phase\n\n            return H\n\n        return hamiltonian\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.get_BZ","title":"<code>get_BZ()</code>","text":"<p>Compute the Brillouin zone vertices and faces.</p> <p>The Brillouin zone is the Wigner-Seitz cell of the reciprocal lattice. This method calculates the vertices and faces of the Brillouin zone using Voronoi construction. The dimensionality of the BZ depends on the number of periodic dimensions in the unit cell (0-3).</p> <p>For 1D, bz_vertices contains two points defining the BZ boundary. For 2D, bz_faces contains the edges of the 2D BZ polygon. For 3D, bz_faces contains the polygonal faces of the 3D BZ polyhedron.</p> <p>Returns:</p> Type Description <code>tuple[NDArray[NDArray[float64]], NDArray[NDArray[NDArray[float64]]]]</code> <p>The first element of the tuple gives the BZ vertex coordinates. The second element gives a list of faces, where each face is defined by vertex points. In 2D, the \"faces\" are edges.</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def get_BZ(self):\n    \"\"\"\n    Compute the Brillouin zone vertices and faces.\n\n    The Brillouin zone is the Wigner-Seitz cell of the reciprocal lattice.\n    This method calculates the vertices and faces of the Brillouin zone\n    using Voronoi construction. The dimensionality of the BZ depends on\n    the number of periodic dimensions in the unit cell (0-3).\n\n    For 1D, bz_vertices contains two points defining the BZ boundary.\n    For 2D, bz_faces contains the edges of the 2D BZ polygon.\n    For 3D, bz_faces contains the polygonal faces of the 3D BZ polyhedron.\n\n    Returns\n    -------\n    tuple[NDArray[NDArray[np.float64]],\\\n        NDArray[NDArray[NDArray[np.float64]]]]\n        The first element of the tuple gives the BZ vertex coordinates.\n        The second element gives a list of faces, where each face is\n        defined by vertex points. In 2D, the \"faces\" are edges.\n    \"\"\"\n    n_neighbors = (\n        1  # Number of neighboring reciprocal lattice points to consider\n    )\n    ranges = range(-n_neighbors, n_neighbors + 1)\n\n    reciprocal_vectors = self.reciprocal_vectors()\n    dim = len(reciprocal_vectors)\n\n    if dim == 0:\n        bz_vertices = np.array([])\n        bz_faces = np.array([])\n\n    elif dim == 1:\n        g1 = reciprocal_vectors[0]\n        bz_vertices = np.array([[g1[0] / 2], [-g1[0] / 2]])\n        bz_faces = np.array([])\n\n    else:\n\n        if dim == 2:\n            g1 = reciprocal_vectors[0][0:2]\n            g2 = reciprocal_vectors[1][0:2]\n            points = [\n                ii * g1 + jj * g2\n                for ii, jj in itertools.product(ranges, ranges)\n                if (ii != 0 or jj != 0)\n            ]\n            all_points = np.vstack([np.zeros(2), points])\n        else:\n            g1 = reciprocal_vectors[0]\n            g2 = reciprocal_vectors[1]\n            g3 = reciprocal_vectors[2]\n            points = [\n                ii * g1 + jj * g2 + kk * g3\n                for ii, jj, kk in itertools.product(ranges, ranges, ranges)\n                if (ii != 0 or jj != 0 or kk != 0)\n            ]\n            all_points = np.vstack([np.zeros(3), points])\n\n        vor = Voronoi(all_points)\n\n        # Start by getting the vertices of the Brillouin zone\n        # The first Brillouin zone is the Voronoi cell around\n        # the origin (index 0)\n        origin_region = vor.point_region[\n            0\n        ]  # Tells which Voronoi cell corresponds to origin point\n        vertex_indices = vor.regions[\n            origin_region\n        ]  # Tells which vertices defining Voronoi cell bound the region\n\n        # Extract vertices\n        bz_vertices = vor.vertices[\n            vertex_indices\n        ]  # Get the coordinates of the vertices\n\n        # Next, get a list of lists that defines the faces of the BZ\n        bz_faces = []\n        # ridge_points is a list of tuples corresponding to\n        # pairs of elements of all_points that are separated by\n        # a Voronoi boundary\n        for num, p in enumerate(vor.ridge_points):\n            # If one of the elements in the pair is the origin (index 0),\n            # this ridge separates the BZ from its neighbors\n            if p[0] == 0 or p[1] == 0:\n                # ridge_vertices[num] contains the indices of the vertices\n                # bounding the ridge\n                ridge_vertices = vor.ridge_vertices[num]\n                # finally, get the coordinates of the ridge vertices from\n                # their indices\n                face = vor.vertices[ridge_vertices]\n                bz_faces.append(face)\n        bz_faces = np.array(bz_faces)\n    return bz_vertices, bz_faces\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.get_hamiltonian_function","title":"<code>get_hamiltonian_function()</code>","text":"<p>Generate a function that computes the Hamiltonian matrix.</p> <p>This method creates a closure that precomputes all k-independent data needed for the Hamiltonian, and returns a function that builds the Hamiltonian matrix for any k-point in the Brillouin zone.</p> <p>The dimension of the k-point must match the number of periodic dimensions in the unit cell (1D, 2D, or 3D).</p> <p>Returns:</p> Type Description <code>function</code> <p>A function that takes k-points (numpy array) and returns a complex Hamiltonian matrix.</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def get_hamiltonian_function(self):\n    \"\"\"\n    Generate a function that computes the Hamiltonian matrix.\n\n    This method creates a closure that precomputes all k-independent\n    data needed for the Hamiltonian, and returns a function that builds\n    the Hamiltonian matrix for any k-point in the Brillouin zone.\n\n    The dimension of the k-point must match the number of periodic\n    dimensions in the unit cell (1D, 2D, or 3D).\n\n    Returns\n    -------\n    function\n        A function that takes k-points (numpy array) and returns a\n        complex Hamiltonian matrix.\n    \"\"\"\n    # Get the list of all states in the unit cell for\n    # determining the Hamiltonian size\n    states, state_info = self.get_states()\n\n    # Get the reciprocal lattice vectors\n    reciprocal_vectors = self.reciprocal_vectors()\n    num_periodic = len(reciprocal_vectors)\n\n    # Create a mapping from state IDs to indices in the Hamiltonian matrix\n    # state_id identifies the state, idx is its index in the Hamiltonian\n    # matrix (to keep track of rows/columns)\n    state_to_idx = {\n        state_id: idx for idx, (_, _, _, state_id) in enumerate(state_info)\n    }\n\n    # Store the total number of states for matrix size\n    n_states = len(states)\n    # Basis vectors as arrays\n    v1 = self.v1.as_array() if self.v1.is_periodic else np.zeros(3)\n    v2 = self.v2.as_array() if self.v2.is_periodic else np.zeros(3)\n    v3 = self.v3.as_array() if self.v3.is_periodic else np.zeros(3)\n\n    # Define the Hamiltonian function that will be returned\n    def hamiltonian(k):\n        \"\"\"\n        Compute the Hamiltonian matrix for a given k-point.\n\n        This function constructs the Hamiltonian matrix in k-space\n        according to the tight-binding model defined by the `UnitCell`\n        and its hopping parameters.\n        The matrix elements include phase factors exp(-i k\u00b7R) for hoppings\n        between different unit cells, as required by Bloch's theorem.\n\n        Parameters\n        ----------\n        k : NDArray[np.float64]\n            k-point vector in the basis of reciprocal lattice vectors\n            If the system has n periodic directions, k should be an\n            n-dimensional vector\n\n        Returns\n        -------\n        NDArray[np.float64]\n            Complex Hamiltonian matrix of size (n_states, n_states)\n        \"\"\"\n        # Validate the k-point dimension matches the number of\n        # periodic directions\n        if len(k) != num_periodic:\n            raise ValueError(\"Momentum does not match system periodicity\")\n\n        # Initialize the Hamiltonian matrix with zeros\n        H = np.zeros((n_states, n_states), dtype=np.complex128)\n\n        # Fill the Hamiltonian matrix\n        for (dest_id, source_id), hoppings in self.hoppings.items():\n            dest_idx = state_to_idx[dest_id]  # Destination state index\n            source_idx = state_to_idx[source_id]  # Source state index\n\n            for displacement, amplitude in hoppings:\n                d1, d2, d3 = displacement\n\n                # Calculate the real-space displacement vector\n                # This is the sum of the periodic vectors scaled by\n                # the displacement\n                R = d1 * v1 + d2 * v2 + d3 * v3\n\n                # Apply Bloch phase factor: exp(-i k\u00b7R)\n                if num_periodic == 0:\n                    phase = 1.0\n                else:\n                    phase = np.exp(1j * np.dot(k, R[0:num_periodic]))\n\n                # Add the term to the Hamiltonian\n                H[dest_idx, source_idx] += amplitude * phase\n\n        return H\n\n    return hamiltonian\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.get_states","title":"<code>get_states()</code>","text":"<p>Extract all <code>State</code>s and their information from a <code>UnitCell</code> .</p> <p>This is a helper function used by UI components to get a flattened list of all states in the unit cell, regardless of which site they belong to. It makes it easier to display states in UI components like dropdown menus or lists.</p> <p>Returns:</p> Type Description <code>tuple[list[State], list[tuple[str, UUID, str, UUID]]]</code> <p>A tuple containing a list of <code>State</code> objects and a list of tuples (site_name, site_id, state_name, state_id) providing context for each state (which site it belongs to).</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def get_states(self):\n    \"\"\"\n    Extract all `State`s and their information from a `UnitCell` .\n\n    This is a helper function used by UI components to get a flattened\n    list of all states in the unit cell, regardless of which site they\n    belong to. It makes it easier to display states in UI components\n    like dropdown menus or lists.\n\n    Returns\n    -------\n    tuple[list[State], list[tuple[str, uuid.UUID, str, uuid.UUID]]]\n        A tuple containing a list of `State` objects and a list of\n        tuples (site_name, site_id, state_name, state_id)\n        providing context for each state (which site it belongs to).\n    \"\"\"\n    states = []\n    state_info = []\n    for site_id, site in self.sites.items():\n        for state_id, state in site.states.items():\n            states.append(state)\n            state_info.append((site.name, site_id, state.name, state_id))\n    return (states, state_info)\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.is_hermitian","title":"<code>is_hermitian()</code>","text":"<p>Check whether the hoppings are Hermitian.</p> <p>For each key (destination_state_id, source_state_id) in the hoppings dictionary, check if there is a key (source_state_id, destination_state_id). If so, check that the entries are related by Hermitian conjugation.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if Hermitian; <code>False</code> if not.</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def is_hermitian(self) -&gt; bool:\n    \"\"\"\n    Check whether the hoppings are Hermitian.\n\n    For each key (destination_state_id, source_state_id) in the\n    hoppings dictionary, check if there is a key\n    (source_state_id, destination_state_id). If so, check that the entries\n    are related by Hermitian conjugation.\n\n    Returns\n    -------\n    bool\n        `True` if Hermitian; `False` if not.\n    \"\"\"\n    hermitian = True\n\n    for key, val in self.hoppings.items():\n        s1 = key[0]\n        s2 = key[1]\n\n        hop = set(val)\n        hop_transpose = set(self.hoppings.get((s2, s1), []))\n\n        hop_neg_conj = set(\n            ((-d1, -d2, -d3), np.conj(x)) for ((d1, d2, d3), x) in hop\n        )\n\n        if hop_neg_conj != hop_transpose:\n            hermitian = False\n            break\n    return hermitian\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.reciprocal_vectors","title":"<code>reciprocal_vectors()</code>","text":"<p>Compute the reciprocal lattice vectors for the periodic directions.</p> <p>Calculates the reciprocal lattice vectors corresponding to the periodic directions in the <code>UnitCell</code>. The number of reciprocal vectors depends on the number of periodic dimensions (0-3).</p> <p>Returns:</p> Type Description <code>list[NDArray[float64]]</code> <p>List of 3D reciprocal vectors (0 to 3 items depending on periodicity)</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def reciprocal_vectors(self) -&gt; list[NDArray[np.float64]]:\n    \"\"\"\n    Compute the reciprocal lattice vectors for the periodic directions.\n\n    Calculates the reciprocal lattice vectors corresponding to the\n    periodic directions in the `UnitCell`.\n    The number of reciprocal vectors depends on the number of\n    periodic dimensions (0-3).\n\n    Returns\n    -------\n    list[NDArray[np.float64]]\n        List of 3D reciprocal vectors (0 to 3 items depending on\n        periodicity)\n    \"\"\"\n    basis_vectors = [\n        v for v in [self.v1, self.v2, self.v3] if v.is_periodic\n    ]\n    num_periodic = len(basis_vectors)\n\n    if num_periodic == 0:\n        return []\n\n    elif num_periodic == 1:\n        a1 = basis_vectors[0].as_array()\n        g1 = 2 * np.pi * a1 / np.dot(a1, a1)\n        return [g1]\n\n    elif num_periodic == 2:\n        a1, a2 = [v.as_array() for v in basis_vectors]\n        normal = np.cross(a1, a2)\n        g1 = (\n            2\n            * np.pi\n            * np.cross(normal, a2)\n            / np.dot(a1, np.cross(a2, normal))\n        )\n        g2 = (\n            2\n            * np.pi\n            * np.cross(a1, normal)\n            / np.dot(a2, np.cross(normal, a1))\n        )\n        return [g1, g2]\n\n    elif num_periodic == 3:\n        a1, a2, a3 = [v.as_array() for v in basis_vectors]\n        volume = np.dot(a1, np.cross(a2, a3))\n        g1 = 2 * np.pi * np.cross(a2, a3) / volume\n        g2 = 2 * np.pi * np.cross(a3, a1) / volume\n        g3 = 2 * np.pi * np.cross(a1, a2) / volume\n        return [g1, g2, g3]\n\n    else:\n        raise ValueError(\"Invalid number of periodic vectors.\")\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.reduced_basis","title":"<code>reduced_basis(scale=1000000.0)</code>","text":"<p>Return a reduced set of periodic <code>BasisVector</code>s using LLL algorithm.</p> <p>Applies the Lenstra-Lenstra-Lov\u00e1sz (LLL) lattice reduction algorithm to find a more orthogonal set of basis vectors that spans the same lattice.</p> <p>Only the periodic <code>BasisVector</code>s are reduced. Non-periodic vectors are left unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float = 1e6</code> <p>A float to scale the vectors for integer reduction. Used because the LLL algorithm works with integer matrices.</p> <code>1000000.0</code> <p>Returns:</p> Type Description <code>list[BasisVector]</code> <p>A list of BasisVector objects representing the reduced basis</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def reduced_basis(self, scale: float = 1e6) -&gt; list[BasisVector]:\n    \"\"\"\n    Return a reduced set of periodic `BasisVector`s using LLL algorithm.\n\n    Applies the Lenstra-Lenstra-Lov\u00e1sz (LLL) lattice reduction algorithm\n    to find a more orthogonal set of basis vectors that spans the same\n    lattice.\n\n    Only the periodic `BasisVector`s are reduced.\n    Non-periodic vectors are left unchanged.\n\n    Parameters\n    ----------\n    scale : float = 1e6\n        A float to scale the vectors for integer reduction.\n        Used because the LLL algorithm works with integer matrices.\n\n    Returns\n    -------\n    list[BasisVector]\n        A list of BasisVector objects representing the reduced basis\n    \"\"\"\n    vs = [self.v1, self.v2, self.v3]\n    # Determine which vectors are periodic\n    periodic_flags = [v.is_periodic for v in vs]\n    # Extract the periodic vectors. Scale them to be used in reduction\n    periodic_vectors = [\n        np.round(scale * vs[ii].as_array()).astype(int)\n        for ii in range(3)\n        if periodic_flags[ii]\n    ]\n\n    # If there are fewer than 2 periodic vectors,\n    # LLL reduction isn't meaningful\n    if len(periodic_vectors) &lt; 2:\n        return vs  # Return unchanged\n\n    # Reduced vectors\n    reduced = DM(periodic_vectors, ZZ).lll().to_list()\n    # Rebuild full list with reduced periodic vectors in original order\n    reduced_basis = []\n    # Rescale\n    reduced_vectors = [\n        np.array(vec, dtype=float) / scale for vec in reduced\n    ]\n\n    jj = 0  # Index for reduced_vectors\n    for ii in range(3):\n        if periodic_flags[ii]:\n            vec = reduced_vectors[jj]\n            reduced_basis.append(BasisVector(*vec, is_periodic=True))\n            jj += 1\n        else:\n            reduced_basis.append(vs[ii])  # Unchanged\n    return reduced_basis\n</code></pre>"},{"location":"dev/models/#TiBi.models.UnitCell.volume","title":"<code>volume()</code>","text":"<p>Compute the volume of the <code>UnitCell</code> using the scalar triple product.</p> <p>Returns:</p> Type Description <code>float64</code> <p>Volume of the unit cell in arbitrary units</p> Source code in <code>TiBi/models/unit_cell.py</code> <pre><code>def volume(self) -&gt; np.float64:\n    \"\"\"\n    Compute the volume of the `UnitCell` using the scalar triple product.\n\n    Returns\n    -------\n    np.float64\n        Volume of the unit cell in arbitrary units\n    \"\"\"\n    a1, a2, a3 = [v.as_array() for v in [self.v1, self.v2, self.v3]]\n    return np.abs(np.dot(a1, np.cross(a2, a3)))\n</code></pre>"},{"location":"dev/models/#TiBi.models.factories.bz_point_selection_init","title":"<code>TiBi.models.factories.bz_point_selection_init()</code>","text":"<p>Initialize the selection dictonary for points in the Brillouin zone.</p> <p>Each key corresponds to a point type (vertex, edge, face), while the entries give the cardinal indices of the selected points.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys 'vertex', 'edge', and 'face', each initialized to None. During use, the entries are set to the indices of the selected points.</p> Source code in <code>TiBi/models/factories.py</code> <pre><code>def bz_point_selection_init():\n    \"\"\"\n    Initialize the selection dictonary for points in the Brillouin zone.\n\n    Each key corresponds to a point type (vertex, edge, face), while\n    the entries give the cardinal indices of the selected points.\n\n    Returns\n    -------\n    dict\n        A dictionary with keys 'vertex', 'edge', and 'face', each initialized\n        to None. During use, the entries are set to the indices\n        of the selected points.\n    \"\"\"\n    return {\n        \"vertex\": None,\n        \"edge\": None,\n        \"face\": None,\n    }  # Indices of the selected high-symmetry points in the BZ\n</code></pre>"},{"location":"dev/models/#TiBi.models.factories.bz_point_lists_init","title":"<code>TiBi.models.factories.bz_point_lists_init()</code>","text":"<p>Initialize the dictonary of points in the Brillouin zone.</p> <p>Each key corresponds to a point type (vertex, edge, face), while the entries are lists of high-symmetry points in the Brillouin zone.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys 'vertex', 'edge', and 'face', each initialized to empty lists. During use, the entries are set to the lists of of the high-symmetry points.</p> Source code in <code>TiBi/models/factories.py</code> <pre><code>def bz_point_lists_init():\n    \"\"\"\n    Initialize the dictonary of points in the Brillouin zone.\n\n    Each key corresponds to a point type (vertex, edge, face), while\n    the entries are lists of high-symmetry points in the Brillouin zone.\n\n    Returns\n    -------\n    dict\n        A dictionary with keys 'vertex', 'edge', and 'face', each initialized\n        to empty lists. During use, the entries are set to the lists of\n        of the high-symmetry points.\n    \"\"\"\n    return {\n        \"vertex\": [],\n        \"edge\": [],\n        \"face\": [],\n    }  # Lists of the high-symmetry points in the BZ, grouped by type\n</code></pre>"},{"location":"dev/models/#TiBi.models.factories.mk_new_site","title":"<code>TiBi.models.factories.mk_new_site()</code>","text":"<p>Create a new site with default values.</p> <p>Returns:</p> Type Description <code>Site</code> <p>A new <code>Site</code> object with default values.</p> Source code in <code>TiBi/models/factories.py</code> <pre><code>def mk_new_site():\n    \"\"\"\n    Create a new site with default values.\n\n    Returns\n    -------\n    Site\n        A new `Site` object with default values.\n    \"\"\"\n    name = \"New Site\"\n    c1 = 0  # Fractional coordinate along first basis vector\n    c2 = 0  # Fractional coordinate along second basis vector\n    c3 = 0  # Fractional coordinate along third basis vector\n    R = DEFAULT_SITE_SIZE\n    color = (\n        random.uniform(0, 1),\n        random.uniform(0, 1),\n        random.uniform(0, 1),\n        1.0,\n    )\n    return Site(name, c1, c2, c3, R, color)\n</code></pre>"},{"location":"dev/models/#TiBi.models.factories.mk_new_state","title":"<code>TiBi.models.factories.mk_new_state()</code>","text":"<p>Create a new state with default values.</p> <p>Returns:</p> Type Description <code>State</code> <p>A new <code>State</code> object with default values.</p> Source code in <code>TiBi/models/factories.py</code> <pre><code>def mk_new_state():\n    \"\"\"\n    Create a new state with default values.\n\n    Returns\n    -------\n    State\n        A new `State` object with default values.\n    \"\"\"\n    name = \"New State\"\n    return State(name)\n</code></pre>"},{"location":"dev/models/#TiBi.models.factories.mk_new_unit_cell","title":"<code>TiBi.models.factories.mk_new_unit_cell()</code>","text":"<p>Create a new unit cell with default values.</p> <p>Returns:</p> Type Description <code>UnitCell</code> <p>A new <code>UnitCell</code> object with default values.</p> Source code in <code>TiBi/models/factories.py</code> <pre><code>def mk_new_unit_cell():\n    \"\"\"\n    Create a new unit cell with default values.\n\n    Returns\n    -------\n    UnitCell\n        A new `UnitCell` object with default values.\n    \"\"\"\n    name = \"New Unit Cell\"\n    v1 = BasisVector(1, 0, 0)  # Unit vector along x-axis\n    v2 = BasisVector(0, 1, 0)  # Unit vector along y-axis\n    v3 = BasisVector(0, 0, 1)  # Unit vector along z-axis\n\n    return UnitCell(name, v1, v2, v3)\n</code></pre>"},{"location":"dev/ui/","title":"UI","text":"<p>This page provides the documentation for the logical UI components.</p>"},{"location":"dev/ui/#TiBi.ui.actions.ActionManager","title":"<code>TiBi.ui.actions.ActionManager</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Central manager for application actions.</p> <p>This class manages the creation and organization of all application actions, allowing them to be shared between menu bars, toolbars, context menus, and keyboard shortcuts.</p> <p>Attributes:</p> Name Type Description <code>undo_stack</code> <code>QUndoStack</code> <p>Application-wide undo stack</p> <code>file_actions</code> <code>dict[str, QAction]</code> <p>Actions pertinent to new project reset, saving, and loading</p> <code>undo_redo_actions</code> <code>dict[str, QAction]</code> <p>Undo and Redo actions</p> <code>unit_cell_actions</code> <code>dict[str, QAction]</code> <p>Actions to control the unit cell visualization (toggling the unit cell wireframe on/off)</p> Source code in <code>TiBi/ui/actions/action_manager.py</code> <pre><code>class ActionManager(QObject):\n    \"\"\"\n    Central manager for application actions.\n\n    This class manages the creation and organization of all application\n    actions, allowing them to be shared between menu bars, toolbars,\n    context menus, and keyboard shortcuts.\n\n    Attributes\n    ----------\n    undo_stack : QUndoStack\n        Application-wide undo stack\n    file_actions : dict[str, QAction]\n        Actions pertinent to new project reset, saving, and loading\n    undo_redo_actions : dict[str, QAction]\n        Undo and Redo actions\n    unit_cell_actions : dict[str, QAction]\n        Actions to control the unit cell visualization\n        (toggling the unit cell wireframe on/off)\n    \"\"\"\n\n    def __init__(self, undo_stack: QUndoStack, parent=None):\n\n        super().__init__(parent)\n        self.undo_stack = undo_stack\n        # Initialize action dictionaries for different categories\n        self.file_actions: dict[str, QAction] = {}\n        self.undo_redo_actions: dict[str, QAction] = {}\n        # self.view_actions: dict[str, QAction] = {}\n        # self.computation_actions: dict[str, QAction] = {}\n        # self.help_actions: dict[str, QAction] = {}\n        self.unit_cell_actions: dict[str, QAction] = {}\n\n        # Create all actions\n        self._create_file_actions()\n        self._create_undo_redo_actions()\n        self._create_unit_cell_actions()\n\n    def _create_file_actions(self):\n        \"\"\"Create actions related to file operations.\"\"\"\n        # New Unit Cell action\n        self.file_actions[\"new_project\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/file.svg\")),\n            \"New Project\",\n            self,\n        )\n        self.file_actions[\"new_project\"].setStatusTip(\"Create a new project\")\n\n        # Save Project action\n        self.file_actions[\"save_project\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/save.svg\")),\n            \"Save Project\",\n            self,\n        )\n        self.file_actions[\"save_project\"].setStatusTip(\n            \"Save the current project\"\n        )\n\n        # Save As action\n        self.file_actions[\"save_project_as\"] = QAction(\n            \"Save Project As...\", self\n        )\n        self.file_actions[\"save_project_as\"].setStatusTip(\n            \"Save the current project to a new file\"\n        )\n\n        # Open Project action\n        self.file_actions[\"open_project\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/open.svg\")),\n            \"Open Project...\",\n            self,\n        )\n        self.file_actions[\"open_project\"].setStatusTip(\n            \"Open an existing project\"\n        )\n\n        # Import action\n        self.file_actions[\"import_project\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/import.svg\")),\n            \"Import...\",\n            self,\n        )\n        self.file_actions[\"import_project\"].setStatusTip(\n            \"Import data from an exiting project\"\n        )\n\n    def _create_undo_redo_actions(self):\n        \"\"\"Create the \"forward/back\" arrow undo/redo actions.\"\"\"\n        self.undo_redo_actions[\"undo\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/undo.svg\")),\n            \"Undo\",\n            self,\n        )\n        self.undo_redo_actions[\"undo\"].setStatusTip(\"Undo\")\n\n        self.undo_redo_actions[\"redo\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/redo.svg\")),\n            \"Redo\",\n            self,\n        )\n        self.undo_redo_actions[\"redo\"].setStatusTip(\"Redo\")\n\n        # Disable/enable based on stack state.\n        # The actions become disabled if there is nothing to undo/redo\n        self.undo_redo_actions[\"undo\"].setEnabled(self.undo_stack.canUndo())\n        self.undo_redo_actions[\"redo\"].setEnabled(self.undo_stack.canRedo())\n\n        # Keep the action status updated as the user performs operations\n        self.undo_stack.canUndoChanged.connect(\n            self.undo_redo_actions[\"undo\"].setEnabled\n        )\n        self.undo_stack.canRedoChanged.connect(\n            self.undo_redo_actions[\"redo\"].setEnabled\n        )\n\n        # When an undo/redo item is pushed to the stack, we track the\n        # text of the associated item\n        # (provided inside the command constructors)\n        # The new text is then used to construct the status bar tip\n        self.undo_stack.undoTextChanged.connect(self._update_undo_tooltip)\n        self.undo_stack.redoTextChanged.connect(self._update_redo_tooltip)\n\n    def _update_undo_tooltip(self):\n        if self.undo_stack.canUndo():\n            self.undo_redo_actions[\"undo\"].setStatusTip(\n                f\"Undo {self.undo_stack.undoText()}\"\n            )\n        else:\n            self.undo_redo_actions[\"undo\"].setStatusTip(\"Nothing to undo\")\n\n    def _update_redo_tooltip(self):\n        if self.undo_stack.canRedo():\n            self.undo_redo_actions[\"redo\"].setStatusTip(\n                f\"Redo {self.undo_stack.redoText()}\"\n            )\n        else:\n            self.undo_redo_actions[\"redo\"].setStatusTip(\"Nothing to redo\")\n\n    def disconnect_undo_redo(self):\n        \"\"\"Disconnect the signals during the shutdown.\n\n        This step prevents the objects deleted during the shutdown from\n        being accessed\n        \"\"\"\n        self.undo_stack.canUndoChanged.disconnect(\n            self.undo_redo_actions[\"undo\"].setEnabled\n        )\n        self.undo_stack.canRedoChanged.disconnect(\n            self.undo_redo_actions[\"redo\"].setEnabled\n        )\n        self.undo_stack.undoTextChanged.disconnect(self._update_undo_tooltip)\n        self.undo_stack.redoTextChanged.disconnect(self._update_redo_tooltip)\n\n    def _create_unit_cell_actions(self):\n        \"\"\"Create actions for unit cell visualization.\"\"\"\n        # Toggle wireframe action\n        self.unit_cell_actions[\"wireframe\"] = QAction(\n            QIcon(os.path.join(basedir, \"../../assets/icons/box.svg\")),\n            \"Toggle wireframe\",\n            self,\n        )\n        self.unit_cell_actions[\"wireframe\"].setCheckable(True)\n        self.unit_cell_actions[\"wireframe\"].setStatusTip(\n            \"Show/hide unit cell wireframe\"\n        )\n\n    def connect_signals(self, handlers):\n        \"\"\"\n        Connect actions to their handlers.\n\n        Parameters\n        ----------\n        handlers\n            Dictionary mapping action names to handler functions\n        \"\"\"\n        # Connect file actions\n        for action_name, action in self.file_actions.items():\n            if action_name in handlers:\n                action.triggered.connect(handlers[action_name])\n        # Connect undo/redo actions\n        for action_name, action in self.undo_redo_actions.items():\n            if action_name in handlers:\n                action.triggered.connect(handlers[action_name])\n        # Connect unit cell actions\n        for action_name, action in self.unit_cell_actions.items():\n            if action_name in handlers:\n                action.triggered.connect(handlers[action_name])\n</code></pre>"},{"location":"dev/ui/#TiBi.ui.actions.ActionManager.connect_signals","title":"<code>connect_signals(handlers)</code>","text":"<p>Connect actions to their handlers.</p> <p>Parameters:</p> Name Type Description Default <code>handlers</code> <p>Dictionary mapping action names to handler functions</p> required Source code in <code>TiBi/ui/actions/action_manager.py</code> <pre><code>def connect_signals(self, handlers):\n    \"\"\"\n    Connect actions to their handlers.\n\n    Parameters\n    ----------\n    handlers\n        Dictionary mapping action names to handler functions\n    \"\"\"\n    # Connect file actions\n    for action_name, action in self.file_actions.items():\n        if action_name in handlers:\n            action.triggered.connect(handlers[action_name])\n    # Connect undo/redo actions\n    for action_name, action in self.undo_redo_actions.items():\n        if action_name in handlers:\n            action.triggered.connect(handlers[action_name])\n    # Connect unit cell actions\n    for action_name, action in self.unit_cell_actions.items():\n        if action_name in handlers:\n            action.triggered.connect(handlers[action_name])\n</code></pre>"},{"location":"dev/ui/#TiBi.ui.actions.ActionManager.disconnect_undo_redo","title":"<code>disconnect_undo_redo()</code>","text":"<p>Disconnect the signals during the shutdown.</p> <p>This step prevents the objects deleted during the shutdown from being accessed</p> Source code in <code>TiBi/ui/actions/action_manager.py</code> <pre><code>def disconnect_undo_redo(self):\n    \"\"\"Disconnect the signals during the shutdown.\n\n    This step prevents the objects deleted during the shutdown from\n    being accessed\n    \"\"\"\n    self.undo_stack.canUndoChanged.disconnect(\n        self.undo_redo_actions[\"undo\"].setEnabled\n    )\n    self.undo_stack.canRedoChanged.disconnect(\n        self.undo_redo_actions[\"redo\"].setEnabled\n    )\n    self.undo_stack.undoTextChanged.disconnect(self._update_undo_tooltip)\n    self.undo_stack.redoTextChanged.disconnect(self._update_redo_tooltip)\n</code></pre>"},{"location":"dev/views/","title":"Views","text":"<p>This page provides the documentation for the views, panel components, and UI widgets.</p>"},{"location":"dev/views/#views","title":"Views","text":""},{"location":"dev/views/#TiBi.views.BrillouinZonePlotView","title":"<code>TiBi.views.BrillouinZonePlotView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A 3D visualization panel for Brillouin Zone using PyQtGraph's OpenGL.</p> <p>Displays a Brillouin zone as a wireframe with vertices shown as small spheres. The visualization supports rotation and zooming.</p> <p>Features: - Interactive 3D visualization with mouse rotation and zooming - Colored axes representing the Cartesian coordinate system - BZ visualization with wireframe boundaries - High-symmetry points displayed as colored spheres - Selected high-symmetry points highlighted with a different color</p> Source code in <code>TiBi/views/bz_plot_view.py</code> <pre><code>class BrillouinZonePlotView(QWidget):\n    \"\"\"\n    A 3D visualization panel for Brillouin Zone using PyQtGraph's OpenGL.\n\n    Displays a Brillouin zone as a wireframe with vertices shown as small\n    spheres. The visualization supports rotation and zooming.\n\n    Features:\n    - Interactive 3D visualization with mouse rotation and zooming\n    - Colored axes representing the Cartesian coordinate system\n    - BZ visualization with wireframe boundaries\n    - High-symmetry points displayed as colored spheres\n    - Selected high-symmetry points highlighted with a different color\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.setMinimumHeight(150)\n\n        # Colors\n        self.point_color = CF_BLUE\n        self.selected_point_color = CF_YELLOW\n\n        # Setup layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n\n        # Create 3D plot widget\n        self.view = gl.GLViewWidget()\n        # Set almost-orthographic projection\n        self.view.opts[\"distance\"] = 2000\n        self.view.opts[\"fov\"] = 1  # In degrees\n        self.view.setBackgroundColor(\"k\")  # Black background\n\n        # Axes\n        axis_limit = 10\n        axes = [\n            np.array([[-axis_limit, 0, 0], [axis_limit, 0, 0]]),\n            np.array([[0, -axis_limit, 0], [0, axis_limit, 0]]),\n            np.array([[0, 0, -axis_limit], [0, 0, axis_limit]]),\n        ]\n        for ii, color in enumerate(\n            [\n                CF_VERMILLION,\n                CF_GREEN,\n                CF_SKY,\n            ]\n        ):\n            self.view.addItem(\n                gl.GLLinePlotItem(\n                    pos=axes[ii], color=color, width=5, antialias=True\n                )\n            )\n\n        layout.addWidget(self.view, stretch=1)\n</code></pre>"},{"location":"dev/views/#TiBi.views.ComputationView","title":"<code>TiBi.views.ComputationView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A multi-tab view for setting up and managing computations.</p> <p>This view contains the following panels:</p> <ul> <li>HoppintPanel: For managing hopping parameters</li> <li>BandsPanel: For managing band structure and Brillouin grid calculations</li> </ul> <p>Attributes:</p> Name Type Description <code>hopping_panel</code> <code>HoppingPanel</code> <p>Panel for editing hopping parameters between states.</p> <code>bands_panel</code> <code>BandsPanel</code> <p>Panel for managing band and Brillouin grid calculations.</p> Source code in <code>TiBi/views/computation_view.py</code> <pre><code>class ComputationView(QWidget):\n    \"\"\"\n    A multi-tab view for setting up and managing computations.\n\n    This view contains the following panels:\n\n    - HoppintPanel: For managing hopping parameters\n    - BandsPanel: For managing band structure and Brillouin grid calculations\n\n    Attributes\n    ----------\n    hopping_panel : HoppingPanel\n        Panel for editing hopping parameters between states.\n    bands_panel : BandsPanel\n        Panel for managing band and Brillouin grid calculations.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Create a layout for the TabView itself\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(\n            0, 0, 0, 0\n        )  # Remove margins to maximize space\n        self.hopping_panel = HoppingPanel()\n        self.bands_panel = BandsPanel()\n\n        # Wrap each panel in scroll area\n        hopping_scroll = QScrollArea()\n        hopping_scroll.setWidgetResizable(True)\n        hopping_scroll.setSizePolicy(\n            QSizePolicy.Expanding, QSizePolicy.Expanding\n        )\n        hopping_scroll.setWidget(self.hopping_panel)\n\n        bands_scroll = QScrollArea()\n        bands_scroll.setWidgetResizable(True)\n        bands_scroll.setSizePolicy(\n            QSizePolicy.Expanding, QSizePolicy.Expanding\n        )\n        bands_scroll.setWidget(self.bands_panel)\n\n        self.tabs = QTabWidget()\n        self.tabs.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        self.tabs.addTab(hopping_scroll, \"Hopping\")\n        self.tabs.addTab(bands_scroll, \"Bands\")\n        self.tabs.setTabPosition(QTabWidget.East)\n        self.tabs.setDocumentMode(True)\n\n        layout.addWidget(self.tabs)\n\n        # Set the layout for this widget\n        self.setLayout(layout)\n</code></pre>"},{"location":"dev/views/#TiBi.views.MainToolbarView","title":"<code>TiBi.views.MainToolbarView</code>","text":"<p>               Bases: <code>QToolBar</code></p> <p>Main toolbar view that contains application-wide actions.</p> <p>This class is a view component that provides a toolbar with common actions such as creating new unit cells, saving/loading projects, etc.</p> <p>It does not create actions itself, receiving them from an action manager.</p> Source code in <code>TiBi/views/main_toolbar_view.py</code> <pre><code>class MainToolbarView(QToolBar):\n    \"\"\"\n    Main toolbar view that contains application-wide actions.\n\n    This class is a view component that provides a toolbar with common actions\n    such as creating new unit cells, saving/loading projects, etc.\n\n    It does not create actions itself, receiving them from an action manager.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"Main Toolbar\")\n\n        # Allow the toolbar to be moved by the user\n        self.setMovable(True)\n\n    def set_actions(self, action_manager: ActionManager):\n        \"\"\"\n        Set actions from the action manager to the toolbar.\n\n        Parameters\n        ----------\n        action_manager : ActionManager\n            ActionManager instance containing all actions to be added.\n        \"\"\"\n        # Add File actions\n        self.addAction(action_manager.file_actions[\"new_project\"])\n        self.addAction(action_manager.file_actions[\"open_project\"])\n        self.addAction(action_manager.file_actions[\"import_project\"])\n        self.addAction(action_manager.file_actions[\"save_project\"])\n\n        self.addSeparator()\n\n        self.addAction(action_manager.undo_redo_actions[\"undo\"])\n        self.addAction(action_manager.undo_redo_actions[\"redo\"])\n\n        self.addSeparator()\n\n        self.addAction(action_manager.unit_cell_actions[\"wireframe\"])\n        # Add the grouped spinboxes\n        self.addWidget(self._create_uc_spinbox_group())\n\n    def _create_uc_spinbox_group(self):\n        \"\"\"\n        Create a grouped widget containing spinboxes for unit cell repetitions.\n        \"\"\"\n        group_widget = QWidget()\n        layout = QHBoxLayout(group_widget)\n        layout.setContentsMargins(0, 0, 0, 0)  # Remove padding to fit nicely\n        layout.setSpacing(5)  # Small spacing between spinboxes and labels\n\n        self.n1_spinbox = QSpinBox()\n        self.n2_spinbox = QSpinBox()\n        self.n3_spinbox = QSpinBox()\n\n        for ii, spinbox in enumerate(\n            [self.n1_spinbox, self.n2_spinbox, self.n3_spinbox]\n        ):\n            spinbox.setRange(1, 10)\n            spinbox.setFixedWidth(50)\n            spinbox.setToolTip(f\"Along v&lt;sub&gt;{ii+1}&lt;/sub&gt;\")\n            spinbox.setStatusTip(\"Number of unit cells\")\n            spinbox.setEnabled(False)\n\n        layout.addWidget(QLabel(\"n&lt;sub&gt;1&lt;/sub&gt;:\"))\n        # layout.addWidget(QLabel(\"n\\u2081:\"))\n        layout.addWidget(self.n1_spinbox)\n        layout.addWidget(QLabel(\"n&lt;sub&gt;2&lt;/sub&gt;:\"))\n        # layout.addWidget(QLabel(\"n\\u2082:\"))\n        layout.addWidget(self.n2_spinbox)\n        layout.addWidget(QLabel(\"n&lt;sub&gt;3&lt;/sub&gt;:\"))\n        # layout.addWidget(QLabel(\"n\\u2083:\"))\n        layout.addWidget(self.n3_spinbox)\n\n        return group_widget\n</code></pre>"},{"location":"dev/views/#TiBi.views.MainToolbarView.set_actions","title":"<code>set_actions(action_manager)</code>","text":"<p>Set actions from the action manager to the toolbar.</p> <p>Parameters:</p> Name Type Description Default <code>action_manager</code> <code>ActionManager</code> <p>ActionManager instance containing all actions to be added.</p> required Source code in <code>TiBi/views/main_toolbar_view.py</code> <pre><code>def set_actions(self, action_manager: ActionManager):\n    \"\"\"\n    Set actions from the action manager to the toolbar.\n\n    Parameters\n    ----------\n    action_manager : ActionManager\n        ActionManager instance containing all actions to be added.\n    \"\"\"\n    # Add File actions\n    self.addAction(action_manager.file_actions[\"new_project\"])\n    self.addAction(action_manager.file_actions[\"open_project\"])\n    self.addAction(action_manager.file_actions[\"import_project\"])\n    self.addAction(action_manager.file_actions[\"save_project\"])\n\n    self.addSeparator()\n\n    self.addAction(action_manager.undo_redo_actions[\"undo\"])\n    self.addAction(action_manager.undo_redo_actions[\"redo\"])\n\n    self.addSeparator()\n\n    self.addAction(action_manager.unit_cell_actions[\"wireframe\"])\n    # Add the grouped spinboxes\n    self.addWidget(self._create_uc_spinbox_group())\n</code></pre>"},{"location":"dev/views/#TiBi.views.MainWindow","title":"<code>TiBi.views.MainWindow</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main application window that defines the UI layout.</p> <p>This class is purely a view component that arranges the UI elements and doesn't contain business logic or model manipulation. It creates a four-column layout for organizing the different components of the application, along with menu bar, toolbar, and status bar.</p> <p>Attributes:</p> Name Type Description <code>uc</code> <code>UnitCellView</code> <p>Unit cell editor view</p> <code>uc_plot</code> <code>UnitCellPlotView</code> <p>Unit cell 3D visualization view</p> <code>bz_plot</code> <code>BrillouinZonePlotView</code> <p>Brillouin zone 3D visualization view</p> <code>plot</code> <code>PlotView</code> <p>2D plot view</p> <code>computation</code> <code>ComputationView</code> <p>Multi-tab view used to set up calculations</p> <code>window_closed</code> <code>Signal</code> <p>Signals the main app to run the cleanup procedure</p> Source code in <code>TiBi/views/main_window.py</code> <pre><code>class MainWindow(QMainWindow):\n    \"\"\"\n    Main application window that defines the UI layout.\n\n    This class is purely a view component that arranges the UI elements and\n    doesn't contain business logic or model manipulation. It creates a\n    four-column layout for organizing the different components of the\n    application, along with menu bar, toolbar, and status bar.\n\n    Attributes\n    ----------\n    uc : UnitCellView\n        Unit cell editor view\n    uc_plot : UnitCellPlotView\n        Unit cell 3D visualization view\n    bz_plot : BrillouinZonePlotView\n        Brillouin zone 3D visualization view\n    plot : PlotView\n        2D plot view\n    computation : ComputationView\n        Multi-tab view used to set up calculations\n    window_closed : Signal\n        Signals the main app to run the cleanup procedure\n    \"\"\"\n\n    window_closed = Signal()\n\n    def __init__(\n        self,\n        uc: UnitCellView,\n        uc_plot: UnitCellPlotView,\n        bz_plot: BrillouinZonePlotView,\n        plot: PlotView,\n        computation_view: ComputationView,\n        menu_bar: MenuBarView,\n        toolbar: MainToolbarView,\n        status_bar: StatusBarView,\n    ):\n        super().__init__()\n        self.setWindowTitle(\"TiBi\")\n        # self.setMinimumSize(1100, 825)\n\n        # Store references to UI components\n        self.uc = uc\n        self.uc_plot = uc_plot\n        self.bz_plot = bz_plot\n        self.plot = plot\n        self.computation_view = computation_view\n\n        # Set menu bar\n        self.setMenuBar(menu_bar)\n        # Add toolbar\n        self.addToolBar(toolbar)\n        # Set status bar\n        self.setStatusBar(status_bar)\n\n        # Main Layout\n        main_view = QWidget()\n        main_layout = QHBoxLayout(main_view)\n\n        # Create three column Layouts and wrap them into Widgets\n        # UnitCell geometry and Sites\n        unit_cell_layout = QVBoxLayout()\n        unit_cell_layout.setContentsMargins(0, 0, 0, 0)\n        unit_cell_widget = QWidget()\n        unit_cell_widget.setLayout(unit_cell_layout)\n        unit_cell_widget.setSizePolicy(\n            QSizePolicy.Fixed, QSizePolicy.Expanding\n        )\n        unit_cell_layout.addWidget(self._frame_widget(self.uc))\n\n        # Computation controls and BZ\n        computation_layout = QVBoxLayout()\n        computation_layout.setContentsMargins(0, 0, 0, 0)\n\n        computation_widget = QWidget()\n        computation_widget.setLayout(computation_layout)\n        computation_widget.setSizePolicy(\n            QSizePolicy.Fixed, QSizePolicy.Expanding\n        )\n\n        # Set fixed height for computation_view\n        computation_splitter = QSplitter(Qt.Vertical)\n        inner_height = max(\n            self.computation_view.bands_panel.sizeHint().height(),\n            self.computation_view.hopping_panel.sizeHint().height(),\n        )\n        margin_buffer = 20  # adjust if needed\n        max_height = inner_height + margin_buffer\n\n        computation_view_framed = self._frame_widget(self.computation_view)\n        computation_view_framed.setMaximumHeight(max_height)\n        computation_view_framed.setSizePolicy(\n            QSizePolicy.Preferred, QSizePolicy.Preferred\n        )\n\n        computation_splitter.addWidget(self._frame_widget(self.bz_plot))\n        computation_splitter.addWidget(computation_view_framed)\n\n        # Disable expansion of computation_view\n        computation_splitter.setStretchFactor(0, 1)\n        computation_splitter.setStretchFactor(1, 0)\n\n        computation_splitter.setCollapsible(0, False)\n        computation_splitter.setCollapsible(1, False)\n\n        # Prevent computation_view from growing too large\n        computation_layout.addWidget(computation_splitter)\n\n        # UC 3D plot and results plots\n        plots_splitter = QSplitter(Qt.Vertical)\n        plots_splitter.addWidget(\n            self._frame_widget(self.uc_plot)\n        )  # Top 3D plot\n        plots_splitter.addWidget(\n            self._frame_widget(self.plot)\n        )  # Bottom 2D plot\n\n        # Set initial size ratio\n        plots_splitter.setSizes([1, 1])\n        # Prevent the panels from collapsing\n        plots_splitter.setCollapsible(0, False)\n        plots_splitter.setCollapsible(1, False)\n\n        main_layout.addWidget(unit_cell_widget)\n        main_layout.addWidget(computation_widget)\n        main_layout.addWidget(plots_splitter)\n        # Set as central widget\n        self.setCentralWidget(main_view)\n\n    def closeEvent(self, event):\n        # Override the parent class closeEvent to emit a signal on closing.\n        self.window_closed.emit()\n        super().closeEvent(event)\n\n    def _frame_widget(self, widget: QWidget) -&gt; QFrame:\n        \"\"\"\n        Enclose a widget in a frame.\n\n        Used to make the layout look more structured.\n        \"\"\"\n        frame = QFrame()\n        frame.setFrameShape(QFrame.Box)\n        frame.setLineWidth(1)\n        layout = QVBoxLayout()\n        layout.setContentsMargins(5, 5, 5, 5)\n        layout.addWidget(widget, stretch=1)\n        frame.setLayout(layout)\n        return frame\n</code></pre>"},{"location":"dev/views/#TiBi.views.MenuBarView","title":"<code>TiBi.views.MenuBarView</code>","text":"<p>               Bases: <code>QMenuBar</code></p> <p>Menu bar view that provides access to application features.</p> <p>This class is a view component that organizes application actions into menus, providing a standard way to access all functionality.</p> <p>It does not create actions itself, receiving them from an action manager.</p> <p>Methods:</p> Name Description <code>set_actions</code> <p>Set actions from the action manager to the appropriate menus.</p> Source code in <code>TiBi/views/menu_bar_view.py</code> <pre><code>class MenuBarView(QMenuBar):\n    \"\"\"\n    Menu bar view that provides access to application features.\n\n    This class is a view component that organizes application actions\n    into menus, providing a standard way to access all functionality.\n\n    It does not create actions itself, receiving them from an action manager.\n\n    Methods\n    -------\n    set_actions(action_manager: ActionManager)\n        Set actions from the action manager to the appropriate menus.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Create empty menus\n        self.file_menu = QMenu(\"&amp;File\", self)\n        self.edit_menu = QMenu(\"&amp;Edit\", self)\n        self.view_menu = QMenu(\"&amp;View\", self)\n        self.computation_menu = QMenu(\"&amp;Computation\", self)\n        self.help_menu = QMenu(\"&amp;Help\", self)\n\n        # Add menus to the menu bar\n        self.addMenu(self.file_menu)\n        # self.addMenu(self.edit_menu)\n        # self.addMenu(self.view_menu)\n        # self.addMenu(self.computation_menu)\n        # self.addMenu(self.help_menu)\n\n    def set_actions(self, action_manager):\n        \"\"\"\n        Set actions from the action manager to the appropriate menus.\n\n        Parameters\n        ----------\n        action_manager : ActionManager\n            ActionManager instance containing all actions to be added.\n        \"\"\"\n        # Populate File menu\n        self.file_menu.addAction(action_manager.file_actions[\"new_project\"])\n        self.file_menu.addAction(action_manager.file_actions[\"open_project\"])\n        self.file_menu.addAction(action_manager.file_actions[\"import_project\"])\n\n        self.file_menu.addSeparator()\n        self.file_menu.addAction(action_manager.file_actions[\"save_project\"])\n        self.file_menu.addAction(\n            action_manager.file_actions[\"save_project_as\"]\n        )\n</code></pre>"},{"location":"dev/views/#TiBi.views.MenuBarView.set_actions","title":"<code>set_actions(action_manager)</code>","text":"<p>Set actions from the action manager to the appropriate menus.</p> <p>Parameters:</p> Name Type Description Default <code>action_manager</code> <code>ActionManager</code> <p>ActionManager instance containing all actions to be added.</p> required Source code in <code>TiBi/views/menu_bar_view.py</code> <pre><code>def set_actions(self, action_manager):\n    \"\"\"\n    Set actions from the action manager to the appropriate menus.\n\n    Parameters\n    ----------\n    action_manager : ActionManager\n        ActionManager instance containing all actions to be added.\n    \"\"\"\n    # Populate File menu\n    self.file_menu.addAction(action_manager.file_actions[\"new_project\"])\n    self.file_menu.addAction(action_manager.file_actions[\"open_project\"])\n    self.file_menu.addAction(action_manager.file_actions[\"import_project\"])\n\n    self.file_menu.addSeparator()\n    self.file_menu.addAction(action_manager.file_actions[\"save_project\"])\n    self.file_menu.addAction(\n        action_manager.file_actions[\"save_project_as\"]\n    )\n</code></pre>"},{"location":"dev/views/#TiBi.views.PlotView","title":"<code>TiBi.views.PlotView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for displaying 2D plots.</p> <p>This widget creates a matplotlib figure embedded in a Qt widget to display data as 2D plots. It includes navigation controls for zooming, panning, and saving the plot.</p> Source code in <code>TiBi/views/plot_view.py</code> <pre><code>class PlotView(QWidget):\n    \"\"\"\n    Widget for displaying 2D plots.\n\n    This widget creates a matplotlib figure embedded in a Qt widget to display\n    data as 2D plots. It includes navigation controls for zooming, panning,\n    and saving the plot.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.setMinimumHeight(150)\n\n        # Setup layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(1, 1, 1, 1)\n\n        # Matplotlib Figure\n        self.figure = mpl_fig.Figure(figsize=(5, 4), dpi=100)\n        self.canvas = FigureCanvas(self.figure)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        self.toolbar.setIconSize(QSize(20, 20))\n\n        # Add widgets to layout\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas, stretch=1)\n\n        # Initialize plot\n        self.ax = self.figure.add_subplot(111)\n        self.ax.grid(True)\n\n        # Initial draw\n        self.canvas.draw()\n</code></pre>"},{"location":"dev/views/#TiBi.views.ProgressDialog","title":"<code>TiBi.views.ProgressDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>A modal that displays a progress bar and a cancel button.</p> <p>Attributes:</p> Name Type Description <code>cancel_requested</code> <code>Signal</code> <p>Signal emitted when the cancel button is clicked.</p> <p>Methods:</p> Name Description <code>update_progress</code> <p>Updates the progress bar with the given value.</p> Source code in <code>TiBi/views/progress_dialog.py</code> <pre><code>class ProgressDialog(QDialog):\n    \"\"\"\n    A modal that displays a progress bar and a cancel button.\n\n    Attributes\n    ----------\n    cancel_requested : Signal\n        Signal emitted when the cancel button is clicked.\n\n    Methods\n    -------\n    update_progress(value: int)\n        Updates the progress bar with the given value.\n    \"\"\"\n\n    cancel_requested = Signal()\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Working...\")\n        self.setModal(True)\n\n        self.progress_bar = QProgressBar()\n        self.progress_bar.setRange(0, 100)\n\n        self.cancel_button = QPushButton(\"Cancel\")\n        self.cancel_button.clicked.connect(self.cancel_requested.emit)\n\n        layout = QVBoxLayout()\n        layout.addWidget(self.progress_bar)\n        layout.addWidget(self.cancel_button)\n        self.setLayout(layout)\n\n    def update_progress(self, value: int):\n        \"\"\"\n        Update the progress bar with the given value.\n        \"\"\"\n        self.progress_bar.setValue(value)\n</code></pre>"},{"location":"dev/views/#TiBi.views.ProgressDialog.update_progress","title":"<code>update_progress(value)</code>","text":"<p>Update the progress bar with the given value.</p> Source code in <code>TiBi/views/progress_dialog.py</code> <pre><code>def update_progress(self, value: int):\n    \"\"\"\n    Update the progress bar with the given value.\n    \"\"\"\n    self.progress_bar.setValue(value)\n</code></pre>"},{"location":"dev/views/#TiBi.views.StatusBarView","title":"<code>TiBi.views.StatusBarView</code>","text":"<p>               Bases: <code>QStatusBar</code></p> <p>Status bar view that displays application status information.</p> <p>This class is a view component that shows messages to the user.</p> <p>Methods:</p> Name Description <code>update_status</code> <p>Update the status label.</p> Source code in <code>TiBi/views/status_bar_view.py</code> <pre><code>class StatusBarView(QStatusBar):\n    \"\"\"\n    Status bar view that displays application status information.\n\n    This class is a view component that shows messages to the user.\n\n    Methods\n    -------\n    update_status(text: str)\n        Update the status label.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Create a permanent status label\n        self.status_label = QLabel(\"Ready\")\n        self.addPermanentWidget(self.status_label)\n\n    def update_status(self, text: str):\n        \"\"\"\n        Update the status label.\n\n        Parameters\n        ----------\n        text : str\n            New status text to display\n        \"\"\"\n        self.status_label.setText(text)\n</code></pre>"},{"location":"dev/views/#TiBi.views.StatusBarView.update_status","title":"<code>update_status(text)</code>","text":"<p>Update the status label.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>New status text to display</p> required Source code in <code>TiBi/views/status_bar_view.py</code> <pre><code>def update_status(self, text: str):\n    \"\"\"\n    Update the status label.\n\n    Parameters\n    ----------\n    text : str\n        New status text to display\n    \"\"\"\n    self.status_label.setText(text)\n</code></pre>"},{"location":"dev/views/#TiBi.views.UnitCellPlotView","title":"<code>TiBi.views.UnitCellPlotView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A 3D visualization panel for <code>UnitCell</code> using PyQtGraph's OpenGL support.</p> <p>Displays a unit cell as a wireframe parallelepiped with sites as spheres. The visualization supports rotation and zooming.</p> <p>Features: - Interactive 3D visualization with mouse rotation and zooming - Colored axes representing the Cartesian coordinate system - Unit cell visualization with wireframe parallelepiped - Sites displayed as colored spheres at their fractional positions - Selected sites highlighted with an increased size</p> Source code in <code>TiBi/views/uc_plot_view.py</code> <pre><code>class UnitCellPlotView(QWidget):\n    \"\"\"\n    A 3D visualization panel for `UnitCell` using PyQtGraph's OpenGL support.\n\n    Displays a unit cell as a wireframe parallelepiped with sites as spheres.\n    The visualization supports rotation and zooming.\n\n    Features:\n    - Interactive 3D visualization with mouse rotation and zooming\n    - Colored axes representing the Cartesian coordinate system\n    - Unit cell visualization with wireframe parallelepiped\n    - Sites displayed as colored spheres at their fractional positions\n    - Selected sites highlighted with an increased size\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.setMinimumHeight(150)\n\n        # Setup layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n\n        # Create 3D plot widget\n        self.view = gl.GLViewWidget()\n        # Set almost-orthographic projection\n        self.view.opts[\"distance\"] = 2000\n        self.view.opts[\"fov\"] = 1  # In degrees\n\n        self.view.setBackgroundColor(\"k\")  # Black background\n\n        # Axes\n        axis_limit = 10\n        axes = [\n            np.array([[-axis_limit, 0, 0], [axis_limit, 0, 0]]),\n            np.array([[0, -axis_limit, 0], [0, axis_limit, 0]]),\n            np.array([[0, 0, -axis_limit], [0, 0, axis_limit]]),\n        ]\n        for ii, color in enumerate(\n            [\n                CF_VERMILLION,\n                CF_GREEN,\n                CF_SKY,\n            ]\n        ):\n            self.view.addItem(\n                gl.GLLinePlotItem(\n                    pos=axes[ii], color=color, width=5, antialias=True\n                )\n            )\n\n        layout.addWidget(self.view)\n</code></pre>"},{"location":"dev/views/#TiBi.views.UnitCellView","title":"<code>TiBi.views.UnitCellView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Main UI component for managing unit cells, sites, and states.</p> <p>This widget combines a tree view of the unit cell hierarchy with dynamically swappable panels for editing properties of the selected tree node. It handles the data models and coordinates interactions between the tree view and detail panels.</p> <p>The UI consists of several main parts:</p> <ol> <li>Tree view panel showing the hierarchy of unit cells, sites, and states</li> <li>Button panel with actions for creating, deleting, and modifying items</li> <li>Form panels that change depending on what is selected in the tree</li> <li>Dimensionality controls for setting periodic boundary conditions</li> </ol> <p>Attributes:</p> Name Type Description <code>unit_cell_panel</code> <code>UnitCellPanel</code> <p>Panel for editing <code>UnitCell</code> properties.</p> <code>site_panel</code> <code>SitePanel</code> <p>Panel for editing <code>Site</code> properties.</p> <code>tree_view_panel</code> <code>TreeViewPanel</code> <p>Panel displaying the tree view of <code>UnitCell</code>s, <code>Site</code>s, and <code>State</code>s.</p> Source code in <code>TiBi/views/uc_view.py</code> <pre><code>class UnitCellView(QWidget):\n    \"\"\"\n    Main UI component for managing unit cells, sites, and states.\n\n    This widget combines a tree view of the unit cell hierarchy with\n    dynamically swappable panels for editing properties of the selected\n    tree node. It handles the data models and coordinates interactions\n    between the tree view and detail panels.\n\n    The UI consists of several main parts:\n\n    1. Tree view panel showing the hierarchy of unit cells, sites, and states\n    2. Button panel with actions for creating, deleting, and modifying items\n    3. Form panels that change depending on what is selected in the tree\n    4. Dimensionality controls for setting periodic boundary conditions\n\n    Attributes\n    ----------\n    unit_cell_panel : UnitCellPanel\n        Panel for editing `UnitCell` properties.\n    site_panel : SitePanel\n        Panel for editing `Site` properties.\n    tree_view_panel : TreeViewPanel\n        Panel displaying the tree view of `UnitCell`s, `Site`s, and `State`s.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        # Main layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(1, 1, 1, 1)\n\n        # Initialize UI panels\n        self.unit_cell_panel = UnitCellPanel()\n        self.site_panel = SitePanel()\n        self.tree_view_panel = TreeViewPanel()\n\n        # Use the unit_cell_panel to determine the width of the tree view panel\n        tree_view_width = self.unit_cell_panel.sizeHint().width()\n        self.tree_view_panel.setFixedWidth(tree_view_width)\n        # Info labels\n        self.uc_info_label = QLabel(\"Add/Select a Unit Cell\")\n        self.uc_info_label.setAlignment(Qt.AlignCenter)\n\n        self.site_info_label = QLabel(\"Add/Select a Site\")\n        self.site_info_label.setAlignment(Qt.AlignCenter)\n\n        # Panel stacks\n        self.uc_stack = QStackedWidget()\n        self.uc_stack.addWidget(self.uc_info_label)\n        self.uc_stack.addWidget(self.unit_cell_panel)\n\n        self.site_stack = QStackedWidget()\n        self.site_stack.addWidget(self.site_info_label)\n        self.site_stack.addWidget(self.site_panel)\n\n        # Create the interface\n        # Top panel contains the tree view\n        top_panel = QVBoxLayout()\n        top_panel.addWidget(self.tree_view_panel)\n\n        # Bottom panel contains the unit cell/state editable fields\n        bottom_panel = QVBoxLayout()\n        bottom_panel.addWidget(self.uc_stack)\n        bottom_panel.addWidget(divider_line())\n        bottom_panel.addWidget(self.site_stack)\n\n        layout.setSpacing(0)\n\n        layout.addLayout(top_panel)\n        layout.addWidget(divider_line())\n        layout.addLayout(bottom_panel)\n        layout.setStretch(0, 1)\n        layout.setStretch(1, 0)\n        layout.setStretch(2, 0)\n</code></pre>"},{"location":"dev/views/#panel-components","title":"Panel Components","text":""},{"location":"dev/views/#TiBi.views.panels.BandsPanel","title":"<code>TiBi.views.panels.BandsPanel</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A panel for managing band structure calculations and projections.</p> <p>This panel allows users to define a path in the Brillouin zone, compute band structures, and project states onto various basis states. The panel also includes options for configuring the Brillouin zone grid and DOS calculations.</p> Source code in <code>TiBi/views/panels/bands_panel.py</code> <pre><code>class BandsPanel(QWidget):\n    \"\"\"\n    A panel for managing band structure calculations and projections.\n\n    This panel allows users to define a path in the Brillouin zone, compute\n    band structures, and project states onto various basis states.\n    The panel also includes options for configuring\n    the Brillouin zone grid and DOS calculations.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # Main Layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        self.bands_grid = QGridLayout()\n        self.proj_layout = QVBoxLayout()\n        self.dos_layout = QVBoxLayout()\n        layout.addLayout(self.bands_grid, stretch=1)\n        layout.addWidget(divider_line())\n        layout.addLayout(self.proj_layout)\n        layout.addWidget(divider_line())\n        layout.addLayout(self.dos_layout, stretch=1)\n\n        # Bands Section\n        self.bands_grid.setContentsMargins(10, 5, 15, 5)\n        path_label = QLabel(\"Band Calculations\")\n        path_label.setProperty(\"style\", \"bold\")\n        path_label.setAlignment(\n            Qt.AlignCenter\n        )  # This centers the text within the label\n        self.bands_grid.addWidget(path_label, 0, 0, 1, 8)\n\n        # Icons\n        icon_size = QSize(20, 20)\n        left_arrow_icon = QIcon()\n        left_arrow_icon.addFile(\n            str(get_resource_path(\"assets/icons/down_arrow.svg\")),\n            mode=QIcon.Mode.Normal,\n        )\n        left_arrow_icon.addFile(\n            str(get_resource_path(\"assets/icons/down_arrow_disabled.svg\")),\n            mode=QIcon.Mode.Disabled,\n        )\n\n        right_arrow_icon = QIcon()\n        right_arrow_icon.addFile(\n            str(get_resource_path(\"assets/icons/up_arrow.svg\")),\n            mode=QIcon.Mode.Normal,\n        )\n        right_arrow_icon.addFile(\n            str(get_resource_path(\"assets/icons/up_arrow_disabled.svg\")),\n            mode=QIcon.Mode.Disabled,\n        )\n\n        # Gamma point controls (\u0393 - origin of reciprocal space)\n        self.add_gamma_btn = QPushButton(\"\u0393\")\n        self.add_gamma_btn.setToolTip(\"Gamma Point\")\n        self.add_gamma_btn.setStatusTip(\"Add the Gamma Point to the path.\")\n        self.bands_grid.addWidget(self.add_gamma_btn, 2, 0)\n\n        # Vertex selection controls\n        self.prev_vertex_btn = QPushButton()\n        self.prev_vertex_btn.setToolTip(\"Previous\")\n        self.prev_vertex_btn.setStatusTip(\"Select the previous Vertex.\")\n        self.prev_vertex_btn.setIcon(left_arrow_icon)\n        self.prev_vertex_btn.setIconSize(icon_size)\n\n        self.next_vertex_btn = QPushButton()\n        self.next_vertex_btn.setToolTip(\"Next\")\n        self.next_vertex_btn.setStatusTip(\"Select the next Vertex.\")\n        self.next_vertex_btn.setIcon(right_arrow_icon)\n        self.next_vertex_btn.setIconSize(icon_size)\n\n        self.add_vertex_btn = QPushButton(\"V\")\n        self.add_vertex_btn.setToolTip(\"Vertex\")\n        self.add_vertex_btn.setStatusTip(\n            \"Add the selected Vertex to the path.\"\n        )\n\n        self.bands_grid.addWidget(self.next_vertex_btn, 1, 1)\n        self.bands_grid.addWidget(self.add_vertex_btn, 2, 1)\n        self.bands_grid.addWidget(self.prev_vertex_btn, 3, 1)\n\n        # Edge midpoint selection controls\n        self.prev_edge_btn = QPushButton()\n        self.prev_edge_btn.setToolTip(\"Previous\")\n        self.prev_edge_btn.setStatusTip(\"Select the previous Edge.\")\n        self.prev_edge_btn.setIcon(left_arrow_icon)\n        self.prev_edge_btn.setIconSize(icon_size)\n\n        self.next_edge_btn = QPushButton()\n        self.next_edge_btn.setToolTip(\"Next\")\n        self.next_edge_btn.setStatusTip(\"Select the next Edge.\")\n        self.next_edge_btn.setIcon(right_arrow_icon)\n        self.next_edge_btn.setIconSize(icon_size)\n\n        self.add_edge_btn = QPushButton(\"E\")\n        self.add_edge_btn.setToolTip(\"Edge\")\n        self.add_edge_btn.setStatusTip(\"Add the selected Edge to the path.\")\n\n        self.bands_grid.addWidget(self.next_edge_btn, 1, 2)\n        self.bands_grid.addWidget(self.add_edge_btn, 2, 2)\n        self.bands_grid.addWidget(self.prev_edge_btn, 3, 2)\n\n        # Face center selection controls\n        self.prev_face_btn = QPushButton()\n        self.prev_face_btn.setToolTip(\"Previous\")\n        self.prev_face_btn.setStatusTip(\"Select the previous Face.\")\n        self.prev_face_btn.setIcon(left_arrow_icon)\n        self.prev_face_btn.setIconSize(icon_size)\n\n        self.next_face_btn = QPushButton()\n        self.next_face_btn.setToolTip(\"Next\")\n        self.next_face_btn.setStatusTip(\"Select the next Face.\")\n        self.next_face_btn.setIcon(right_arrow_icon)\n        self.next_face_btn.setIconSize(icon_size)\n\n        self.add_face_btn = QPushButton(\"F\")\n        self.add_face_btn.setToolTip(\"Face\")\n        self.add_face_btn.setStatusTip(\"Add the selected Face to the path.\")\n\n        self.bands_grid.addWidget(self.next_face_btn, 1, 3)\n        self.bands_grid.addWidget(self.add_face_btn, 2, 3)\n        self.bands_grid.addWidget(self.prev_face_btn, 3, 3)\n\n        # Path controls\n        self.remove_last_btn = QPushButton()\n        remove_last = QIcon()\n        remove_last.addFile(\n            str(get_resource_path(\"assets/icons/remove_last.svg\")),\n            mode=QIcon.Mode.Normal,\n        )\n        remove_last.addFile(\n            str(get_resource_path(\"assets/icons/remove_last_disabled.svg\")),\n            mode=QIcon.Mode.Disabled,\n        )\n        self.remove_last_btn.setIcon(remove_last)\n        self.remove_last_btn.setIconSize(icon_size)\n\n        self.remove_last_btn.setToolTip(\"Remove Last\")\n        self.remove_last_btn.setStatusTip(\n            \"Remove the last added point from the Brillouin Zone path.\"\n        )\n\n        self.clear_path_btn = QPushButton()\n        clear_path_icon = QIcon()\n        clear_path_icon.addFile(\n            str(get_resource_path(\"assets/icons/trash_hopping.svg\")),\n            mode=QIcon.Mode.Normal,\n        )\n        clear_path_icon.addFile(\n            str(get_resource_path(\"assets/icons/trash_hopping_disabled.svg\")),\n            mode=QIcon.Mode.Disabled,\n        )\n        self.clear_path_btn.setIcon(clear_path_icon)\n        self.clear_path_btn.setIconSize(icon_size)\n        self.clear_path_btn.setToolTip(\"Clear\")\n        self.clear_path_btn.setStatusTip(\"Clear the Brillouin Zone path.\")\n\n        kpoints_layout = QHBoxLayout()\n        self.n_points_spinbox = QSpinBox()\n        self.n_points_spinbox.setRange(1, 10000)\n        self.n_points_spinbox.setValue(100)\n        self.n_points_spinbox.setButtonSymbols(QSpinBox.NoButtons)\n        set_spinbox_digit_width(self.n_points_spinbox, 5)\n\n        self.compute_bands_btn = QPushButton()\n        compute_icon = QIcon()\n        compute_icon.addFile(\n            str(get_resource_path(\"assets/icons/computer.svg\")),\n            mode=QIcon.Mode.Normal,\n        )\n        compute_icon.addFile(\n            str(get_resource_path(\"assets/icons/computer_disabled.svg\")),\n            mode=QIcon.Mode.Disabled,\n        )\n        self.compute_bands_btn.setIcon(compute_icon)\n        self.compute_bands_btn.setIconSize(icon_size)\n        self.compute_bands_btn.setToolTip(\"Compute\")\n        self.compute_bands_btn.setStatusTip(\"Compute the Bands.\")\n\n        self.bands_grid.addWidget(self.remove_last_btn, 1, 5)\n        self.remove_last_btn.setEnabled(\n            False\n        )  # Disabled until path has points\n\n        self.bands_grid.addWidget(self.clear_path_btn, 1, 6)\n        self.clear_path_btn.setEnabled(False)  # Disabled until path has points\n\n        self.bands_grid.addWidget(self.compute_bands_btn, 1, 7)\n        self.compute_bands_btn.setEnabled(\n            False\n        )  # Disabled until path has at least two points\n\n        kpoints_layout.addWidget(QLabel(\"Points:\"))\n        kpoints_layout.addWidget(self.n_points_spinbox)\n        self.bands_grid.addLayout(kpoints_layout, 2, 5, 1, 3)\n\n        self.bands_grid.setVerticalSpacing(5)\n        self.bands_grid.setHorizontalSpacing(5)\n\n        # Initially disable all selection buttons\n        btns = [\n            self.add_gamma_btn,\n            self.prev_vertex_btn,\n            self.next_vertex_btn,\n            self.add_vertex_btn,\n            self.prev_edge_btn,\n            self.next_edge_btn,\n            self.add_edge_btn,\n            self.prev_face_btn,\n            self.next_face_btn,\n            self.add_face_btn,\n        ]\n        for btn in btns:\n            btn.setEnabled(False)\n\n        # Group buttons by type for easier controller access\n        self.vertex_btns = [\n            self.prev_vertex_btn,\n            self.next_vertex_btn,\n            self.add_vertex_btn,\n        ]\n        self.edge_btns = [\n            self.prev_edge_btn,\n            self.next_edge_btn,\n            self.add_edge_btn,\n        ]\n        self.face_btns = [\n            self.prev_face_btn,\n            self.next_face_btn,\n            self.add_face_btn,\n        ]\n\n        for row in range(4):  # Rows 0 to 4 in bands_grid\n            self.bands_grid.setRowMinimumHeight(row, 25)\n\n        # Approximate output size label\n        self.approximate_band_size = QLabel(\"Approximate output size: 0 kB\")\n        self.bands_grid.addWidget(self.approximate_band_size, 4, 0, 1, 8)\n\n        # Projection panel\n        projection_label = QLabel(\"State Projection\")\n        projection_label.setProperty(\"style\", \"bold\")\n        projection_label.setAlignment(Qt.AlignCenter)\n        projection_tools = QHBoxLayout()\n\n        self.proj_layout.setContentsMargins(10, 5, 15, 5)\n\n        self.proj_layout.addWidget(projection_label)\n        self.proj_layout.addLayout(projection_tools)\n\n        self.proj_combo = CheckableComboBox()\n        self.project_btn = QPushButton(\"Project\")\n        self.select_all_btn = QPushButton(\"All\")\n        self.select_all_btn.setToolTip(\"Select All\")\n        self.select_all_btn.setStatusTip(\"Select all States for Projection.\")\n        self.clear_all_btn = QPushButton(\"None\")\n        self.clear_all_btn.setToolTip(\"Clear Selection\")\n        self.clear_all_btn.setStatusTip(\"Deselect all States.\")\n        self.select_all_btn.setEnabled(False)\n        self.clear_all_btn.setEnabled(False)\n\n        proj_left = QVBoxLayout()\n        proj_right = QVBoxLayout()\n        proj_buttons = QHBoxLayout()\n\n        projection_tools.addLayout(proj_left, stretch=3)\n        projection_tools.addLayout(proj_right, stretch=1)\n\n        proj_left.addWidget(self.proj_combo)\n        proj_left.addLayout(proj_buttons)\n\n        proj_buttons.addWidget(self.select_all_btn)\n        proj_buttons.addWidget(self.clear_all_btn)\n\n        self.bands_radio = QRadioButton(\"Bands\")\n        self.dos_radio = QRadioButton(\"DOS\")\n\n        self.radio_group = QButtonGroup(self)\n        self.radio_group.addButton(self.bands_radio, id=0)\n        self.radio_group.addButton(self.dos_radio, id=1)\n        self.bands_radio.setChecked(True)\n\n        proj_right.addWidget(self.bands_radio)\n        proj_right.addWidget(self.dos_radio)\n\n        # DOS Section\n        self.bz_grid = QGridLayout()\n        self.dos_visualization_grid = QGridLayout()\n        self.dos_layout.addLayout(self.bz_grid)\n        self.dos_layout.addWidget(divider_line())\n        self.dos_layout.addLayout(self.dos_visualization_grid)\n        self.dos_layout.setContentsMargins(10, 5, 15, 5)\n\n        bz_grid_label = QLabel(\"Brillouin Zone Grid\")\n        bz_grid_label.setProperty(\"style\", \"bold\")\n        bz_grid_label.setAlignment(Qt.AlignCenter)\n        self.bz_grid.addWidget(bz_grid_label, 0, 0, 1, 4)\n\n        dos_presentation_label = QLabel(\"DOS Visualization\")\n        dos_presentation_label.setProperty(\"style\", \"bold\")\n        dos_presentation_label.setAlignment(Qt.AlignCenter)\n        self.dos_visualization_grid.addWidget(\n            dos_presentation_label, 0, 0, 1, 4\n        )\n\n        # Grid points controls\n        self.v1_points_spinbox = QSpinBox()\n        self.v2_points_spinbox = QSpinBox()\n        self.v3_points_spinbox = QSpinBox()\n        self.num_bins_spinbox = EnterKeyIntSpinBox()\n        self.broadening_spinbox = EnterKeySpinBox()\n\n        for b in [\n            self.v1_points_spinbox,\n            self.v2_points_spinbox,\n            self.v3_points_spinbox,\n        ]:\n            b.setRange(2, 200)\n            b.setValue(30)\n            set_spinbox_digit_width(b, 3)\n            b.setButtonSymbols(QSpinBox.NoButtons)\n            b.setEnabled(False)\n\n        self.num_bins_spinbox.setRange(2, 1000)\n        self.num_bins_spinbox.setValue(20)\n        self.num_bins_spinbox.setButtonSymbols(QSpinBox.NoButtons)\n        set_spinbox_digit_width(self.num_bins_spinbox, 5)\n\n        self.broadening_spinbox.setDecimals(3)\n        self.broadening_spinbox.setRange(0.001, 10.0)\n        self.broadening_spinbox.setValue(0.001)\n        self.broadening_spinbox.setButtonSymbols(QSpinBox.NoButtons)\n        set_spinbox_digit_width(self.broadening_spinbox, 5)\n\n        self.bz_grid.addWidget(QLabel(\"v&lt;sub&gt;1&lt;/sub&gt; points:\"), 1, 0)\n        self.bz_grid.addWidget(QLabel(\"v&lt;sub&gt;2&lt;/sub&gt; points:\"), 2, 0)\n        self.bz_grid.addWidget(QLabel(\"v&lt;sub&gt;3&lt;/sub&gt; points:\"), 3, 0)\n\n        self.bz_grid.addWidget(self.v1_points_spinbox, 1, 1)\n        self.bz_grid.addWidget(self.v2_points_spinbox, 2, 1)\n        self.bz_grid.addWidget(self.v3_points_spinbox, 3, 1)\n\n        # Approximate output size label\n        self.approximate_BZ_grid_size = QLabel(\"Approximate output size: 0 kB\")\n        self.bz_grid.addWidget(self.approximate_BZ_grid_size, 4, 0, 1, 4)\n\n        self.dos_visualization_grid.addWidget(QLabel(\"Bin number:\"), 1, 0)\n        self.dos_visualization_grid.addWidget(QLabel(\"Broadening:\"), 2, 0)\n\n        self.dos_visualization_grid.addWidget(self.num_bins_spinbox, 1, 1)\n        self.dos_visualization_grid.addWidget(self.broadening_spinbox, 2, 1)\n\n        self.compute_grid_btn = QPushButton()\n        self.compute_grid_btn.setIcon(compute_icon)\n        self.compute_grid_btn.setIconSize(icon_size)\n        self.compute_grid_btn.setToolTip(\"Compute\")\n        self.compute_grid_btn.setStatusTip(\"Compute the Brillouin Zone grid.\")\n        self.compute_grid_btn.setEnabled(False)\n\n        # Grid type choice\n        self.MP_radio = QRadioButton(\"Monkhorst-Pack\")\n        self.Gamma_radio = QRadioButton(\"\u0393-centered\")\n        self.grid_choice_group = QButtonGroup(self)\n        self.grid_choice_group.addButton(self.MP_radio, id=0)\n        self.grid_choice_group.addButton(self.Gamma_radio, id=1)\n        self.MP_radio.setChecked(True)\n\n        # DOS presentation choice\n        self.histogram_radio = QRadioButton(\"Histogram\")\n        self.lorentzian_radio = QRadioButton(\"Lorentzian\")\n        self.presentation_choice_group = QButtonGroup(self)\n        self.presentation_choice_group.addButton(self.histogram_radio, id=0)\n        self.presentation_choice_group.addButton(self.lorentzian_radio, id=1)\n        self.histogram_radio.setChecked(True)\n\n        self.bz_grid.addWidget(self.MP_radio, 1, 3)\n        self.bz_grid.addWidget(self.Gamma_radio, 2, 3)\n        self.bz_grid.addWidget(self.compute_grid_btn, 3, 3)\n\n        self.dos_visualization_grid.addWidget(self.histogram_radio, 1, 3)\n        self.dos_visualization_grid.addWidget(self.lorentzian_radio, 2, 3)\n\n        # Style the buttons\n        for btn in [\n            self.add_gamma_btn,\n            self.prev_vertex_btn,\n            self.next_vertex_btn,\n            self.add_vertex_btn,\n            self.prev_edge_btn,\n            self.next_edge_btn,\n            self.add_edge_btn,\n            self.prev_face_btn,\n            self.next_face_btn,\n            self.add_face_btn,\n            self.remove_last_btn,\n            self.clear_path_btn,\n            self.compute_bands_btn,\n            self.compute_grid_btn,\n        ]:\n            set_button_size(btn, \"compact\")\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.hopping_panel.HoppingMatrix","title":"<code>TiBi.views.panels.hopping_panel.HoppingMatrix</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A grid of buttons representing possible hopping connections between states.</p> <p>Each button in the grid represents a possible hopping between two states. The rows (columns) represent the destination (source) states. Buttons are colored differently based on whether a hopping exists or not, and whether the hopping is Hermitian.</p> Source code in <code>TiBi/views/panels/hopping_panel.py</code> <pre><code>class HoppingMatrix(QWidget):\n    \"\"\"\n    A grid of buttons representing possible hopping connections between states.\n\n    Each button in the grid represents a possible hopping between two states.\n    The rows (columns) represent the destination (source) states.\n    Buttons are colored differently based on whether a hopping exists or not,\n    and whether the hopping is Hermitian.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n\n        # Scrollable Area for Matrix\n        self.scroll_area = QScrollArea()\n        self.scroll_area.setWidgetResizable(True)\n\n        # Content widget for grid\n        self.content_widget = QWidget()\n        self.grid_layout = QGridLayout(self.content_widget)\n        self.grid_layout.setSpacing(3)\n\n        self.scroll_area.setWidget(self.content_widget)\n        self.scroll_area.setFrameStyle(QFrame.NoFrame)\n\n        title_label = QLabel(\"Coupling Matrix\")\n        title_label.setProperty(\"style\", \"bold\")\n        title_label.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)\n        title_label.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)\n        layout.addWidget(title_label)\n        layout.addWidget(self.scroll_area)\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.HoppingPanel","title":"<code>TiBi.views.panels.HoppingPanel</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>View for editing hopping parameters between quantum states.</p> <p>This widget combines two main components:</p> <ol> <li>A matrix grid where each button represents a possible hopping connection    between two states [rows (columns) are destination (target) states]</li> <li>A table for editing specific hopping parameters when a connection    is selected in the matrix</li> </ol> <p>The view uses a stacked widget approach to show different panels based on the current selection state (no unit cell, no states, or states selected).</p> <p>Attributes:</p> Name Type Description <code>matrix_panel</code> <code>HoppingMatrix</code> <p>The panel displaying the hopping matrix as a grid of buttons.</p> <code>table_panel</code> <code>HoppingTable</code> <p>The panel displaying the hopping parameters in a table format.</p> Source code in <code>TiBi/views/panels/hopping_panel.py</code> <pre><code>class HoppingPanel(QWidget):\n    \"\"\"\n    View for editing hopping parameters between quantum states.\n\n    This widget combines two main components:\n\n    1. A matrix grid where each button represents a possible hopping connection\n       between two states [rows (columns) are destination (target) states]\n    2. A table for editing specific hopping parameters when a connection\n       is selected in the matrix\n\n    The view uses a stacked widget approach to show different panels based on\n    the current selection state (no unit cell, no states, or states selected).\n\n    Attributes\n    ----------\n    matrix_panel : HoppingMatrix\n        The panel displaying the hopping matrix as a grid of buttons.\n    table_panel : HoppingTable\n        The panel displaying the hopping parameters in a table format.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # Initialize the panels\n        self.matrix_panel = HoppingMatrix()\n        self.table_panel = HoppingTable()\n\n        # Main layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(1, 1, 1, 1)\n\n        # Components\n        self.info_label = QLabel(\"Select a Unit Cell with States\")\n        self.info_label.setAlignment(Qt.AlignCenter)\n\n        self.table_info_label = QLabel(\"Select a matrix element to edit\")\n        self.table_info_label.setAlignment(Qt.AlignCenter)\n\n        # Main Panel\n        self.panel = QWidget()\n        panel_layout = QVBoxLayout(self.panel)\n\n        # A stack that hides the table if no state pair is selected\n        self.table_stack = QStackedWidget()\n        self.table_stack.addWidget(self.table_info_label)\n        self.table_stack.addWidget(self.table_panel)\n\n        panel_layout.addWidget(self.matrix_panel, stretch=3)\n        panel_layout.addWidget(self.table_stack, stretch=2)\n\n        # A stack that hides the main panel if no unit cell is selected or\n        # the selected unit cell has no states\n        self.panel_stack = QStackedWidget()\n        self.panel_stack.addWidget(self.info_label)\n        self.panel_stack.addWidget(self.panel)\n        layout.addWidget(self.panel_stack)\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.hopping_panel.HoppingTable","title":"<code>TiBi.views.panels.hopping_panel.HoppingTable</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A table containing hoppings between the selected states.</p> <p>Each row of the table describes a hopping and contains five columns. The first three columns provide the displacements from the origin site to the destination site in terms of the basis vectors. The last two columns are the real and imaginary parts of the hopping term, respectively.</p> Source code in <code>TiBi/views/panels/hopping_panel.py</code> <pre><code>class HoppingTable(QWidget):\n    \"\"\"\n    A table containing hoppings between the selected states.\n\n    Each row of the table describes a hopping and contains five columns.\n    The first three columns provide the displacements from the origin site\n    to the destination site in terms of the basis vectors. The last two\n    columns are the real and imaginary parts of the hopping term, respectively.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n\n        self.table_title = QLabel(\"\")\n        self.table_title.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)\n\n        # Table manipulation buttons on the right\n        table_buttons_layout = QVBoxLayout()\n\n        self.add_row_btn = QPushButton()\n        self.add_row_btn.setIcon(\n            QIcon(str(get_resource_path(\"assets/icons/plus_hopping.svg\")))\n        )\n        self.add_row_btn.setToolTip(\"New Hopping\")\n        self.add_row_btn.setStatusTip(\"Add a new hopping integral.\")\n\n        self.remove_row_btn = QPushButton()\n        self.remove_row_btn.setIcon(\n            QIcon(str(get_resource_path(\"assets/icons/trash_hopping.svg\")))\n        )\n        self.remove_row_btn.setToolTip(\"Delete Hopping\")\n        self.remove_row_btn.setStatusTip(\n            \"Delete the selected hopping integral.\"\n        )\n\n        self.save_btn = QPushButton()\n        self.save_btn.setIcon(\n            QIcon(str(get_resource_path(\"assets/icons/save_hopping.svg\")))\n        )\n        self.save_btn.setToolTip(\"Save Hoppings\")\n        self.save_btn.setStatusTip(\"Save the Hopping table.\")\n\n        table_buttons_layout.addWidget(self.add_row_btn)\n        table_buttons_layout.addWidget(self.remove_row_btn)\n        table_buttons_layout.addWidget(self.save_btn)\n\n        # Table for hopping details\n        self.hopping_table = QTableWidget(\n            0, 5\n        )  # 5 columns: d1, d2, d3, Re(amplitude), Im(amplitude)\n\n        headers = [\"d\u2081\", \"d\u2082\", \"d\u2083\", \"Re(t)\", \"Im(t)\"]\n        tooltips = [\n            \"Displacement along v\u2081\",\n            \"Displacement along v\u2082\",\n            \"Displacement along v\u2083\",\n            \"Real part\",\n            \"Imaginary part\",\n        ]\n        statustips = [\n            \"Number of v\u2081's from the origin site to the destination site\",\n            \"Number of v\u2082's from the origin site to the destination site\",\n            \"Number of v\u2083's from the origin site to the destination site\",\n            \"Real part of hopping amplitude\",\n            \"Imaginary part of hopping amplitude\",\n        ]\n\n        # Assign headers with tooltips\n        for i, (label, tip, status) in enumerate(\n            zip(headers, tooltips, statustips)\n        ):\n            item = QTableWidgetItem(label)\n            item.setToolTip(tip)\n            item.setStatusTip(status)\n            self.hopping_table.setHorizontalHeaderItem(i, item)\n\n        # Get font metrics for the spinbox's current font\n        font_metrics = QFontMetrics(self.hopping_table.font())\n\n        # Add some padding for margins, borders, and spin buttons\n        padding = 5  # Adjust as needed\n\n        col_widths = [\n            (font_metrics.horizontalAdvance(\"0\" * x) + padding)\n            for x in [3, 3, 3, 6, 6]  # d\u2081, d\u2082, d\u2083, Re(t), Im(t)\n        ]\n        for ii, width in enumerate(col_widths):\n            self.hopping_table.setColumnWidth(ii, width)\n        scrollbar_width = (\n            self.hopping_table.verticalScrollBar().sizeHint().width()\n        )\n\n        self.hopping_table.setFixedWidth(sum(col_widths) + 3 * scrollbar_width)\n        # Table and buttons layout\n        control_layout = QHBoxLayout()\n        control_layout.addWidget(self.hopping_table)\n        control_layout.addLayout(table_buttons_layout)\n\n        scroll_area = QScrollArea()\n        scroll_area.setWidgetResizable(True)\n        scroll_area.setWidget(self.table_title)\n        scroll_area.setFrameStyle(QFrame.NoFrame)\n        content_height = self.table_title.sizeHint().height()\n        scroll_area.setMaximumHeight(content_height + 20)\n\n        layout.addWidget(scroll_area)\n        layout.addLayout(control_layout)\n        # Format the buttons\n        icon_size = QSize(20, 20)\n        for btn in [\n            self.add_row_btn,\n            self.remove_row_btn,\n            self.save_btn,\n        ]:\n            set_button_size(btn, \"compact\")\n            btn.setIconSize(icon_size)\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.SitePanel","title":"<code>TiBi.views.panels.SitePanel</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Form panel for editing site properties.</p> <p>This panel provides a form interface for editing a site's properties:</p> <ul> <li>Radius for the site marker</li> <li>Color for the site marker</li> <li>Fractional coordinates (c1, c2, c3) within the unit cell</li> </ul> Source code in <code>TiBi/views/panels/site_panel.py</code> <pre><code>class SitePanel(QWidget):\n    \"\"\"\n    Form panel for editing site properties.\n\n    This panel provides a form interface for editing a site's properties:\n\n    - Radius for the site marker\n    - Color for the site marker\n    - Fractional coordinates (c1, c2, c3) within the unit cell\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Main layout\n        layout = QVBoxLayout(self)\n\n        panel_header = QLabel(\"Site Parameters\")\n        panel_header.setProperty(\"style\", \"bold\")\n        panel_header.setAlignment(Qt.AlignCenter)\n\n        header = QLabel(\"Site Coordinates\")\n        header.setAlignment(Qt.AlignCenter)\n\n        # Coordinate and radius fields\n        self.R = EnterKeySpinBox()\n        self.c1 = EnterKeySpinBox()\n        self.c2 = EnterKeySpinBox()\n        self.c3 = EnterKeySpinBox()\n\n        for c in [self.R, self.c1, self.c2, self.c3]:\n            c.setRange(0.0, 1.0)\n            c.setDecimals(3)\n            c.setButtonSymbols(EnterKeySpinBox.NoButtons)\n            set_spinbox_digit_width(c, 5)\n\n        # Color picker button\n        self.color_picker_btn = QPushButton()\n        self.color_picker_btn.setFixedWidth(25)\n\n        appearance_layout = QHBoxLayout()\n        appearance_layout.addWidget(QLabel(\"Radius:\"))\n        appearance_layout.addWidget(self.R)\n        appearance_layout.addWidget(QLabel(\"Color:\"))\n        appearance_layout.addWidget(self.color_picker_btn)\n\n        # Create a grid layout with labels on top and spin boxes below\n        c1_label = QLabel(\"c&lt;sub&gt;1&lt;/sub&gt;\")\n        c1_label.setAlignment(Qt.AlignCenter)\n        c2_label = QLabel(\"c&lt;sub&gt;2&lt;/sub&gt;\")\n        c2_label.setAlignment(Qt.AlignCenter)\n        c3_label = QLabel(\"c&lt;sub&gt;3&lt;/sub&gt;\")\n        c3_label.setAlignment(Qt.AlignCenter)\n\n        grid_layout = QGridLayout()\n        grid_layout.addWidget(c1_label, 1, 0)\n        grid_layout.addWidget(c2_label, 1, 1)\n        grid_layout.addWidget(c3_label, 1, 2)\n\n        grid_layout.addWidget(self.c1, 2, 0)\n        grid_layout.addWidget(self.c2, 2, 1)\n        grid_layout.addWidget(self.c3, 2, 2)\n        grid_layout.setVerticalSpacing(2)\n\n        layout.addWidget(panel_header)\n        layout.addLayout(appearance_layout)\n        layout.addWidget(header)\n        layout.addLayout(grid_layout)\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.tree_view_panel.TreeDelegate","title":"<code>TiBi.views.panels.tree_view_panel.TreeDelegate</code>","text":"<p>               Bases: <code>QStyledItemDelegate</code></p> <p>A custom item delegate for the <code>SystemTree</code> widget.</p> <p>This delegate requires the user to commit changes to tree item names by pressing \"Enter\". Clicking away/defocusing resets the tree item name to its pre-edit form. The purpose is to handle the Qt default behavior, where defocusing keeps the new display name in the tree but does not send an updated signal so that the data can be updated internally. Additionally, the delegate draws rectangular \"Delete\" and \"Add\" buttons next to the item names.</p> <p>Attributes:</p> Name Type Description <code>name_edit_finished</code> <code>Signal(object)</code> <p>Emitted when the user finishes editing an item name.</p> <code>new_unit_cell_requested</code> <code>Signal</code> <p>Emitted when the user clicks the \"Add Unit Cell\" button.</p> <code>new_site_requested</code> <code>Signal</code> <p>Emitted when the user adds a new <code>Site</code>.</p> <code>new_state_requested</code> <code>Signal</code> <p>Emitted when the user adds a new <code>State</code>.</p> <code>delete_requested</code> <code>Signal</code> <p>Emitted when the user clicks the \"Delete\" button next to an item.</p> Source code in <code>TiBi/views/panels/tree_view_panel.py</code> <pre><code>class TreeDelegate(QStyledItemDelegate):\n    \"\"\"\n    A custom item delegate for the `SystemTree` widget.\n\n    This delegate requires the user to commit changes to tree item names by\n    pressing \"Enter\". Clicking away/defocusing resets the tree item name to\n    its pre-edit form. The purpose is to handle the Qt default behavior,\n    where defocusing keeps the new display name in the tree but does not send\n    an updated signal so that the data can be updated internally.\n    Additionally, the delegate draws rectangular \"Delete\" and \"Add\" buttons\n    next to the item names.\n\n    Attributes\n    ----------\n    name_edit_finished : Signal(object)\n        Emitted when the user finishes editing an item name.\n    new_unit_cell_requested : Signal\n        Emitted when the user clicks the \"Add Unit Cell\" button.\n    new_site_requested : Signal\n        Emitted when the user adds a new `Site`.\n    new_state_requested : Signal\n        Emitted when the user adds a new `State`.\n    delete_requested : Signal\n        Emitted when the user clicks the \"Delete\" button next to an item.\n    \"\"\"\n\n    name_edit_finished = Signal(object)  # Emits QModelIndex\n    new_unit_cell_requested = Signal()\n    new_site_requested = Signal()\n    new_state_requested = Signal()\n    delete_requested = Signal()\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self._editing_index = None\n        self.delete_renderer = QSvgRenderer(\n            str(get_resource_path(\"assets/icons/trash.svg\"))\n        )\n        self.add_renderer = QSvgRenderer(\n            str(get_resource_path(\"assets/icons/plus.svg\"))\n        )\n\n    def _button_rects(self, option, index):\n        \"\"\"Regions defining the item buttons.\"\"\"\n        size = 16\n        margin = 4\n        right = option.rect.right() - margin\n\n        buttons = {}\n        buttons[\"delete\"] = QRect(\n            right - size, option.rect.center().y() - size // 2, size, size\n        )\n        if self._get_item_level(index) &lt; 2:\n            buttons[\"add\"] = QRect(\n                right - 2 * size - margin,\n                option.rect.center().y() - size // 2,\n                size,\n                size,\n            )\n        return buttons\n\n    def _get_item_level(self, index):\n        \"\"\"\n        Determine the tree level of the item (0=UnitCell, 1=Site, 2=State)\n        \"\"\"\n        level = 0\n        current = index\n        while current.parent().isValid():\n            level += 1\n            current = current.parent()\n        return level\n\n    def createEditor(self, parent, option, index):\n        editor = super().createEditor(parent, option, index)\n        editor.setProperty(\n            \"originalText\", index.data()\n        )  # Save the original name\n        self._editing_index = index\n        return editor\n\n    def paint(self, painter, option, index):\n        if index.data(Qt.UserRole) == \"ADD_UNIT_CELL\":\n            # Custom paint for \"Add Unit Cell\" item\n            painter.save()\n            # Get the full width of the viewport (the whole row)\n            tree = self.parent()\n            full_rect = QRect(\n                0,\n                option.rect.y(),\n                tree.viewport().width(),\n                option.rect.height(),\n            )\n\n            # Draw background across the full width\n            painter.fillRect(\n                full_rect,\n                QColor(*hex_to_rgb(THEME_SETTINGS[\"PRIMARY_HEX\"])),\n            )\n\n            # Text formatting\n            painter.setPen(QColor(*hex_to_rgb(THEME_SETTINGS[\"ON_PRIMARY\"])))\n            font = painter.font()\n            painter.setFont(font)\n\n            # Adjust text inside the original rect (with padding)\n            text_rect = option.rect.adjusted(8, 0, -8, 0)\n            painter.drawText(text_rect, Qt.AlignVCenter, \"+ Add Unit Cell\")\n\n            painter.restore()\n\n        else:\n            super().paint(painter, option, index)\n            # Only show the delete icon for selected items\n            if option.state &amp; QStyle.State_Selected:\n                rects = self._button_rects(option, index)\n                self.delete_renderer.render(painter, rects[\"delete\"])\n                if \"add\" in rects:\n                    # painter.drawPixmap(rects[\"add\"], self.add_icon)\n                    self.add_renderer.render(painter, rects[\"add\"])\n\n    def editorEvent(self, event, model, option, index):\n        # Handle special \"Add Unit Cell\" item\n        if index.data(Qt.UserRole) == \"ADD_UNIT_CELL\":\n            if event.type() == QEvent.MouseButtonRelease:\n                if option.rect.contains(event.pos()):\n                    self.new_unit_cell_requested.emit()\n                    return True\n            return False\n\n        rects = self._button_rects(option, index)\n\n        if event.type() == QEvent.MouseButtonPress:\n            # Store whether the item was selected before this click\n            self._was_selected_before_click = (\n                self.parent().selectionModel().isSelected(index)\n            )\n            return super().editorEvent(event, model, option, index)\n\n        elif event.type() == QEvent.MouseButtonRelease:\n            if rects[\"delete\"].contains(event.pos()):\n                # Only trigger delete if the item was already selected\n                if self._was_selected_before_click:\n                    self.delete_requested.emit()\n                    return True\n                # If it wasn't selected before, the click selects the item\n                return False\n            elif (\"add\" in rects) and rects[\"add\"].contains(event.pos()):\n                # Only trigger delete if the item was already selected\n                if self._was_selected_before_click:\n                    if self._get_item_level(index) == 0:\n                        self.new_site_requested.emit()\n                    elif self._get_item_level(index) == 1:\n                        self.new_state_requested.emit()\n                    return True\n                return False\n        return super().editorEvent(event, model, option, index)\n\n    def eventFilter(self, editor, event):\n        if event.type() == QEvent.FocusOut:\n            # Restore original text on focus loss (cancel edit)\n            editor.blockSignals(True)\n            editor.setText(editor.property(\"originalText\"))\n            editor.blockSignals(False)\n            self.closeEditor.emit(editor, QStyledItemDelegate.RevertModelCache)\n            return True\n\n        if event.type() == QEvent.KeyPress and event.key() in (\n            Qt.Key_Return,\n            Qt.Key_Enter,\n        ):\n            # User manually pressed Enter or Return \u2014 accept the edit\n            self.commitData.emit(editor)\n            self.closeEditor.emit(editor, QStyledItemDelegate.NoHint)\n            if self._editing_index is not None:\n                self.name_edit_finished.emit(self._editing_index)\n                self._editing_index = None\n            return True\n\n        return super().eventFilter(editor, event)\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.TreeViewPanel","title":"<code>TiBi.views.panels.TreeViewPanel</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Tree view panel for displaying and selecting the unit cell hierarchy.</p> <p>This panel displays a hierarchical tree showing <code>UnitCell</code>s, their <code>Site</code>s, and the <code>State</code>s at each <code>Site</code>. It handles selection events and emits signals when different types of nodes are selected, allowing other components to respond appropriately.</p> <p>The tree has three levels:</p> <ol> <li><code>UnitCell</code>s</li> <li><code>Sites</code> within a <code>UnitCell</code></li> <li><code>State</code>s within a <code>Site</code></li> </ol> <p>Features:</p> <ul> <li>Hierarchical display of unit cells, sites, and states</li> <li>Single selection mode for focused editing</li> <li>Double-click to edit names directly in the tree</li> <li>Keyboard shortcuts for deletion (Del and Backspace)</li> <li>Signal emission on deletion requests</li> </ul> <p>Attributes:</p> Name Type Description <code>delegate</code> <code>TreeDelegate</code> <p>Custom tree delegate for handling item editing and button actions.</p> <code>tree_view</code> <code>SystemTree</code> <p>The tree view widget displaying the unit cell hierarchy.</p> <code>name_edit_finished</code> <code>Signal(object)</code> <p>Emitted when the user finishes editing an item name. Re-emitting signal from the <code>TreeDelegate</code>.`</p> <code>new_unit_cell_requested</code> <code>Signal</code> <p>Emitted when the user clicks the \"Add Unit Cell\" button. Re-emitting signal from the <code>TreeDelegate</code>.`</p> <code>new_site_requested</code> <code>Signal</code> <p>Emitted when the user adds a new <code>Site</code>. Re-emitting signal from the <code>TreeDelegate</code>.`</p> <code>new_state_requested</code> <code>Signal</code> <p>Emitted when the user adds a new <code>State</code>. Re-emitting signal from the <code>TreeDelegate</code>.`</p> <code>delete_requested</code> <code>Signal</code> <p>Emitted when the user presses the Delete/Backspace key. Also acts as a re-emitting signal for deletion requests from the <code>TreeDelegate</code>.</p> Source code in <code>TiBi/views/panels/tree_view_panel.py</code> <pre><code>class TreeViewPanel(QWidget):\n    \"\"\"\n    Tree view panel for displaying and selecting the unit cell hierarchy.\n\n    This panel displays a hierarchical tree showing `UnitCell`s, their `Site`s,\n    and the `State`s at each `Site`.\n    It handles selection events and emits signals when different types\n    of nodes are selected, allowing other components to respond appropriately.\n\n    The tree has three levels:\n\n    1. `UnitCell`s\n    2. `Sites` within a `UnitCell`\n    3. `State`s within a `Site`\n\n    Features:\n\n    - Hierarchical display of unit cells, sites, and states\n    - Single selection mode for focused editing\n    - Double-click to edit names directly in the tree\n    - Keyboard shortcuts for deletion (Del and Backspace)\n    - Signal emission on deletion requests\n\n    Attributes\n    ----------\n    delegate : TreeDelegate\n        Custom tree delegate for handling item editing and button actions.\n    tree_view : SystemTree\n        The tree view widget displaying the unit cell hierarchy.\n    name_edit_finished : Signal(object)\n        Emitted when the user finishes editing an item name.\n        Re-emitting signal from the `TreeDelegate`.`\n    new_unit_cell_requested : Signal\n        Emitted when the user clicks the \"Add Unit Cell\" button.\n        Re-emitting signal from the `TreeDelegate`.`\n    new_site_requested : Signal\n        Emitted when the user adds a new `Site`.\n        Re-emitting signal from the `TreeDelegate`.`\n    new_state_requested : Signal\n        Emitted when the user adds a new `State`.\n        Re-emitting signal from the `TreeDelegate`.`\n    delete_requested : Signal\n        Emitted when the user presses the Delete/Backspace key.\n        Also acts as a re-emitting signal for deletion requests\n        from the `TreeDelegate`.\n    \"\"\"\n\n    # Define signals\n    name_edit_finished = Signal(object)  # Emits QModelIndex\n    new_unit_cell_requested = Signal()\n    new_site_requested = Signal()\n    new_state_requested = Signal()\n    delete_requested = Signal()\n\n    def __init__(self):\n        super().__init__()\n\n        # Create and configure tree view\n        self.tree_view = SystemTree()\n\n        # Set the delegate to save the data only on Enter-press\n        self.delegate = TreeDelegate(self.tree_view)\n        self.tree_view.setItemDelegate(self.delegate)\n\n        # Layout\n        layout = QVBoxLayout(self)\n        layout.addWidget(self.tree_view)\n\n        # Set up Delete shortcut\n        self.delete_shortcut = QShortcut(QKeySequence(\"Del\"), self.tree_view)\n        self.delete_shortcut.activated.connect(\n            lambda: self.delete_requested.emit()\n        )\n\n        # Add Backspace as an alternative shortcut\n        self.backspace_shortcut = QShortcut(\n            QKeySequence(\"Backspace\"), self.tree_view\n        )\n        self.backspace_shortcut.activated.connect(\n            lambda: self.delete_requested.emit()\n        )\n\n        # Relay delegate signals\n        self.delegate.delete_requested.connect(\n            lambda: QTimer.singleShot(0, lambda: self.delete_requested.emit())\n        )\n        self.delegate.new_unit_cell_requested.connect(\n            lambda: QTimer.singleShot(\n                0, lambda: self.new_unit_cell_requested.emit()\n            )\n        )\n        self.delegate.new_site_requested.connect(\n            lambda: QTimer.singleShot(\n                0, lambda: self.new_site_requested.emit()\n            )\n        )\n        self.delegate.new_state_requested.connect(\n            lambda: QTimer.singleShot(\n                0, lambda: self.new_state_requested.emit()\n            )\n        )\n        self.delegate.name_edit_finished.connect(\n            lambda x: QTimer.singleShot(\n                0, lambda x=x: self.name_edit_finished.emit(x)\n            )\n        )\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.UnitCellPanel","title":"<code>TiBi.views.panels.UnitCellPanel</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Form panel for editing unit cell properties.</p> <p>This panel provides a form interface for editing a unit cell's properties:</p> <ul> <li>System dimensionality</li> <li>Three basis vectors (v1, v2, v3) with x, y, z components</li> </ul> <p>Methods:</p> Name Description <code>set_basis_vectors</code> <p>Set the basis vectors in the UI.</p> Source code in <code>TiBi/views/panels/unit_cell_panel.py</code> <pre><code>class UnitCellPanel(QWidget):\n    \"\"\"\n    Form panel for editing unit cell properties.\n\n    This panel provides a form interface for editing a unit cell's properties:\n\n    - System dimensionality\n    - Three basis vectors (v1, v2, v3) with x, y, z components\n\n    Methods\n    -------\n    set_basis_vectors(v1: BasisVector, v2: BasisVector, v3: BasisVector)\n        Set the basis vectors in the UI.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Main layout\n        layout = QVBoxLayout(self)\n\n        # Layout for basis vectors\n        grid_layout = QGridLayout()\n\n        panel_header = QLabel(\"Unit Cell Parameters\")\n        panel_header.setProperty(\"style\", \"bold\")\n        panel_header.setAlignment(Qt.AlignCenter)\n\n        dimensionality_header = QLabel(\"Dimensionality\")\n        dimensionality_header.setAlignment(Qt.AlignCenter)\n\n        basis_header = QLabel(\"Basis Vectors\")\n        basis_header.setAlignment(Qt.AlignCenter)\n\n        # Dimensionality radio buttons\n        self.radio0D = QRadioButton(\"0\")\n        self.radio1D = QRadioButton(\"1\")\n        self.radio2D = QRadioButton(\"2\")\n        self.radio3D = QRadioButton(\"3\")\n\n        self.radio_group = QButtonGroup(self)\n        self.radio_group.addButton(self.radio0D, id=0)\n        self.radio_group.addButton(self.radio1D, id=1)\n        self.radio_group.addButton(self.radio2D, id=2)\n        self.radio_group.addButton(self.radio3D, id=3)\n\n        radio_layout = QHBoxLayout()\n        radio_layout.addWidget(self.radio0D)\n        radio_layout.addWidget(self.radio1D)\n        radio_layout.addWidget(self.radio2D)\n        radio_layout.addWidget(self.radio3D)\n\n        # Add Site and Reduce UC (LLL algorithm) buttons\n        self.reduce_btn = QPushButton()\n        self.reduce_btn.setToolTip(\"Reduce Unit Cell\")\n        self.reduce_btn.setStatusTip(\n            \"Reduce Unit Cell basis using Lenstra\u2013Lenstra\u2013Lov\u00e1sz algorithm\"\n        )\n        set_button_size(self.reduce_btn, \"small\")\n\n        # Assemble the panel\n        layout.addWidget(panel_header)\n        layout.addWidget(dimensionality_header)\n        layout.addLayout(radio_layout)\n        layout.addLayout(grid_layout)\n\n        # Populate the basis vector grid\n        grid_layout.addWidget(basis_header, 0, 0, 1, 4)\n        grid_layout.addWidget(self.reduce_btn, 1, 0)\n        self.reduce_btn.setIcon(\n            QIcon(str(get_resource_path(\"assets/icons/grid.svg\")))\n        )\n\n        # Function to create a row with (x, y, z) input fields\n        def create_vector_column(n):\n            x = EnterKeySpinBox()\n            y = EnterKeySpinBox()\n            z = EnterKeySpinBox()\n\n            for coord in [x, y, z]:\n                coord.setButtonSymbols(EnterKeySpinBox.NoButtons)\n                coord.setRange(-1e308, 1e308)\n                set_spinbox_digit_width(coord, 5)\n                coord.setDecimals(3)\n\n            # Vector components are stacked vertically\n            grid_layout.addWidget(x, 2, n)\n            grid_layout.addWidget(y, 3, n)\n            grid_layout.addWidget(z, 4, n)\n            return (x, y, z)\n\n        # Create vector input columns\n        self.v1 = create_vector_column(1)\n        self.v2 = create_vector_column(2)\n        self.v3 = create_vector_column(3)\n\n        # Vector labels go above the coordinate columns\n        v1_label = QLabel(\"v&lt;sub&gt;1&lt;/sub&gt;\")\n        v1_label.setAlignment(Qt.AlignCenter)\n        v2_label = QLabel(\"v&lt;sub&gt;2&lt;/sub&gt;\")\n        v2_label.setAlignment(Qt.AlignCenter)\n        v3_label = QLabel(\"v&lt;sub&gt;3&lt;/sub&gt;\")\n        v3_label.setAlignment(Qt.AlignCenter)\n\n        grid_layout.addWidget(v1_label, 1, 1)\n        grid_layout.addWidget(v2_label, 1, 2)\n        grid_layout.addWidget(v3_label, 1, 3)\n\n        # Create a coordinate label column to the left of coordinate columns\n        for ii, (text, color) in enumerate(\n            zip([\"x\", \"y\", \"z\"], [CF_VERMILLION, CF_GREEN, CF_SKY]), start=1\n        ):\n            label = QLabel(text)\n            label.setAlignment(Qt.AlignCenter)\n            c = (\n                int(color[0] * 255),\n                int(color[1] * 255),\n                int(color[2] * 255),\n                int(color[3]),\n            )  # Color in 0-255 component range\n            label.setStyleSheet(f\"color: rgba({c[0]},{c[1]},{c[2]},{c[3]});\")\n            grid_layout.addWidget(label, 1 + ii, 0)\n\n        grid_layout.setVerticalSpacing(2)\n        grid_layout.setColumnStretch(0, 0)\n        grid_layout.setColumnStretch(1, 1)\n        grid_layout.setColumnStretch(2, 1)\n        grid_layout.setColumnStretch(3, 1)\n\n    def set_basis_vectors(\n        self, v1: BasisVector, v2: BasisVector, v3: BasisVector\n    ) -&gt; None:\n        \"\"\"\n        Set the basis vectors in the UI.\n\n        Parameters\n        ----------\n        v1 : BasisVector\n            Basis vector 1.\n        v2 : BasisVector\n            Basis vector 2.\n        v3 : BasisVector\n            Basis vector 3.\n        \"\"\"\n        for ii, coord in enumerate(\"xyz\"):\n            self.v1[ii].setValue(getattr(v1, coord))\n            self.v2[ii].setValue(getattr(v2, coord))\n            self.v3[ii].setValue(getattr(v3, coord))\n</code></pre>"},{"location":"dev/views/#TiBi.views.panels.UnitCellPanel.set_basis_vectors","title":"<code>set_basis_vectors(v1, v2, v3)</code>","text":"<p>Set the basis vectors in the UI.</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>BasisVector</code> <p>Basis vector 1.</p> required <code>v2</code> <code>BasisVector</code> <p>Basis vector 2.</p> required <code>v3</code> <code>BasisVector</code> <p>Basis vector 3.</p> required Source code in <code>TiBi/views/panels/unit_cell_panel.py</code> <pre><code>def set_basis_vectors(\n    self, v1: BasisVector, v2: BasisVector, v3: BasisVector\n) -&gt; None:\n    \"\"\"\n    Set the basis vectors in the UI.\n\n    Parameters\n    ----------\n    v1 : BasisVector\n        Basis vector 1.\n    v2 : BasisVector\n        Basis vector 2.\n    v3 : BasisVector\n        Basis vector 3.\n    \"\"\"\n    for ii, coord in enumerate(\"xyz\"):\n        self.v1[ii].setValue(getattr(v1, coord))\n        self.v2[ii].setValue(getattr(v2, coord))\n        self.v3[ii].setValue(getattr(v3, coord))\n</code></pre>"},{"location":"dev/views/#ui-widgets","title":"UI Widgets","text":""},{"location":"dev/views/#TiBi.views.widgets.CheckableComboBox","title":"<code>TiBi.views.widgets.CheckableComboBox</code>","text":"<p>               Bases: <code>QComboBox</code></p> <p>Drop-down box that supports multiple selections.</p> <p>Selected items are denoted by ticks.</p> <p>Attributes:</p> Name Type Description <code>selection_changed</code> <code>Signal(object)</code> <p>Emitted when the selection changes. Even if multiple items are selected/deselected, the signal is emitted once. The signal carries a list of indices of the selected items.</p> <p>Methods:</p> Name Description <code>checked_items</code> <p>Get the indices of the selected items.</p> <code>clear_selection</code> <p>Deselect all items.</p> <code>refresh_combo</code> <p>Reset the menu with a new list of items.</p> <code>select_all</code> <p>Select all items.</p> Source code in <code>TiBi/views/widgets/checkable_combo_box.py</code> <pre><code>class CheckableComboBox(QComboBox):\n    \"\"\"\n    Drop-down box that supports multiple selections.\n\n    Selected items are denoted by ticks.\n\n    Attributes\n    ----------\n    selection_changed : Signal(object)\n        Emitted when the selection changes. Even if multiple items\n        are selected/deselected, the signal is emitted once. The signal\n        carries a list of indices of the selected items.\n\n    Methods\n    -------\n    checked_items\n        Get the indices of the selected items.\n    clear_selection\n        Deselect all items.\n    refresh_combo(list[str])\n        Reset the menu with a new list of items.\n    select_all\n        Select all items.\n    \"\"\"\n\n    selection_changed = Signal(object)\n\n    def __init__(self):\n        super().__init__()\n        # Create model\n        self.combo_model = QStandardItemModel()\n        # Set model to view\n        self.setModel(self.combo_model)\n        self.combo_model.itemChanged.connect(\n            lambda _: self.selection_changed.emit(self.checked_items())\n        )\n\n    def refresh_combo(self, items: list[str]):\n        \"\"\"\n        Reset the combo box with a new list of items.\n\n        Parameters\n        ----------\n        items : list[str]\n            New list of items to be added to the menu.\n        \"\"\"\n        self.combo_model.clear()\n        for idx in range(len(items)):\n            # for text in items:\n            text = items[idx]\n            item = QStandardItem(text)\n            item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)\n            item.setData(Qt.Checked, Qt.CheckStateRole)\n            item.setData(idx, Qt.UserRole)\n            self.combo_model.appendRow(item)\n        self.selection_changed.emit(self.checked_items())\n\n    def checked_items(self):\n        \"\"\"\n        Get the indices of the selected items.\n\n        Returns\n        -------\n        result : list[int]\n            List of indices of selected items\n        \"\"\"\n        result = []\n        for ii in range(self.combo_model.rowCount()):\n            item = self.combo_model.item(ii)\n            if item.checkState() == Qt.Checked:\n                result.append(item.data(Qt.UserRole))\n        return result\n\n    def clear_selection(self):\n        \"\"\"\n        Deselect all items.\n        \"\"\"\n        self.combo_model.blockSignals(True)\n        for ii in range(self.combo_model.rowCount()):\n            item = self.combo_model.item(ii)\n            item.setData(Qt.Unchecked, Qt.CheckStateRole)\n        self.combo_model.blockSignals(False)\n        self.selection_changed.emit(self.checked_items())\n\n    def select_all(self):\n        \"\"\"\n        Select all items.\n        \"\"\"\n        self.combo_model.blockSignals(True)\n        for ii in range(self.combo_model.rowCount()):\n            item = self.combo_model.item(ii)\n            item.setData(Qt.Checked, Qt.CheckStateRole)\n        self.combo_model.blockSignals(False)\n        self.selection_changed.emit(self.checked_items())\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.CheckableComboBox.checked_items","title":"<code>checked_items()</code>","text":"<p>Get the indices of the selected items.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>list[int]</code> <p>List of indices of selected items</p> Source code in <code>TiBi/views/widgets/checkable_combo_box.py</code> <pre><code>def checked_items(self):\n    \"\"\"\n    Get the indices of the selected items.\n\n    Returns\n    -------\n    result : list[int]\n        List of indices of selected items\n    \"\"\"\n    result = []\n    for ii in range(self.combo_model.rowCount()):\n        item = self.combo_model.item(ii)\n        if item.checkState() == Qt.Checked:\n            result.append(item.data(Qt.UserRole))\n    return result\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.CheckableComboBox.clear_selection","title":"<code>clear_selection()</code>","text":"<p>Deselect all items.</p> Source code in <code>TiBi/views/widgets/checkable_combo_box.py</code> <pre><code>def clear_selection(self):\n    \"\"\"\n    Deselect all items.\n    \"\"\"\n    self.combo_model.blockSignals(True)\n    for ii in range(self.combo_model.rowCount()):\n        item = self.combo_model.item(ii)\n        item.setData(Qt.Unchecked, Qt.CheckStateRole)\n    self.combo_model.blockSignals(False)\n    self.selection_changed.emit(self.checked_items())\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.CheckableComboBox.refresh_combo","title":"<code>refresh_combo(items)</code>","text":"<p>Reset the combo box with a new list of items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[str]</code> <p>New list of items to be added to the menu.</p> required Source code in <code>TiBi/views/widgets/checkable_combo_box.py</code> <pre><code>def refresh_combo(self, items: list[str]):\n    \"\"\"\n    Reset the combo box with a new list of items.\n\n    Parameters\n    ----------\n    items : list[str]\n        New list of items to be added to the menu.\n    \"\"\"\n    self.combo_model.clear()\n    for idx in range(len(items)):\n        # for text in items:\n        text = items[idx]\n        item = QStandardItem(text)\n        item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)\n        item.setData(Qt.Checked, Qt.CheckStateRole)\n        item.setData(idx, Qt.UserRole)\n        self.combo_model.appendRow(item)\n    self.selection_changed.emit(self.checked_items())\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.CheckableComboBox.select_all","title":"<code>select_all()</code>","text":"<p>Select all items.</p> Source code in <code>TiBi/views/widgets/checkable_combo_box.py</code> <pre><code>def select_all(self):\n    \"\"\"\n    Select all items.\n    \"\"\"\n    self.combo_model.blockSignals(True)\n    for ii in range(self.combo_model.rowCount()):\n        item = self.combo_model.item(ii)\n        item.setData(Qt.Checked, Qt.CheckStateRole)\n    self.combo_model.blockSignals(False)\n    self.selection_changed.emit(self.checked_items())\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.EnterKeyIntSpinBox","title":"<code>TiBi.views.widgets.EnterKeyIntSpinBox</code>","text":"<p>               Bases: <code>QSpinBox</code></p> <p>Custom <code>QSpinBox</code> that emits a signal when the Enter key is pressed.</p> <p>On defocus, the value is reset to the original value and no signal is emitted.</p> <p>Attributes:</p> Name Type Description <code>editingConfirmed</code> <code>Signal</code> <p>Signal emitted when the Enter key is pressed and the value has changed.</p> Source code in <code>TiBi/views/widgets/enter_key_int_spin_box.py</code> <pre><code>class EnterKeyIntSpinBox(QSpinBox):\n    \"\"\"\n    Custom `QSpinBox` that emits a signal when the Enter key is pressed.\n\n    On defocus, the value is reset to the original value and no signal\n    is emitted.\n\n    Attributes\n    ----------\n    editingConfirmed : Signal\n        Signal emitted when the Enter key is pressed and the value has changed.\n    \"\"\"\n\n    editingConfirmed = Signal()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._original_value = self.value()\n\n    def focusInEvent(self, event):\n        self._original_value = self.value()\n        super().focusInEvent(event)\n\n    def focusOutEvent(self, event):\n        # Revert to original value on focus out\n        self.blockSignals(True)\n        self.setValue(self._original_value)\n        self.blockSignals(False)\n        super().focusOutEvent(event)\n\n    def keyPressEvent(self, event):\n        if event.key() in (Qt.Key_Enter, Qt.Key_Return):\n            # Emit signal only if the value has changed\n            if not np.isclose(self.value(), self._original_value):\n                self._original_value = self.value()\n                self.editingConfirmed.emit()\n        elif event.key() == Qt.Key_Escape:\n            self.blockSignals(True)\n            self.setValue(self._original_value)\n            self.blockSignals(False)\n        else:\n            super().keyPressEvent(event)\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.EnterKeySpinBox","title":"<code>TiBi.views.widgets.EnterKeySpinBox</code>","text":"<p>               Bases: <code>QDoubleSpinBox</code></p> <p>Custom <code>QDoubleSpinBox</code> that emits a signal when the Enter key is pressed.</p> <p>On defocus, the value is reset to the original value and no signal is emitted.</p> <p>Attributes:</p> Name Type Description <code>editingConfirmed</code> <code>Signal</code> <p>Signal emitted when the Enter key is pressed and the value has changed.</p> Source code in <code>TiBi/views/widgets/enter_key_spin_box.py</code> <pre><code>class EnterKeySpinBox(QDoubleSpinBox):\n    \"\"\"\n    Custom `QDoubleSpinBox` that emits a signal when the Enter key is pressed.\n\n    On defocus, the value is reset to the original value and no signal\n    is emitted.\n\n    Attributes\n    ----------\n    editingConfirmed : Signal\n        Signal emitted when the Enter key is pressed and the value has changed.\n    \"\"\"\n\n    editingConfirmed = Signal()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._original_value = self.value()\n\n    def focusInEvent(self, event):\n        self._original_value = self.value()\n        super().focusInEvent(event)\n\n    def focusOutEvent(self, event):\n        # Revert to original value on focus out\n        self.blockSignals(True)\n        self.setValue(self._original_value)\n        self.blockSignals(False)\n        super().focusOutEvent(event)\n\n    def keyPressEvent(self, event):\n        if event.key() in (Qt.Key_Enter, Qt.Key_Return):\n            # Emit signal only if the value has changed\n            if not np.isclose(self.value(), self._original_value):\n                self._original_value = self.value()\n                self.editingConfirmed.emit()\n        elif event.key() == Qt.Key_Escape:\n            self.blockSignals(True)\n            self.setValue(self._original_value)\n            self.blockSignals(False)\n        else:\n            super().keyPressEvent(event)\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.SystemTree","title":"<code>TiBi.views.widgets.SystemTree</code>","text":"<p>               Bases: <code>QTreeView</code></p> <p>Custom <code>QTreeViewtree</code>for displaying <code>UnitCell</code>s, <code>Site</code>s, and <code>State</code>s.</p> <p>This tree view is designed to show a hierarchical structure of <code>UnitCell</code>s, <code>Site</code>s, and <code>State</code>s. It allows for easy navigation and selection of these elements. The tree is built using a <code>QStandardItemModel</code>, and each item in the tree is represented by a <code>QStandardItem</code>. The tree supports single selection mode and can be edited by double-clicking on an item. The tree view emits a signal when the selection changes, providing information about the selected <code>UnitCell</code>, <code>Site</code>, and <code>State</code>.</p> <p>Attributes:</p> Name Type Description <code>tree_model</code> <code>QStandardItemModel</code> <p>The model used to populate the tree view.</p> <code>root_node</code> <code>QStandardItem</code> <p>The root item of the tree model, representing the tree's top level.</p> <code>tree_selection_changed</code> <code>Signal</code> <p>Emitted when the selection in the tree changes. The signal carries a dictionary with the selected <code>UnitCell</code>, <code>Site</code>, and <code>State</code> IDs.</p> <p>Methods:</p> Name Description <code>add_tree_item</code> <p>Add and select a tree item without rebuilding the entire tree.</p> <code>find_item_by_id</code> <p>Find a tree item by its ID.</p> <code>refresh_tree</code> <p>Rebuilds the entire tree from the current data model.</p> <code>remove_tree_item</code> <p>Remove an item from the tree.</p> Source code in <code>TiBi/views/widgets/system_tree.py</code> <pre><code>class SystemTree(QTreeView):\n    \"\"\"\n    Custom `QTreeViewtree`for displaying `UnitCell`s, `Site`s, and `State`s.\n\n    This tree view is designed to show a hierarchical structure of `UnitCell`s,\n    `Site`s, and `State`s. It allows for easy navigation and selection of these\n    elements. The tree is built using a `QStandardItemModel`, and each item\n    in the tree is represented by a `QStandardItem`. The tree supports\n    single selection mode and can be edited by double-clicking on an item.\n    The tree view emits a signal when the selection changes, providing\n    information about the selected `UnitCell`, `Site`, and `State`.\n\n    Attributes\n    ----------\n    tree_model : QStandardItemModel\n        The model used to populate the tree view.\n    root_node : QStandardItem\n        The root item of the tree model, representing the tree's top level.\n    tree_selection_changed : Signal\n        Emitted when the selection in the tree changes. The signal carries\n        a dictionary with the selected `UnitCell`, `Site`, and `State` IDs.\n\n    Methods\n    -------\n    add_tree_item(name, uc_id, site_id=None, state_id=None)\n        Add and select a tree item without rebuilding the entire tree.\n    find_item_by_id(self, uc_id, site_id=None, state_id=None)\n        Find a tree item by its ID.\n    refresh_tree(unit_cells: dict[uuid.UUID, UnitCell])\n        Rebuilds the entire tree from the current data model.\n    remove_tree_item(uc_id, site_id=None, state_id=None)\n        Remove an item from the tree.\n    \"\"\"\n\n    tree_selection_changed = Signal(object)\n\n    def __init__(self):\n        super().__init__()\n        self.setHeaderHidden(True)\n        self.setSelectionMode(QTreeView.SingleSelection)\n        self.setEditTriggers(QTreeView.DoubleClicked)\n\n        # Create model\n        self.tree_model = QStandardItemModel()\n        self.root_node = self.tree_model.invisibleRootItem()\n\n        # Set model to view\n        self.setModel(self.tree_model)\n\n        # Internal signals\n        self.selectionModel().selectionChanged.connect(\n            self._on_tree_selection_changed\n        )\n\n    def refresh_tree(self, unit_cells: dict[uuid.UUID, UnitCell]):\n        \"\"\"\n        Rebuild the entire tree from the current data model.\n\n        This method clears the existing tree and reconstructs it based on the\n        current state of the unit_cells dictionary. It creates a hierarchical\n        structure with three levels: unit cells, sites, and states.\n\n        Note: For better performance, prefer the more specific update methods:\n        - `add_tree_item()` - For adding or updating a single node\n        - `remove_tree_item()` - For removing a single node\n\n        This full refresh is typically only needed during initialization or\n        when multiple components of the tree need to be updated simultaneously.\n\n        Parameters\n        ----------\n        unit_cells : dict[uuid.UUID, UnitCell]\n            Dictionary of `UnitCells`s to be displayed in the tree.\n            The keys are UUIDs and the values are `UnitCell` objects.\n        \"\"\"\n        self.tree_model.clear()\n        self.root_node = self.tree_model.invisibleRootItem()\n\n        # Add special \"add\" item at the top\n        add_item = QStandardItem(\"+ Add Unit Cell\")\n        add_item.setData(\"ADD_UNIT_CELL\", Qt.UserRole)  # Special marker\n        add_item.setFlags(Qt.ItemIsEnabled)  # Not selectable, but clickable\n        self.root_node.appendRow(add_item)\n\n        # Add unit cells\n        for uc_id, unit_cell in unit_cells.items():\n            unit_cell_item = self._create_tree_item(\n                unit_cell.name, item_id=uc_id\n            )\n            self.root_node.appendRow(unit_cell_item)\n\n            # Add sites for this unit cell\n            for site_id, site in unit_cell.sites.items():\n                site_item = self._create_tree_item(site.name, item_id=site_id)\n                unit_cell_item.appendRow(site_item)\n\n                # Add states for this site\n                for state_id, state in site.states.items():\n                    state_item = self._create_tree_item(\n                        state.name, item_id=state_id\n                    )\n                    site_item.appendRow(state_item)\n\n    def _create_tree_item(\n        self, item_name: str, item_id: uuid.UUID\n    ) -&gt; QStandardItem:\n        \"\"\"\n        Create a `QStandardItem` for tree.\n\n        Parameters\n        ----------\n        item_name : str\n            Name of the item.\n        item_id : uuid.UUID\n            id of the item.\n\n        Returns\n        -------\n        QStandardItem\n            The new tree item.\n        \"\"\"\n        tree_item = QStandardItem(item_name)\n        tree_item.setData(item_id, Qt.UserRole)  # Store the ID\n\n        # Set other visual properties\n        tree_item.setEditable(True)\n\n        return tree_item\n\n    def find_item_by_id(\n        self, uc_id, site_id=None, state_id=None\n    ) -&gt; QStandardItem | None:\n        \"\"\"\n        Find a tree item by its ID.\n\n        Parameters\n        ----------\n        uc_id : uuid.UUID\n            id of the `UnitCell`\n        site_id : uuid.UUID, optional\n            id of the `Site`\n        state_id : uuid.UUID, optional\n            id of the `State`\n\n        Returns\n        -------\n        QStandardItem | None\n            The required item if found, `None` otherwise.\n        \"\"\"\n        if state_id is not None:\n            parent = self.find_item_by_id(uc_id, site_id)\n            item_id = state_id\n        elif site_id is not None:\n            parent = self.find_item_by_id(uc_id)\n            item_id = site_id\n        else:\n            parent = self.root_node\n            item_id = uc_id\n\n        for row in range(parent.rowCount()):\n            item = parent.child(row)\n            if item.data(Qt.UserRole) == item_id:\n                return item\n\n    def _select_item_by_id(self, uc_id, site_id=None, state_id=None) -&gt; None:\n        \"\"\"\n        Select a tree item programmatically by its ID.\n\n        Parameters\n        ----------\n        uc_id : uuid.UUID\n            id of the `UnitCell`\n        site_id : uuid.UUID, optional\n            id of the `Site`\n        state_id : uuid.UUID, optional\n            id of the `State`\n        \"\"\"\n        item = self.find_item_by_id(uc_id, site_id, state_id)\n        if item:\n            index = self.tree_model.indexFromItem(item)\n            self.selectionModel().setCurrentIndex(\n                index, QItemSelectionModel.ClearAndSelect\n            )\n\n    def add_tree_item(self, name, uc_id, site_id=None, state_id=None):\n        \"\"\"\n        Add and select a tree item without rebuilding the entire tree.\n\n        Parameters\n        ----------\n        uc_id : uuid.UUID\n            id of the `UnitCell`\n        site_id : uuid.UUID, optional\n            id of the `Site`\n        state_id : uuid.UUID, optional\n            id of the `State`\n        \"\"\"\n        if state_id is not None:  # Adding a state\n            parent = self.find_item_by_id(uc_id, site_id)\n            item_id = state_id\n        elif site_id is not None:  # Adding a site\n            parent = self.find_item_by_id(uc_id)\n            item_id = site_id\n        else:  # Adding a unit cell\n            parent = self.root_node\n            item_id = uc_id\n\n        item = self._create_tree_item(name, item_id=item_id)\n        parent.appendRow(item)\n        index = self.tree_model.indexFromItem(item)\n        self.selectionModel().setCurrentIndex(\n            index, QItemSelectionModel.ClearAndSelect\n        )\n\n    def remove_tree_item(self, uc_id, site_id=None, state_id=None):\n        \"\"\"\n        Remove an item from the tree.\n\n        If the item has a parent\n        (i.e., is not a `UnitCell`), select the parent. Otherwise,\n        clear the selection\n\n        Parameters\n        ----------\n        uc_id : uuid.UUID\n            id of the `UnitCell`\n        site_id : uuid.UUID, optional\n            id of the `Site`\n        state_id : uuid.UUID, optional\n            id of the `State`\n        \"\"\"\n        item = self.find_item_by_id(uc_id, site_id, state_id)\n        if item:\n            # If the item is a unit cell, the parent is None, so we\n            # default to the invisibleRootItem\n            parent = item.parent() or self.root_node\n            # If the item has a parent, select it\n            if item.parent():\n                index = self.tree_model.indexFromItem(parent)\n                self.selectionModel().setCurrentIndex(\n                    index, QItemSelectionModel.ClearAndSelect\n                )\n            # Otherwise, deselect everything (the item is a unit cell)\n            else:\n                self.selectionModel().clearSelection()\n                self.setCurrentIndex(QModelIndex())\n            # Delete the item\n            parent.removeRow(item.row())\n\n    def _on_tree_selection_changed(self, selected: QStandardItem, deselected):\n        \"\"\"\n        Handle the change of selection in the tree.\n\n        This method is called when the user selects a node in the tree view or\n        the selection occurs programmatically.\n        It determines what type of node was selected\n        (unit cell, site, or state) and emits a dictionary with\n        the item's id and, if applicable, its parent's/grandparent's id's.\n        The dictionary is then used to update the app's selection model.\n\n        Parameters\n        ----------\n        selected : QStandardItem\n            The newly selected item\n        deselected : QStandardItem\n            The previously selected items that are now deselected\n        \"\"\"\n        indexes = selected.indexes()\n\n        if not indexes:\n            new_selection = {\"unit_cell\": None, \"site\": None, \"state\": None}\n        else:\n            # Get the selected item\n            index = indexes[0]\n            item = self.tree_model.itemFromIndex(index)\n\n            item_id = item.data(Qt.UserRole)\n\n            if item.parent() is None:  # unit cell selected\n                new_selection = {\n                    \"unit_cell\": item_id,\n                    \"site\": None,\n                    \"state\": None,\n                }\n            elif item.parent().parent() is None:  # site selected\n                parent_item = item.parent()\n                parent_id = parent_item.data(Qt.UserRole)\n\n                new_selection = {\n                    \"unit_cell\": parent_id,\n                    \"site\": item_id,\n                    \"state\": None,\n                }\n            else:  # state selected\n                parent_item = item.parent()\n                parent_id = parent_item.data(Qt.UserRole)\n                grandparent_item = parent_item.parent()\n                grandparent_id = grandparent_item.data(Qt.UserRole)\n\n                new_selection = {\n                    \"unit_cell\": grandparent_id,\n                    \"site\": parent_id,\n                    \"state\": item_id,\n                }\n\n        self.tree_selection_changed.emit(new_selection)\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.SystemTree.add_tree_item","title":"<code>add_tree_item(name, uc_id, site_id=None, state_id=None)</code>","text":"<p>Add and select a tree item without rebuilding the entire tree.</p> <p>Parameters:</p> Name Type Description Default <code>uc_id</code> <code>UUID</code> <p>id of the <code>UnitCell</code></p> required <code>site_id</code> <code>UUID</code> <p>id of the <code>Site</code></p> <code>None</code> <code>state_id</code> <code>UUID</code> <p>id of the <code>State</code></p> <code>None</code> Source code in <code>TiBi/views/widgets/system_tree.py</code> <pre><code>def add_tree_item(self, name, uc_id, site_id=None, state_id=None):\n    \"\"\"\n    Add and select a tree item without rebuilding the entire tree.\n\n    Parameters\n    ----------\n    uc_id : uuid.UUID\n        id of the `UnitCell`\n    site_id : uuid.UUID, optional\n        id of the `Site`\n    state_id : uuid.UUID, optional\n        id of the `State`\n    \"\"\"\n    if state_id is not None:  # Adding a state\n        parent = self.find_item_by_id(uc_id, site_id)\n        item_id = state_id\n    elif site_id is not None:  # Adding a site\n        parent = self.find_item_by_id(uc_id)\n        item_id = site_id\n    else:  # Adding a unit cell\n        parent = self.root_node\n        item_id = uc_id\n\n    item = self._create_tree_item(name, item_id=item_id)\n    parent.appendRow(item)\n    index = self.tree_model.indexFromItem(item)\n    self.selectionModel().setCurrentIndex(\n        index, QItemSelectionModel.ClearAndSelect\n    )\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.SystemTree.find_item_by_id","title":"<code>find_item_by_id(uc_id, site_id=None, state_id=None)</code>","text":"<p>Find a tree item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>uc_id</code> <code>UUID</code> <p>id of the <code>UnitCell</code></p> required <code>site_id</code> <code>UUID</code> <p>id of the <code>Site</code></p> <code>None</code> <code>state_id</code> <code>UUID</code> <p>id of the <code>State</code></p> <code>None</code> <p>Returns:</p> Type Description <code>QStandardItem | None</code> <p>The required item if found, <code>None</code> otherwise.</p> Source code in <code>TiBi/views/widgets/system_tree.py</code> <pre><code>def find_item_by_id(\n    self, uc_id, site_id=None, state_id=None\n) -&gt; QStandardItem | None:\n    \"\"\"\n    Find a tree item by its ID.\n\n    Parameters\n    ----------\n    uc_id : uuid.UUID\n        id of the `UnitCell`\n    site_id : uuid.UUID, optional\n        id of the `Site`\n    state_id : uuid.UUID, optional\n        id of the `State`\n\n    Returns\n    -------\n    QStandardItem | None\n        The required item if found, `None` otherwise.\n    \"\"\"\n    if state_id is not None:\n        parent = self.find_item_by_id(uc_id, site_id)\n        item_id = state_id\n    elif site_id is not None:\n        parent = self.find_item_by_id(uc_id)\n        item_id = site_id\n    else:\n        parent = self.root_node\n        item_id = uc_id\n\n    for row in range(parent.rowCount()):\n        item = parent.child(row)\n        if item.data(Qt.UserRole) == item_id:\n            return item\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.SystemTree.refresh_tree","title":"<code>refresh_tree(unit_cells)</code>","text":"<p>Rebuild the entire tree from the current data model.</p> <p>This method clears the existing tree and reconstructs it based on the current state of the unit_cells dictionary. It creates a hierarchical structure with three levels: unit cells, sites, and states.</p> <p>Note: For better performance, prefer the more specific update methods: - <code>add_tree_item()</code> - For adding or updating a single node - <code>remove_tree_item()</code> - For removing a single node</p> <p>This full refresh is typically only needed during initialization or when multiple components of the tree need to be updated simultaneously.</p> <p>Parameters:</p> Name Type Description Default <code>unit_cells</code> <code>dict[UUID, UnitCell]</code> <p>Dictionary of <code>UnitCells</code>s to be displayed in the tree. The keys are UUIDs and the values are <code>UnitCell</code> objects.</p> required Source code in <code>TiBi/views/widgets/system_tree.py</code> <pre><code>def refresh_tree(self, unit_cells: dict[uuid.UUID, UnitCell]):\n    \"\"\"\n    Rebuild the entire tree from the current data model.\n\n    This method clears the existing tree and reconstructs it based on the\n    current state of the unit_cells dictionary. It creates a hierarchical\n    structure with three levels: unit cells, sites, and states.\n\n    Note: For better performance, prefer the more specific update methods:\n    - `add_tree_item()` - For adding or updating a single node\n    - `remove_tree_item()` - For removing a single node\n\n    This full refresh is typically only needed during initialization or\n    when multiple components of the tree need to be updated simultaneously.\n\n    Parameters\n    ----------\n    unit_cells : dict[uuid.UUID, UnitCell]\n        Dictionary of `UnitCells`s to be displayed in the tree.\n        The keys are UUIDs and the values are `UnitCell` objects.\n    \"\"\"\n    self.tree_model.clear()\n    self.root_node = self.tree_model.invisibleRootItem()\n\n    # Add special \"add\" item at the top\n    add_item = QStandardItem(\"+ Add Unit Cell\")\n    add_item.setData(\"ADD_UNIT_CELL\", Qt.UserRole)  # Special marker\n    add_item.setFlags(Qt.ItemIsEnabled)  # Not selectable, but clickable\n    self.root_node.appendRow(add_item)\n\n    # Add unit cells\n    for uc_id, unit_cell in unit_cells.items():\n        unit_cell_item = self._create_tree_item(\n            unit_cell.name, item_id=uc_id\n        )\n        self.root_node.appendRow(unit_cell_item)\n\n        # Add sites for this unit cell\n        for site_id, site in unit_cell.sites.items():\n            site_item = self._create_tree_item(site.name, item_id=site_id)\n            unit_cell_item.appendRow(site_item)\n\n            # Add states for this site\n            for state_id, state in site.states.items():\n                state_item = self._create_tree_item(\n                    state.name, item_id=state_id\n                )\n                site_item.appendRow(state_item)\n</code></pre>"},{"location":"dev/views/#TiBi.views.widgets.SystemTree.remove_tree_item","title":"<code>remove_tree_item(uc_id, site_id=None, state_id=None)</code>","text":"<p>Remove an item from the tree.</p> <p>If the item has a parent (i.e., is not a <code>UnitCell</code>), select the parent. Otherwise, clear the selection</p> <p>Parameters:</p> Name Type Description Default <code>uc_id</code> <code>UUID</code> <p>id of the <code>UnitCell</code></p> required <code>site_id</code> <code>UUID</code> <p>id of the <code>Site</code></p> <code>None</code> <code>state_id</code> <code>UUID</code> <p>id of the <code>State</code></p> <code>None</code> Source code in <code>TiBi/views/widgets/system_tree.py</code> <pre><code>def remove_tree_item(self, uc_id, site_id=None, state_id=None):\n    \"\"\"\n    Remove an item from the tree.\n\n    If the item has a parent\n    (i.e., is not a `UnitCell`), select the parent. Otherwise,\n    clear the selection\n\n    Parameters\n    ----------\n    uc_id : uuid.UUID\n        id of the `UnitCell`\n    site_id : uuid.UUID, optional\n        id of the `Site`\n    state_id : uuid.UUID, optional\n        id of the `State`\n    \"\"\"\n    item = self.find_item_by_id(uc_id, site_id, state_id)\n    if item:\n        # If the item is a unit cell, the parent is None, so we\n        # default to the invisibleRootItem\n        parent = item.parent() or self.root_node\n        # If the item has a parent, select it\n        if item.parent():\n            index = self.tree_model.indexFromItem(parent)\n            self.selectionModel().setCurrentIndex(\n                index, QItemSelectionModel.ClearAndSelect\n            )\n        # Otherwise, deselect everything (the item is a unit cell)\n        else:\n            self.selectionModel().clearSelection()\n            self.setCurrentIndex(QModelIndex())\n        # Delete the item\n        parent.removeRow(item.row())\n</code></pre>"},{"location":"user_guide/bands/","title":"Band structure and DOS","text":""},{"location":"user_guide/bands/#band-structrure-and-density-of-states","title":"Band Structrure and Density of States","text":"<p>This page describes how to set up the band structure and density of states computation. This functionality can be found under the Bands tab of the central panel.</p>"},{"location":"user_guide/bands/#bands","title":"Bands","text":"<p>Bands can only be computed if the system's dimensionality is greater than zero. The user defines a path through the Brillouin zone using its high-symmetry points as anchors, chooses the number of points in the path, and launches the calculation. Upon its completion, the bands are plotted.</p> <p>Warning</p> <p>Changing the system properties erases the computed bands to avoid stale data. Undoing the change does not reinstate the bands as storing this data in the undo stack could consume a lot of memory.</p> <p>Depending on the system dimensionality, the path can include the \u0393 point, vertices, edges, or faces of the Brillouin zone. Vertices, edges, and faces each have their own selection controls which are activated in accordance with the dimensionality. By clicking the up and down buttons, the user can change the selection of the particular type of high-symmetry points. By clicking the button \u0393, V, E, or F, the corresponding point is added to the path along which the bands will be calculated. As the path is constructed, it is updated in the Brillouin zone plot.</p> <p>The number of points in the path is set using the Points field. Clicking Compute launches the calculation and plots the bands upon its completion.</p> <p>Note</p> <p>The points are distributed along the path in a manner that guarantees the inclusion of the high-symmetry points while also respecting the distances between the points. Consequently, occasionally the number of points in the calculated path will differ from the value entered in the Points field.</p> <p>Info</p> <p>The approximate output size is estimated using the number of states in the system and the number of points in the path. In particular, because of the double precision and the complex eigenstates, the output for each point along the path takes \\((16\\times \\mathrm{states}^2+8\\times\\mathrm{states})\\) bytes. The total binary output size is obtained by multiplying this value by the number of points in the path. Finally, because the data is save in the JSON format, there is an additional factor of about 10 of overhead.</p>"},{"location":"user_guide/bands/#density-of-states","title":"Density of States","text":"<p>To obtain the density of states, the reciprocal space primitive cell is discretized by choosing the number of points along each reciprocal vector. The type of the grid (\u0393-centered or Monkhorst-Pack) is selected using the radio buttons. Clicking Compute launches the calculation and plots the density of states upon its completion.</p> <p>Warning</p> <p>Changing the system properties erases the computed grid to avoid stale data. Undoing the change does not reinstate the bands as storing this data in the undo stack could consume a lot of memory.</p> <p>The user can choose to visualize the density of states as a histogram or as a collection of Lorentzians. For the histogram option, one can choose the number of bins. For Lorentzians, the bin number functions as number of energies at which the density of states is computed, positioned equally between the minimum and maximum eigenvalues. Additionally, the broadening parameter controls the smoothing of the Lorentzian curves.</p>"},{"location":"user_guide/bands/#projection","title":"Projection","text":"<p>There is an option to project the results onto the system states. The states to be included in the projection can be selected from the dropdown menu. For the band plots, the weight of the projection is indicated by the radius of the scatterplot symbols plotted on top of the band lines. For the density of states histogram, the weight of each eigenstate is given by its projection onto the selected states. Finally, for the Lorentzian plot, each Lorentzian is scaled by the weight of the state's projection onto the selected states.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":""},{"location":"user_guide/getting_started/#getting-started","title":"Getting Started","text":"<p>This page describes the structure of a TiBi project and explains how to create, modify, and interpret its core components \u2014 systems, unit cells, sites, and states. It also explains how to build a tight-binding Hamiltonian that can be used for calculating various quantities of interest.</p>"},{"location":"user_guide/getting_started/#project-structure","title":"Project Structure","text":"<p>In TiBi, a single project can contain multiple systems. A system consists of a unit cell with sites (atoms). Each site can have an arbitrary number of states (orbitals).</p> <p>Example</p> <ul> <li> <p>Graphene (unit cell)</p> <ul> <li>A (site, sublattice A)  <ul> <li>pz (state, orbital) </li> </ul> </li> <li>B (site, sublattice B)  <ul> <li>pz (state, orbital) </li> </ul> </li> </ul> </li> <li> <p>BN (unit cell)</p> <ul> <li>B (site, boron)  <ul> <li>pz (state, orbital) </li> </ul> </li> <li>N (site, nitrogen)  <ul> <li>pz (state, orbital)  </li> </ul> </li> </ul> </li> </ul> <p>The orbitals couple to each other via hopping terms. Having multiple systems within a project makes it easy to compare their properties, such as the band structures of two graphene bilayers with different transverse electric fields.</p>"},{"location":"user_guide/getting_started/#creating-a-system","title":"Creating a System","text":"<p>To create a system, you\u2019ll define basis vectors, add sites to the unit cell, and attach states to each site. To start, click the + Add Unit Cell button in the project layout view. Once a new unit cell has been added, it is possible to rename it by double clicking on it in the project layout view. Press Enter to confirm the new name.</p>"},{"location":"user_guide/getting_started/#basis-vectors","title":"Basis Vectors","text":"<p>By default, unit cells start as cubic with no periodicity (i.e., 0D). This means that the unit cell is not repeated along any of its basis vectors. The dimensionality can be set between 0 and 3 by clicking the appropriate radio button. The system\u2019s dimensionality determines how the unit cell is repeated and how the Brillouin zone is computed. For \\(n\\)-dimensional systems, the unit cell is repeated along the first \\(n\\) basis vectors. You can edit each basis vector using the input fields next to it. Press Enter to apply changes. </p> <p>For notational consistency, there are certain restrictions on the basis vectors depending on the system dimensionality:</p> <ul> <li>0D: Basis vectors are orthogonal, with the first one pointing in the \\(x\\) direction, second in the \\(y\\) direction, and the third in the \\(z\\) direction.</li> <li>1D: Vector 1 is periodic. Basis vectors are orthogonal, with the first one pointing in the \\(x\\) direction, second in the \\(y\\) direction, and the third in the \\(z\\) direction. </li> <li>2D: Vectors 1 and 2 are periodic. The periodic vectors lie in the \\(xy\\) plane; the third vector points along the \\(z\\) direction.</li> <li>3D: Vectors 1, 2, and 3 are periodic. There is no restriction on their directions or magnitudes.</li> </ul> <p>To visualize the lattice even in the absence of any sites, click the Toggle wireframe button from the toolbar. Depending on the dimensionality, it is also possible to change the number of unit cells to be shown along each periodic vector.</p> <p>As the basis vectors and the dimensionality are modified, the Brillouin zone is updated. The Brillouin zone plot shows the edges and the high-symmetry points of the zone that are used for the band calculation:</p> <ul> <li>0D: the Brillouin zone contains a single \u0393 point</li> <li>1D: the Brillouin zone contains three points (\u0393 and two points at either end of the zone)</li> <li>2D: the high-symmetry points are the \u0393 point, vertices, and edge midpoints</li> <li>3D: the high-symmetry points are the \u0393 point, vertices, edge midpoints, and face centers</li> </ul> <p>Tip</p> <p>After defining a new unit cell, click the Reduce Unit Cell button. This step ensures that the basis is \"most orthogonal\", making sure that the algorithm for determining the Brillouin zone functions correctly. For example, if one were to pick \\(\\mathbf{v}_1\\) = (1,0,0) and \\(\\mathbf{v}_2\\) = (1,1,0), the reduction would set \\(\\mathbf{v}_2\\) = (0,1,0).</p> <p>If the volume of the unit cell is zero, the Brillouin zone is not shown.</p>"},{"location":"user_guide/getting_started/#sites","title":"Sites","text":"<p>Sites can be added to a selected unit cell by clicking the \"+\" icon next to its name in the project layout view. The sites can be renamed the same was as the unit cells. In addition to changing a site's name, it is also possible to modify its radius and color. These two properties are entirely cosmetic and their effect can be seen in the system view.</p> <p>The position of each site inside the unit cell is given by the fractional coordinates \\(c_1\\), \\(c_2\\), and \\(c_3\\), ranging from 0 to 1. As with the color and radius, the position is, strictly speaking, also a cosmetic feature since the coupling between different orbitals is determined by hopping elements, not the physical distance.</p>"},{"location":"user_guide/getting_started/#states","title":"States","text":"<p>States are added to sites by clicking the \"+\" icon next to the selected site's name. The states can also be renamed, just as unit cells and sites.</p> <p>Note</p> <p>States don\u2019t have an explicit energy parameter. Instead, the diagonal elements of the Hamiltonian (i.e., state energies) are defined as hopping terms from a state to itself. Therefore, the state energies are added when constructing the hopping matrix.</p> <p>Tip</p> <p>States, Sites, and Unit Cells can be deleted by either clicking the trash bin icon when the item or selected, or by pressing Backspace/Del keys.</p>"},{"location":"user_guide/getting_started/#hoppings","title":"Hoppings","text":"<p>After assembling the sites and states of the system, it is possible to introduce couplings between the states using the Hopping tab of the central panel.</p>"},{"location":"user_guide/getting_started/#coupling-matrix","title":"Coupling Matrix","text":"<p>The Hamiltonian of the system with \\(s\\) states can be represented by a \\(s \\times s\\) matrix. To build the Hamiltonian, TiBi provides a \\(s\\times s\\) button matrix, where each button contains the couplings between pairs of states. If the button is white, the two states do not couple directly. Pink color indicates that the states are coupled, but the couping is not Hermitian (i.e., the transpose partner of the button does not have the appropriate couplings). Finally, if the button is blue, the coupling is Hermitian. In this case, the transpose partner of the button will also be blue.</p>"},{"location":"user_guide/getting_started/#hopping-table","title":"Hopping Table","text":"<p>Clicking on a button in the coupling matrix brings up a table with 5 columns. Each table row corresponds to a single coupling between two states. The first three columns give the separation between the unit cells containing the two states in terms of the three basis vectors. The remaining two columns are the real and imaginary parts of the hopping term. The suggested workflow for adding the hoppings is as follows:</p> <ul> <li>After bringing up the table, click on the New Hopping button once or more to add hoppings between the selected states.</li> <li>Fill out the table with the appropriate values.</li> <li>Click the Save Hoppings button to update the coupling matrix.</li> <li>The newly-added hoppings will likely be non-Hermitian, indicated by the pink color of the hopping button. To make the Hamiltonian Hermitian, either right click on the hopping button currently being edited and select Set transpose element or click on the transpose button and select Get transpose element.</li> </ul> <p>Tip</p> <p>Clicking on the hopping buttons shows the existing hoppings in the 3D system plot making it easier to spot mistakes in the displacement columns of the hopping table.</p> <p>Note</p> <p>There are two details one should be aware of:</p> <ul> <li>If multiple hopping elements in the same table have the same displacement triplet, clicking Save will collect them into a single element.</li> <li>If a non-periodic vector has a non-zero entry in the displacement column, clicking Save will set it to zero.</li> </ul>"},{"location":"user_guide/install/","title":"Installation","text":""},{"location":"user_guide/install/#installation","title":"Installation","text":"<p>There are currently two ways to run the app: using a prebuilt binary or directly from source. In the future, standalone installers will also be provided.</p>"},{"location":"user_guide/install/#option-1-run-the-binary","title":"Option 1: Run the Binary","text":"<p>Prebuilt binaries (if available) can be downloaded from the Releases page. No installation is necessary\u2014just download and double-click the executable for your operating system.</p> <p>If no binary is available for your platform, you can either build one yourself using PyInstaller or run the app directly from source (see below).</p>"},{"location":"user_guide/install/#option-2-run-from-source","title":"Option 2: Run from Source","text":""},{"location":"user_guide/install/#1-download-the-source","title":"1. Download the Source","text":"<p>Download and extract the source archive from the Releases page, or clone the repository directly:</p> <pre><code>git clone https://github.com/rodinalex/TiBi.git\ncd TiBi\n</code></pre>"},{"location":"user_guide/install/#2-set-up-the-python-environment","title":"2. Set up the Python Environment","text":"<p>Option A: Using Conda (Recommended)</p> <pre><code>conda env create -f environment.yml\nconda activate TiBi-env\n</code></pre> <p>Option B: Using venv (if Conda causes issues)</p> <p>macOS/Linux:</p> <pre><code>python -m venv venv\n\n# Activate the environment:\nsource venv/bin/activate\n\npip install -r requirements.txt\n</code></pre> <p>Windows:</p> <pre><code>python -m venv venv\n\n# Activate the environment:\nvenv\\Scripts\\activate\n\npip install -r requirements.txt\n</code></pre>"},{"location":"user_guide/install/#3-launch-the-app","title":"3. Launch the App","text":"<p>macOS/Linux: <pre><code>python3 -m TiBi.app\n</code></pre></p> <p>Windows: <pre><code>python -m TiBi.app\n</code></pre> If the app does not launch, ensure that your virtual environment is activated and all dependencies are installed correctly.</p>"},{"location":"user_guide/install/#building-a-standalone-binary","title":"Building a Standalone Binary","text":"<p>To build the app as a self-contained binary, use the appropriate PyInstaller <code>.spec</code> file:</p> <p>macOS: <pre><code>pyinstaller app_mac.spec\n</code></pre></p> <p>Windows: <pre><code>pyinstaller app_win.spec\n</code></pre></p> <p>Linux: <pre><code>pyinstaller app_linux.spec\n</code></pre></p> <p>This will generate a bundled application in the <code>dist/</code> directory.</p>"},{"location":"user_guide/install/#running-the-built-application","title":"Running the Built Application","text":"<p>macOS <pre><code>./dist/TiBi.app/Contents/macOS/TiBi\n</code></pre> Or double-click <code>TiBi.app</code> in the <code>dist/</code> folder.</p> <p>Windows <pre><code>dist\\TiBi.exe\n</code></pre> Or double-click the executable in your file browser.</p> <p>Linux <pre><code>./dist/TiBi/TiBi\n</code></pre> Or launch from your file browser or terminal.</p>"},{"location":"user_guide/install/#notes","title":"Notes","text":"<ul> <li>Python 3.12+ is supported, but older systems may require Python 3.10 or 3.11.</li> <li>If you encounter issues with fonts, OpenGL, or window display, please open an issue on GitHub.</li> </ul>"}]}